[{"title":"编写高效优雅java代码","url":"https://www.mele.cool/2021/01/26/编写优雅高效的java代码/","content":"面向对象构造器参数太多怎么办\nJava类设计过程中，如果类的构造器或者静态工厂中具有多个参数，并且其中有大量的可选参数时，我们应该怎么办？\n\nTelescoping Constructor模式(重叠构造器)我们首先想到的方法肯定是传统的构造器\n/** * Created by itbird on 2017/3/23 */public class Person &#123;    private String name;    private String sex;    private int year;    public Person(String name, String sex, int year) &#123;        this.name = name;        this.sex = sex;        this.year = year;    &#125;&#125;\n但是设计以及使用过程中我们发现以下几点问题：\n\n属性参数逐渐变多时属性参数逐渐变多时，由于要对之前的代码做兼容，所以不可以直接在现有构造器后面追加属性，只能不断新增构造器/** * Created by itbird on 2017/3/23 */public class Person &#123;    private String name;    private String sex;    private int year;    private String city;    public Person(String name, String sex, int year) &#123;        this.name = name;        this.sex = sex;        this.year = year;    &#125;    public Person(String name, String sex, int year, String city) &#123;        this.name = name;        this.sex = sex;        this.year = year;        this.city = city;    &#125;&#125;\n属性参数中有大量的可选参数/** * Created by itbird on 2017/3/23 */public class Person &#123;    private String name;    private String sex;    private int year;    private String city;    private String state;    private boolean isFemale;    private boolean isEmployed;    private boolean isHomewOwner;    public Person(String name, String sex, int year) &#123;        this.name = name;        this.sex = sex;        this.year = year;    &#125;    public Person(String name, String sex, int year, String city) &#123;        this.name = name;        this.sex = sex;        this.year = year;        this.city = city;    &#125;    public Person(String name, String sex, int year, String city, String newState,                  boolean newIsFemale, boolean newIsEmployed, boolean newIsHomeOwner) &#123;        this.name = name;        this.sex = sex;        this.year = year;        this.city = city;        this.state = newState;        this.isFemale = newIsFemale;        this.isEmployed = newIsEmployed;        this.isHomewOwner = newIsHomeOwner;    &#125;&#125;\n显而易见，这样写的类构造器虽然无可厚非，但是当有许多参数的时候，客户端代码会很难编写，并且难以阅读。如果读者想知道那些值是什么意思，必须很仔细的数着这些参数来探个究竟。\n\nJavaBeans模式在这种模式下，调用一个无参构造器来创建对象，然后调用setter方法来设置每个必要的参数，以及每个相关的可选参数。\n/** * Created by itbird on 2017/3/23 */public class Person &#123;    private String name;    private String sex;    private int year;    private String city;    private String state;    private boolean isFemale;    private boolean isEmployed;    private boolean isHomewOwner;    public Person() &#123;    &#125;        public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getSex() &#123;        return sex;    &#125;    public void setSex(String sex) &#123;        this.sex = sex;    &#125;    public int getYear() &#123;        return year;    &#125;    public void setYear(int year) &#123;        this.year = year;    &#125;    public String getCity() &#123;        return city;    &#125;    public void setCity(String city) &#123;        this.city = city;    &#125;    public String getState() &#123;        return state;    &#125;    public void setState(String state) &#123;        this.state = state;    &#125;    public boolean isFemale() &#123;        return isFemale;    &#125;    public void setFemale(boolean female) &#123;        isFemale = female;    &#125;    public boolean isEmployed() &#123;        return isEmployed;    &#125;    public void setEmployed(boolean employed) &#123;        isEmployed = employed;    &#125;    public boolean isHomewOwner() &#123;        return isHomewOwner;    &#125;    public void setHomewOwner(boolean homewOwner) &#123;        isHomewOwner = homewOwner;    &#125;&#125;\n这种模式弥补重叠构造器模式的不足。说的明白一点，就是创建实例很容易，这样产生的代码读起来也很容易:\nPerson person = new Person();person.setCity(&quot;重庆&quot;);person.setYear(12);person.setSex(&quot;男&quot;);person.setName(&quot;itbird&quot;);\n遗憾的是，JavaBeans模式自身有着很严重的缺点。因为构造过程被分到几个调用中，在构造过程中JavaBean可能处于非一致的状态。JavaBeans模式阻止了把类做成不可变的可能，这就需要程序员付出额外的努力来确保他的线程安全。\nBuilder模式5个或者5个以上的成员变量 参数不多，但是在未来，参数会增加\npublic class Person &#123;    private String name;    private String sex;    private int year;    private String city;    private String state;    private boolean isFemale;    private boolean isEmployed;    private boolean isHomewOwner;    public Person() &#123;    &#125;    public static class PersonBuilder &#123;        // 必要参数        private String name;        // 可选参数        private String sex;        private int year;        private String city;        private String state;        private boolean isFemale;        private boolean isEmployed;        private boolean isHomewOwner;        public PersonBuilder(String name) &#123;            this.name = name;        &#125;        public PersonBuilder setSex(String sex) &#123;            this.sex = sex;            return this;        &#125;        public PersonBuilder setYear(int year) &#123;            this.year = year;            return this;        &#125;        public PersonBuilder setCity(String city) &#123;            this.city = city;            return this;        &#125;        public PersonBuilder setState(String state) &#123;            this.state = state;            return this;        &#125;        public PersonBuilder setFemale(boolean female) &#123;            isFemale = female;            return this;        &#125;        public PersonBuilder setEmployed(boolean employed) &#123;            isEmployed = employed;            return this;        &#125;        public PersonBuilder setHomewOwner(boolean homewOwner) &#123;            isHomewOwner = homewOwner;            return this;        &#125;        public Person build() &#123;            Person person = new Person();            person.name = name;            person.sex = sex;            person.city = city;            person.isEmployed = isEmployed;            person.isFemale = isFemale;            person.isHomewOwner = isHomewOwner;            person.state = state;            person.year = year;            return person;        &#125;    &#125;&#125;\n调用的实例:\nPerson person = new Person.PersonBuilder(&quot;itbird&quot;)                   .setCity(&quot;重庆&quot;).setYear(15).build();\n显然，使用Builder模式解决了上诉的难题，达到了“以不变(Builder)应万变(参数)”的目的。\n不需要实例化的类应该构造器私有​ 一些工具类提供的都是静态方法，这些类是不应该提供具体的实例的。可以参考JDK中的Arrays。\n不要创建不必要的对象\n反例\n该语句每次被执行的时候都创建一个新的String实例，但这些创建对象的动作全部都是不必要的。传递给String构造器的参数（”stringette”）本身就是一个String实例，功能方面等同于构造器创建的对象。如果这种用法实在一个循环中，或者在一个被频繁调用的方法中，就会创建出成千上万不必要的String实例。\n\n\n\nString s = new String(&quot;stringette&quot;);\n\n正例\n这个版本只用了一个String实例，而不是每一次执行代码都创建一个新的实例。\n\n\n\nString s = &quot;stringette&quot;;\n避免使用终结方法终结方法（finalizer）通常是不可预测的，也是很危险的，一般情况下是不必要的。使用终结方法会导致行为不稳定，降低性能以及可移植性问题。\n\n反例Foo foo = new Foo(...);try&#123;    //Do what must be done with foo    ...&#125;finally&#123;    foo.terminate();        //Explicit termination method&#125;\n使用终结方法的好处，它们有两种合法用途：\n\n第一种用途是，当对象的所有者忘记调用前面建议的显示终止方法的时，终结方法可以充当“安全网（safety net）”。迟一点释放关键资源总比永远不释放要好。但是如果终结方法发现资源还未被终止，则应该在日志中记录一条警告，因为这是客户端的一个BUG，应当被修复。\n第二种合理用途与对象的本地对等体（native peer）有关。本地对等体是一个本地对象（native object），普通对象通过本地方法（native method）委托给一个本地对象。因为本地对等体不是一个普通对象，所以垃圾回收器不会知道它，当它的Java对等体被回收的时候，它不会被回收。在本地对等体不拥有关键资源的前提下，终结方法正是执行这项任务最合适的工具。如果本地对等体拥有必须被及时终止的资源，那么该类就应该具有一个显示的终止方法，如前所述。终止方法应该完成所有必要的工作以便释放关键资源。终止方法可以是本地的，或者调用本地方法。\n使类和成员的可访问性最小化编写程序和设计架构，最重要的目标之一就是模块之间的解耦。使类和成员的可访问性最小化无疑是有效的途径之一。\n为什么要使类和成员的可访问性最小化可以有效的解除系统中各个模块的耦合度、实现每个模块的独立开发、使得系统更加的可维护，更加的健壮。\n如何最小化类和接口的可访问性？ 能将类和接口做成包级私有就一定要做成包级私有的。\n 如果一个类或者接口，只被另外的一个类应用，那么最好将这个类或者接口做成其内部的私有类或者接口。\n如何最小化一个了类中的成员的可访问性？首先设计出该类需要暴露出来的api，然后将剩下的成员的设计成private类型。然后再其他类需要访问某些private类型的成员时，在删掉private，使其变成包级私有。如果你发现你需要经常这样做，那么就请你重新设计一下这个类的api。对于protected类型的成员，作用域是整个系统，所以，能用包访问类型的成员的话就尽量不要使用保护行的成员。不能为了测试而将包中的类或者成员变为public类型的，最多只能设置成包级私有类型。实例域绝对不能是public类型的.使可变性最小化\n尽量使类不可变，不可变的类比可变的类更加易于设计、实现和使用，而且更不容易出错，更安全。\n\n常用的手段\n不提供任何可以修改对象状态的方法；\n使所有的域都是final的。\n使所有的域都是私有的。\n使用写时复制机制。带来的问题：会导致系统产生大量的对象，而且性能有一定的影响，需要在使用过程中小心权衡。优先使用复合继承容易破坏封装性，而且会使子类的实现依赖于父类。复合则是在类中增加一个私有域，引用类的一个实例，这样的话就避免了依赖类的具体实现。只有在子类确实是父类的一个子类型时，才比较适合用继承。\n\n接口优于抽象类java是个单继承的，但是类允许实现多个接口。所以当发生业务变化时，新增接口，并且需要进行业务变化的类现新接口即可。但是抽象类有可能导致不需要变化的类也不得不实现新增的业务方法。在JDK里常用的一种设计方法是：定义一个接口，声明一个抽象的骨架类实现接口，骨架类类实现通用的方法，而实际的业务类可以同时实现接口又继承骨架类，也可以只实现接口。如HashSet实现了implements Set接口 但是又extends 类AbstractSet，而AbstractSet本身也实现了Set接口。其他如Map，List都是这样的设计的。\n\n方法可变参数要谨慎使用可变参数是允许传0个参数的如果是参数个数在1~多个之间的时候，要做单独的业务控制。\n//可能很多 0~很多   static int sum(int... args) &#123;       int sum = 0;       for (int arg : args)           sum += arg;       return sum;   &#125;      //要求参数的个数，是1~多个   //   static int sum1(int... args) &#123;       if(args.length==0) &#123;           //做点异常处理       &#125;       if(args[0]==100) &#123;       &#125;       for(int i=1;i&lt;args.length;i++) &#123;           int sum = 0;           sum += args[i];           return sum;        &#125;   &#125;   static int sum2(int flag, int... args) &#123;       if(flag==100) &#123;       &#125;       int sum = 0;       for (int arg : args)           sum += arg;       return sum;       return Collections.EMPTY_LIST;   &#125;   \n优先使用标准的异常\n要尽量追求代码的重用，同时减少类加载的数目，提高类装载的性能。\n\nNullPointerException 在参数值不能为null的情况下参数值为null 抛出空指针异常\nIndexOutOfBoundsException 下标参数值越界 抛出索引越界异常\nConcurrentModificationException 在禁止并发修改的情况下，检测到对象的并发修改 抛出\nUnsupportedOperationException 对象不支持用户请求的方法 抛出\n\n让代码性能更高需要 Map 的主键和取值时，应该迭代 entrySet()当循环中只需要 Map 的主键时，迭代 keySet() 是正确的。但是，当需要主键和取值时，迭代 entrySet() 才是更高效的做法，比先迭代 keySet() 后再去 get 取值性能更佳。\n反例\nMap&lt;String, String&gt; map = ...;for (String key : map.keySet()) &#123;    String value = map.get(key);    ...&#125;\n正例\nMap&lt;String, String&gt; map = ...;for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;    String key = entry.getKey();    String value = entry.getValue();    ...&#125;\n应该使用Collection.isEmpty()检测空使用 Collection.size() 来检测空逻辑上没有问题，但是使用 Collection.isEmpty()使得代码更易读，并且可以获得更好的性能。任何 Collection.isEmpty() 实现的时间复杂度都是 O(1) ，但是某些 Collection.size() 实现的时间复杂度可能是 O(n) 。\n反例\nif (collection.size() == 0) &#123;    ...&#125;\n正例\nif (collection.isEmpty()) &#123;    ...&#125;\n如果需要还需要检测 null ，可采用\nCollectionUtils.isEmpty(collection)和CollectionUtils.isNotEmpty(collection)。\n不要把集合对象传给自己此外，由于某些方法要求参数在执行期间保持不变，因此将集合传递给自身可能会导致异常行为。\n反例\nList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Hello&quot;);list.add(&quot;World&quot;);if (list.containsAll(list)) &#123; // 无意义,总是返回true    ...&#125;list.removeAll(list); // 性能差, 直接使用clear()\n集合初始化尽量指定大小java 的集合类用起来十分方便，但是看源码可知，集合也是有大小限制的。每次扩容的时间复杂度很有可能是 O(n) ，所以尽量指定可预知的集合大小，能减少集合的扩容次数。\n反例\nint[] arr = new int[]&#123;1, 2, 3&#125;;List&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i : arr) &#123;    list.add(i);&#125;\n正例\nint[] arr = new int[]&#123;1, 2, 3&#125;;List&lt;Integer&gt; list = new ArrayList&lt;&gt;(arr.length);for (int i : arr) &#123;    list.add(i);&#125;\n字符串拼接使用 StringBuilder一般的字符串拼接在编译期 java 会进行优化，但是在循环中字符串拼接， java 编译器无法做到优化，所以需要使用 StringBuilder 进行替换。\n反例\nString s = &quot;&quot;;for (int i = 0; i &lt; 10; i++) &#123;    s += i;&#125;\n正例\nString a = &quot;a&quot;;String b = &quot;b&quot;;String c = &quot;c&quot;;String s = a + b + c; // 没问题，java编译器会进行优化StringBuilder sb = new StringBuilder();for (int i = 0; i &lt; 10; i++) &#123;    sb.append(i);  // 循环中，java编译器无法进行优化，所以要手动使用StringBuilder&#125;```java# List 的随机访问大家都知道数组和链表的区别：数组的随机访问效率更高。当调用方法获取到 List 后，如果想随机访问其中的数据，并不知道该数组内部实现是链表还是数组，怎么办呢？可以判断它是否实现 RandomAccess 接口。正例```java// 调用别人的服务获取到listList&lt;Integer&gt; list = otherService.getList();if (list instanceof RandomAccess) &#123;    // 内部数组实现，可以随机访问    System.out.println(list.get(list.size() - 1));&#125; else &#123;    // 内部可能是链表实现，随机访问效率低&#125;\n频繁调用 Collection.contains 方法请使用 Set在 java 集合类库中，List 的 contains 方法普遍时间复杂度是 O(n) ，如果在代码中需要频繁调用 contains 方法查找数据，可以先将 list 转换成 HashSet 实现，将 O(n) 的时间复杂度降为 O(1) 。\n反例\nArrayList&lt;Integer&gt; list = otherService.getList();for (int i = 0; i &lt;= Integer.MAX_VALUE; i++) &#123;    // 时间复杂度O(n)    list.contains(i);&#125;\n正例\nArrayList&lt;Integer&gt; list = otherService.getList();Set&lt;Integer&gt; set = new HashSet(list);for (int i = 0; i &lt;= Integer.MAX_VALUE; i++) &#123;    // 时间复杂度O(1)    set.contains(i);&#125;\n\n让代码更优雅长整型常量后添加大写 L在使用长整型常量值时，后面需要添加 L ，必须是大写的 L ，不能是小写的 l ，小写 l 容易跟数字 1 混淆而造成误解。\n反例\nlong value = 1l;long max = Math.max(1L, 5);\n正例\nlong value = 1L;long max = Math.max(1L, 5L);\n不要使用魔法值当你编写一段代码时，使用魔法值可能看起来很明确，但在调试时它们却不显得那么明确了。这就是为什么需要把魔法值定义为可读取常量的原因。但是，-1、0 和 1不被视为魔法值。\n反例\nfor (int i = 0; i &lt; 100; i++)&#123;    ...&#125;if (a == 100) &#123;    ...&#125;\n正例\nprivate static final int MAX_COUNT = 100;for (int i = 0; i &lt; MAX_COUNT; i++)&#123;    ...&#125;if (count == MAX_COUNT) &#123;    ...&#125;\n不要使用集合实现来赋值静态成员变量对于集合类型的静态成员变量，不要使用集合实现来赋值，应该使用静态代码块赋值。\n反例\nprivate static Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;() &#123;    &#123;        put(&quot;a&quot;, 1);        put(&quot;b&quot;, 2);    &#125;&#125;;private static List&lt;String&gt; list = new ArrayList&lt;String&gt;() &#123;    &#123;        add(&quot;a&quot;);        add(&quot;b&quot;);    &#125;&#125;;\n正例\nprivate static Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();static &#123;    map.put(&quot;a&quot;, 1);    map.put(&quot;b&quot;, 2);&#125;;private static List&lt;String&gt; list = new ArrayList&lt;&gt;();static &#123;    list.add(&quot;a&quot;);    list.add(&quot;b&quot;);&#125;;\n建议使用 try-with-resources 语句Java 7 中引入了 try-with-resources 语句，该语句能保证将相关资源关闭，优于原来的 try-catch-finally 语句，并且使程序代码更安全更简洁。\n反例\nprivate void handle(String fileName) &#123;    BufferedReader reader = null;    try &#123;        String line;        reader = new BufferedReader(new FileReader(fileName));        while ((line = reader.readLine()) != null) &#123;            ...        &#125;    &#125; catch (Exception e) &#123;        ...    &#125; finally &#123;        if (reader != null) &#123;            try &#123;                reader.close();            &#125; catch (IOException e) &#123;                ...            &#125;        &#125;    &#125;&#125;\n正例\n\n那什么是try-with-resource呢？简而言之，当一个外部资源的句柄对象（比如FileInputStream对象）实现了AutoCloseable接口，那么就可以将上面的板式代码简化为如下形式：\n\nprivate void handle(String fileName) &#123;    try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) &#123;        String line;        while ((line = reader.readLine()) != null) &#123;            ...        &#125;    &#125; catch (Exception e) &#123;        ...    &#125;&#125;\n将外部资源的句柄对象的创建放在try关键字后面的括号中，当这个try-catch代码块执行完毕后，Java会确保外部资源的close方法被调用。代码是不是瞬间简洁许多！\n删除未使用的私有方法和字段删除未使用的私有方法和字段，使代码更简洁更易维护。若有需要再使用，可以从历史提交中找回。\n反例\npublic class DoubleDemo1 &#123;    private int unusedField = 100;    private void unusedMethod() &#123;        ...    &#125;    public int sum(int a, int b) &#123;        return a + b;    &#125;&#125;\n正例\npublic class DoubleDemo1 &#123;    public int sum(int a, int b) &#123;        return a + b;    &#125;&#125;\n删除未使用的局部变量删除未使用的局部变量，使代码更简洁更易维护。\n反例\npublic int sum(int a, int b) &#123;    int c = 100;    return a + b;&#125;\n正例\npublic int sum(int a, int b) &#123;    return a + b;&#125;\n删除未使用的方法参数未使用的方法参数具有误导性，删除未使用的方法参数，使代码更简洁更易维护。但是，由于重写方法是基于父类或接口的方法定义，即便有未使用的方法参数，也是不能删除的。\n反例\npublic int sum(int a, int b, int c) &#123;    return a + b;&#125;\n正例\npublic int sum(int a, int b) &#123;    return a + b;&#125;\n删除表达式的多余括号对应表达式中的多余括号，有人认为有助于代码阅读，也有人认为完全没有必要。对于一个熟悉 Java 语法的人来说，表达式中的多余括号反而会让代码显得更繁琐。\n反例\nreturn (x);return (x + 2);int x = (y * 3) + 1;int m = (n * 4 + 2);\n正例\nreturn x;return x + 2;int x = y * 3 + 1;int m = n * 4 + 2;\n工具类应该屏蔽构造函数工具类是一堆静态字段和函数的集合，不应该被实例化。但是，Java 为每个没有明确定义构造函数的类添加了一个隐式公有构造函数。所以，为了避免 java “小白”使用有误，应该显式定义私有构造函数来屏蔽这个隐式公有构造函数。\n反例\npublic class MathUtils &#123;    public static final double PI = 3.1415926D;    public static int sum(int a, int b) &#123;        return a + b;    &#125;&#125;\n正例\npublic class MathUtils &#123;    public static final double PI = 3.1415926D;    private MathUtils() &#123;&#125;    public static int sum(int a, int b) &#123;        return a + b;    &#125;&#125;\n删除多余的异常捕获并抛出用 catch 语句捕获异常后，什么也不进行处理，就让异常重新抛出，这跟不捕获异常的效果一样，可以删除这块代码或添加别的处理。\n反例\nprivate static String readFile(String fileName) throws IOException &#123;    try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) &#123;        String line;        StringBuilder builder = new StringBuilder();        while ((line = reader.readLine()) != null) &#123;            builder.append(line);        &#125;        return builder.toString();    &#125; catch (Exception e) &#123;        throw e;    &#125;&#125;\n正例\nprivate static String readFile(String fileName) throws IOException &#123;    try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) &#123;        String line;        StringBuilder builder = new StringBuilder();        while ((line = reader.readLine()) != null) &#123;            builder.append(line);        &#125;        return builder.toString();    &#125;&#125;\n公有静态常量应该通过类访问虽然通过类的实例访问公有静态常量是允许的，但是容易让人它误认为每个类的实例都有一个公有静态常量。所以，公有静态常量应该直接通过类访问。\n反例\npublic class User &#123;    public static final String CONST_NAME = &quot;name&quot;;    ...&#125;User user = new User();String nameKey = user.CONST_NAME;\n正例\npublic class User &#123;    public static final String CONST_NAME = &quot;name&quot;;    ...&#125;String nameKey = User.CONST_NAME;\n不要用NullPointerException判断空空指针异常应该用代码规避（比如检测不为空），而不是用捕获异常的方式处理。\n反例\npublic String getUserName(User user) &#123;    try &#123;        return user.getName();    &#125; catch (NullPointerException e) &#123;        return null;    &#125;&#125;\n正例\npublic String getUserName(User user) &#123;    if (Objects.isNull(user)) &#123;        return null;    &#125;    return user.getName();&#125;\n使用String.valueOf(value)代替””+value当要把其它对象或类型转化为字符串时，使用 String.valueOf(value) 比””+value 的效率更高。\n反例\nint i = 1;String s = &quot;&quot; + i;\n正例\nint i = 1;String s = String.valueOf(i);\n过时代码添加 @Deprecated 注解当一段代码过时，但为了兼容又无法直接删除，不希望以后有人再使用它时，可以添加 @Deprecated 注解进行标记。在文档注释中添加 @deprecated 来进行解释，并提供可替代方案\n正例\n/** * 保存 * * @deprecated 此方法效率较低，请使用&#123;@link newSave()&#125;方法替换它 */@Deprecatedpublic void save()&#123;    // do something&#125;\n\n让代码远离 bug禁止使用构造方法 BigDecimal(double)BigDecimal(double) 存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。\n反例\nBigDecimal value = new BigDecimal(0.1D); // 0.100000000000000005551115...\n正例\nBigDecimal value = BigDecimal.valueOf(0.1D);; // 0.1\n返回空数组和空集合而不是 null返回 null ，需要调用方强制检测 null ，否则就会抛出空指针异常。返回空数组或空集合，有效地避免了调用方因为未检测 null 而抛出空指针异常，还可以删除调用方检测 null 的语句使代码更简洁。\n反例\npublic static Result[] getResults() &#123;    return null;&#125;public static List&lt;Result&gt; getResultList() &#123;    return null;&#125;public static Map&lt;String, Result&gt; getResultMap() &#123;    return null;&#125;public static void main(String[] args) &#123;    Result[] results = getResults();    if (results != null) &#123;        for (Result result : results) &#123;            ...        &#125;    &#125;    List&lt;Result&gt; resultList = getResultList();    if (resultList != null) &#123;        for (Result result : resultList) &#123;            ...        &#125;    &#125;    Map&lt;String, Result&gt; resultMap = getResultMap();    if (resultMap != null) &#123;        for (Map.Entry&lt;String, Result&gt; resultEntry : resultMap) &#123;            ...        &#125;    &#125;&#125;\n正例\npublic static Result[] getResults() &#123;    return new Result[0];&#125;public static List&lt;Result&gt; getResultList() &#123;    return Collections.emptyList();&#125;public static Map&lt;String, Result&gt; getResultMap() &#123;    return Collections.emptyMap();&#125;public static void main(String[] args) &#123;    Result[] results = getResults();    for (Result result : results) &#123;        ...    &#125;    List&lt;Result&gt; resultList = getResultList();    for (Result result : resultList) &#123;        ...    &#125;    Map&lt;String, Result&gt; resultMap = getResultMap();    for (Map.Entry&lt;String, Result&gt; resultEntry : resultMap) &#123;        ...    &#125;&#125;\n优先使用常量或确定值来调用 equals 方法对象的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals 方法。当然，使用 java.util.Objects.equals() 方法是最佳实践。\n反例\npublic void isFinished(OrderStatus status) &#123;    return status.equals(OrderStatus.FINISHED); // 可能抛空指针异常&#125;\n正例\npublic void isFinished(OrderStatus status) &#123;    return OrderStatus.FINISHED.equals(status);&#125;public void isFinished(OrderStatus status) &#123;    return Objects.equals(status, OrderStatus.FINISHED);&#125;\n枚举的属性字段必须是私有不可变枚举通常被当做常量使用，如果枚举中存在公共属性字段或设置字段方法，那么这些枚举常量的属性很容易被修改。理想情况下，枚举中的属性字段是私有的，并在私有构造函数中赋值，没有对应的 Setter 方法，最好加上 final 修饰符。\n反例\npublic enum UserStatus &#123;    DISABLED(0, &quot;禁用&quot;),    ENABLED(1, &quot;启用&quot;);    public int value;    private String description;    private UserStatus(int value, String description) &#123;        this.value = value;        this.description = description;    &#125;    public String getDescription() &#123;        return description;    &#125;    public void setDescription(String description) &#123;        this.description = description;    &#125;&#125;\n正例\npublic enum UserStatus &#123;    DISABLED(0, &quot;禁用&quot;),    ENABLED(1, &quot;启用&quot;);    private final int value;    private final String description;    private UserStatus(int value, String description) &#123;        this.value = value;        this.description = description;    &#125;    public int getValue() &#123;        return value;    &#125;    public String getDescription() &#123;        return description;    &#125;&#125;\n小心String.split(String regex)字符串 String 的 split 方法，传入的分隔字符串是正则表达式！部分关键字（比如.| 等）需要转义\n反例\n&quot;a.ab.abc&quot;.split(&quot;.&quot;); // 结果为[]&quot;a|ab|abc&quot;.split(&quot;|&quot;); // 结果为[&quot;a&quot;, &quot;|&quot;, &quot;a&quot;, &quot;b&quot;, &quot;|&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\n正例\n&quot;a.ab.abc&quot;.split(&quot;\\\\.&quot;); // 结果为[&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;]&quot;a|ab|abc&quot;.split(&quot;\\\\|&quot;); // 结果为[&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;]\n文章来源\n","categories":["java"],"tags":["java","常用"]},{"title":"redis入门效率版","url":"https://www.mele.cool/2021/01/23/redis教程效率版/","content":"安装wget http://download.redis.io/releases/redis-3.2.8.tar.gz#1.下载安装包 6.0.5版本wget http://download.redis.io/releases/redis-6.0.5.tar.gz#2.解压到指定文件夹tar -zxvf redis-6.0.5.tar.gz -C /usr/local/redis/#3.在编译安装前，查看系统gcc环境的版本（gcc -v），centos7默认安装的版本为4.8.5，该版本过低会无法进行安装，需要升级gcc到6以上。sudo yum -y install centos-release-sclsudo yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutilssudo scl enable devtoolset-9 bashsudo echo &quot;source /opt/rh/devtoolset-9/enable&quot; &gt;&gt; /etc/profilegcc -v#4.进入文件夹 编译cd /usr/local/redis/redis-6.0.5/make#编译并安装到指定文件夹sudo make &amp;&amp; sudo make install PREFIX=/usr/local/redis/redis-6.0.5#若编译报错:zmalloc.h:50:10: fatal error: jemalloc/jemalloc.h: No such file or directory#则使用命令:make MALLOC=libc#5.修改redis.conf的一些必要配置：daemonize no --&gt; yes  # 让redis启动的时候以后台服务的形式requirepass foobared --&gt; #设置redis的连接密码port 6379　　　　--&gt; #redis的启动端口，默认为6379#6.将redis做成服务，并设置成开机启动：#7.指定redis日志和数据存放目录mkdir -p /usr/local/redis/redis-6.0.5/logmkdir -p /usr/local/redis/redis-6.0.5/datavim redis.conf# 指定redis日志文件存放目录logfile &quot;/usr/local/redis/redis-6.0.5/log/redis.log&quot;#指定redis数据存放目录dir /usr/local/redis/redis-6.0.5/data\n\n\n基本使用\nC语言开发,依赖gcc环境.\n客户端启动会默认连接本机6379端口.\n特点:\n\n高效性.Redis读取的速度是110000次/s,写的速度是81000次/s\n\n原子性. Redis的所有操作都是原子性的,同时Redis还支持对几个操作全并后的原子性执行。\n\n稳定性:持久化,主外复制(集群) .\n\n其他特性:支持过期时间,支持事务,消息订阅。\n\n\n\n\nreids默认有16个数据库,命名是0 , 1 , 2 ….15,默认使用0号数据库,切换数据库使用命令select 2.\n\n移动数据到别的库:move key 2. 表示把key移到2库.\n\n清空当前数据库:flushdb\n\n清空redis服务器:flushall\n\n退出客户端:quit或摁ctrl c\n\n查询当前数据库中key的数量:dbsize\n\n查看当前redis信息:info\n\n\n#安装gcc环境yum install gcc-c++#启动服务端 前端启动,无法部署集群 ./redis/bin/redis-server#后端启动#1.修改redis.conf文件,开启守护线程: daemonize yes#2.命令启动./bin/redis-server ./redis.conf#启动客户端 默认连接本地6379端口./redis/bin/redis-cli#连接其他机器./bin/redis-cli -h ip -p 6379\n后台启动redis\n./bin/redis-server ./redis.conf\n\n关闭redis\nkill -9 进程号 或 ./bin/redis-cli shutdown\n\n数据类型\nkey都是字符串类型,value分为五种数据类型:String,hash,list,set,有序set\n\nString\n单个值最大512M,对应java中的map\n\n使用命令set key valueget keydel keygetset key valueincr keydecr keyappend keyincrby decrby \nhash\n示例:{username:”zhangsan”,age:”18”},类似JSON,对应java中的bean.\n\n使用命令#赋值hset key field value#赋值多个hmset key field value[field1 value1 field2 value2...]#取值hget key field#取值多个hmget key field1 field2...#取值全部hgetall key#查询key有几个fieldhlen key#查询hash所有fieldhkeys key#查询hash所有valuehvals key#删除hdel key field [field2 field3...]#删除整个hashdel key#增加值hincrby key field 10#判断field的value是否存在,存在返回1,否则返回0hexists key field\nlist\n示例:[1,2,3],对应linkedList链表集合,增删快.\nredis中是双向链表,增删极快.场景:大数据量集合操作,任务队列\n\n使用命令#左赋值lpush key a b c d #右赋值 符合习惯rpush key a b c d#取值,获取list中start到end的值.#start end 从0开始,可为负数,-1表示尾部元素,-2表示倒数第二个元素...lrange key start end#查询list长度llen key#删除左边第一个元素,若key不存在返回nil,存在返回第一个元素lpop key#删除右边最后一个元素rpop key#删除集合中所有a,若0改为2表示左边开始删2个,-2表示右边开始删2个   效率极低,因为需要给集合赋索引操作lrem key 0 a#在pivot元素前|后插入value  效率不高linsert kry before|after pivot value#替换下标为index的元素为value 效率不高lset key index value#将集合中尾部元素弹出,添加到头部,存入新集合list2 通过循环实现队列功能rpoplpush list1 list2#eg: list1为 a b c ,执行一次后:list1: a b list2:c#循环队列rpoplpush list1 list1\nset\n对应hashset,无序,不重复.\n场景:redis中涉及到两个集合的交集 并集 差集运算.\n\n使用命令#赋值,重复的会去除sadd key a b c d d#删除元素srem key a b#查询所有元素smembers key#查询a元素是否存在,存在返回1,否则返回0sismember key a#查询set中元素数量scard key#随机返回set中一个元素 伪随机srandmember key#差集运算,属于key1 不属于key2sdiff key1 key2#交集运算sinter key1 key2#并集运算sunion key1 key2#将差|并|交集存入新的set3中sdiffstore|sunionstore|sinterstore set3 set1 set2\n有序set\n有序,不重复.\n默认升序\n场景:排行榜 \n\n使用命令#赋值 zadd set1 500 xiaoming 200 xiaohong 100 xiaogang#查询xiaoming的分数zscore set1 xiaoming#查询元素数量zcard set1#查询所有元素zrange set1 0 -1#查询所有元素的分数zrange set1 0 -1 withscores#倒序查看所有元素 --&gt;排行榜zrevrange set1 0 -1 withscores#按分数范围查询元素. 后可加withscores显示分数.后可加limit 0 1查询前两名zrangebyscore set1 200 500#查询指定分数范围内有几个元素zcount set1 200 1000#查询xiaoming在set1中的排名 从小到大zrank set1 xiaoming#查询xiaoming在set1中的排名 从大到小zrevrank set1 xiaoming#删除元素zrem set1 xiaoming xiaohong#范围删除 删除前两名zremrangebyscore set1 0 1#加值 给xiaoming加200分zincrby set1 200 xiaoming\nredis通用命令#查询所有key  *表示0或多个 ?表示1个keys *#查询长度为4的keykeys ????#模糊查询 查询带name的keykeys *name*#删除key 删除多个keydel key [key2 key3...]#判断key是否存在 存在返回1否则返回0exists key#重命名key 不常用rname oldkey newkey#返回key的value的数据类型type key#设置key过期时间30秒,单位是秒,默认永久有效expire key 30#查询key剩余有效期时间,-2表示过期,会删除key.若未设置超时返回-1ttl key\nredis事务\nredis事务不是为了保证数据完整性,而是为了服务于批量操作.\n事务中报错并不会回滚,而是正常顺序执行.\n\n#开启事务multi#提交事务exec#回滚事务discard\nredis持久化\nredis默认所有增删改都是在内存中执行,因此提供了两种持久化策略\n\n\nRDB\n\n默认策略.\n相当于是照快照,保存的是一种状态,占用空间小.\n符合要求时会随时启动保存操作,占用系统资源(内存),适合内存充裕的服务器.\n大公司一般使用RDB策略.\n\n\n持久化操作何时进行?\n\n服务器正常关闭时 ./bin/redis-cli shutdown\n\n满足一定条件时.在redis.conf中可配置,但一般默认的即是最优配置.\n默认配置如下:\nSave 900 1       –&gt;每900秒(15分钟)有一个key变化,则照快照.\nsave 300 10     –&gt;每300秒(5分钟)有10个key变化,则照快照.\nsave 60 10000 –&gt;每60秒(1分钟)有10000个key变化,则照快照.\n\n\n\n\nAOF\n\n\n默认关闭.\n\n原理:使用日志功能保存数据,aof只会保存导致key变化的命令.\n\n优点:占用内存小;缺点:日志文件大,不适合灾备;恢复效率低.\n\n适用内存小的服务器.\n\n三种机制:\n\neverysec 每秒同步\nalways     每次修改同步\nno             不同步(默认)\n\n\n配置:\n\n修改redis.conf文件:\nAppendonly yes :开启aof\nappendfsync always:选择策略\n重启redis\n\n\n\n\n\n\n\nJedis\njedis是java连接操作redis的框架.\nredis有什么命令,jedis就有对应的方法.\n\n//单实例使用示例Jedis jedis = new Jedis(&quot;192.168.0.20&quot;,6379);//连接池JedisPoolConfig config = new JedisPoolConfig();config.setMaxTotal(50);//池中最大连接数config.setMaxIdle(10);//池中空闲时保留的最大连接数JedisPool pool = new JedisPool(config,&quot;192.168.0.20&quot;,6379);Jedis jedis = pool.getResource();jedis.getName(&quot;username&quot;);jedis.close();//连接归还池中.\n过期策略过期策略通常有以下三种:\n\n定时过期每个设置过期时间的key都需要创建一个定时器,到过期时间就会立即清除。该策略可以立即清除过期的数据,对内存很友好;但是会占用大量的CPU资源去处理过期的数据,从而影响缓存的响应时间和吞吐量。\n\n惰性过期.只有当访问一个key时,才会判断该key是否已过期,过期则清除。该策略可以最大化地节省CPU资源,却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问,从而不会被清除,占用大量内存。\n\n定期过期每隔一定的时间,会扫描一定数量的数据库的expires字典中一定数量的key,并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时,可以在不同情况下使得CPU和内存资源达到最优的平衡效果。.\n\n\n内存淘汰策略Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时,怎么处理需要新写入且需要申请额外空间的数据.\n实际项目中设置内存淘汰策略: maxmemory-policy allkey-lru,移除最近最少使用的key.\n过期策略默认是: maxmemory-policy noeviction\nredis.conf配置如下:\n# MAXMEMORY POLICY: how Redis will select what to remove when maxmemory# is reached. You can select one from the following behaviors:#最大内存策略:当到达最大使用内存时,你可以在下面5种行为中选择, Redis如何选择淘汰数据库键 当内存不足以容纳新写入数据时# volatile-lru -&gt; Evict using approximated LRU, only keys with an expire set.#在设置了过期时间的键空间中,移除最近最少使用的key,这种情况一般是把redis既当缓存，又做持久化存储的时候才用。# allkeys-lru -&gt; Evict any key using approximated LRU.#移除最近最少使用的key (推荐)# volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire set.# allkeys-lfu -&gt; Evict any key using approximated LFU.# volatile-random -&gt; Remove a random key having an expire set.#在设置了过期时间的键空间中，随机移除一个键，不推荐# allkeys-random -&gt; Remove a random key, any key.#直接在键空间中随机移除一个键,弄啥叻# volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)#在设置了过期时间的键空间中,有更早过期时间的key优先移除不推荐# noeviction -&gt; Don&#x27;t evict anything, just return an error on write operations.#不做过键处理,只返回一个写操作错误。不推荐\n\n\nRedis的主从复制架构.\n主从复制,是指将一台Redis服务器的数据,复制到其他的Redis服务器。前者称为主节点(master),后者称为从节点(slave),数据的复制是单向的,只能由主节点到从节点。\n默认情况下,每台Redis服务器都是主节点;且一个主节点可以有多个从节点(或没有从节点),但一个从节点只能有一个主节点。\n\n原理\n当从数据库启动后,会向主数据库发送SYNC命令\n主数据库接收到SYNC命令后开始在后台保存快照(RDB持久化) ,并将保存快照期间接收到的命令缓存进来.\n快照完成后, Redis (Master)将快照文件和所有缓存的命令发送给从数据库\nRedis (Slave)接收到RDB和缓存命令时,会开始载入快照文件并执行接收到的缓存的命令\n后续,每当主数据库接收到写命令时,就会将命令同步给从数据库。所以3和4只会在初始化的时候执行\n\n场景\n备份容错(如果只有一个节点,会存在单点故障问题)\n读写分离(读多写少的场景很适用) ,如果写操作很多,就得使用集群\n从数据库持久化(可以将持久化的性能消耗移动到从节点) \n\n搭建# 修改从节点的配置文件redis.confvim redis.conf#修改\t\t主节点ip\t\t主节点portslaveof masterip masterport\n哨兵\nSentinel (哨兵)是Redis的高可用性解决方案:由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器,以及这些主服务器属下的所有从服务器,并在被监视的主服务器进入下线状态时,自动将下线主服务器属下的某个从服务器升级为新的主服务器。\n\n配置哨兵\n每台服务器都要修改sentinel.conf文件配置哨兵.\n一般哨兵的配置节点数不能是1个,最好是有几个主从节点,就配置几个哨兵。不能哨兵自己出现单点故障\n\n#1 修改主节点配置文件vim sentinel.conf#15行 每台机器修改为自己对应的主机各bind 127.0.0.1 192.168.1.1#修改后台运行daemonize yes#三台机器监控的主节点#\tmonitor监控,master-name服务器名称可自定义,ip服务器ip,quorum为2时2代表只有两个或两个以上的哨兵认为主服务器不可用的时候,才会进行failover操作。\t\t\tsentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;#如果Redis是有密码的,需要指定密码# 定义服务的密码, mymaster服务名称, 123456是Redis服务器密码# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;#2 把配置文件复制到其他节点服务器scp sentinel.conf 从节点1ip:$PWDscp sentinel.conf 从节点2ip:$PWD#分别修改从节点配置文件,绑定自己机器的ipbind 从节点1ipbind 从节点2ip#3 每台服务器启动哨兵服务bin/redis-sentinel sentinel.conf#4 验证哨兵启动是否成功#查看Sentinel master的状态 连接哨兵 26379是哨兵端口bin/redis-cli -h 从节点2ip -p 263794#使用ping命令检查哨兵是否工作,如果正常会返回PONG#使用命令info,可以查看主节点有几个从节点,及几个哨兵.\n哨兵模式下的代码连接\n哨兵模式下,代码中就不能配置主节点连接信息,因为主节点可能挂掉,所以应该配置哨兵的连接信息,并使用JedisSentinelPool来创建连接池。\n\n集群docker搭建redis集群创建模板及脚本\n在/usr/local/server/redis-cluster/目录下创建一个模板,把可变参数传入;\n\n#集群各节点公共配置模板#端口 port $&#123;PORT&#125; #非保护模式 若开启则每次都需输入密码 protected-mode no #启用集群模式 cluster-enabled yes cluster-config-file nodes.conf #超时时间 cluster-node-timeout 5000 #集群各节点IP地址 cluster-announce-ip 192.168.2.110#集群节点映射端口 cluster-announce-port $&#123;PORT&#125; #集群总线端口 cluster-announce-bus-port 1$&#123;PORT&#125; #开启aof持久化策略 appendonly yes #后台运行 #daemonize yes #进程号存储 pidfile /var/run/redis_$&#123;PORT&#125;.pid #集群加密 #masterauth itheima #requirepass itheima\n\n创建redis创建容器脚本:\n\n#!/bin/bash#在/usr/local/server/redis-cluster下生成conf和data目标，并生成配置信息#输入信息read -p &quot;请输入本机IP地址：&quot; Native_IP# 创建文件夹mkdir -p /usr/local/server/redis-cluster# 下载redis配置模板echo &quot;正在下载redis-cluster.tmpl配置模板，请手动下载redis-cluster.tmpl文件并复制到/usr/local/server/redis-cluster目录&quot;;# 文件下载地址 请手动下载redis-cluster.tmpl文件#wget -P /usr/local/server/redis-cluster https://srv-file22.gofile.io/download/RoGvVk/redis-cluster.tmplecho &quot;正在创建redis-net网络&quot;;#c创建网络docker network create redis-netecho &quot;正在创建redis配置文件&quot;;for port in `seq 7001 7006`; do   mkdir -p /usr/local/server/redis-cluster/$&#123;port&#125;/conf &amp;&amp; PORT=$&#123;port&#125; Native_IP=$&#123;Native_IP&#125;  envsubst &lt; /usr/local/server/redis-cluster/redis-cluster.tmpl &gt; /usr/local/server/redis-cluster/$&#123;port&#125;/conf/redis.conf &amp;&amp; mkdir -p /usr/local/server/redis-cluster/$&#123;port&#125;/data;doneecho &quot;正在启动redis容器&quot;;#创建6个redis容器for port in `seq 7001 7006`;do\tdocker run -d -it -p $&#123;port&#125;:$&#123;port&#125; -p 1$&#123;port&#125;:1$&#123;port&#125; -v /usr/local/server/redis-cluster/$&#123;port&#125;/conf/redis.conf:/usr/local/etc/redis/redis.conf -v /usr/local/server/redis-cluster/$&#123;port&#125;/data:/data --privileged=true --restart always --name redis-$&#123;port&#125; --net redis-net --sysctl net.core.somaxconn=1024 redis redis-server /usr/local/etc/redis/redis.conf;done#查找ipfor port in `seq 7001 7006`;do\techo  -n &quot;$(docker inspect --format &#x27;&#123;&#123; (index .NetworkSettings.Networks &quot;redis-net&quot;).IPAddress &#125;&#125;&#x27; &quot;redis-$&#123;port&#125;&quot;)&quot;:$&#123;port&#125;&quot; &quot;;done#换行echo -e &quot;\\n&quot;#输入信息read -p &quot;请把输入要启动的docker容器名称，默认redis-7001：&quot; DOCKER_NAME#判断是否为空if [ ! $DOCKER_NAME ]; \tthen DOCKER_NAME=&#x27;redis-7001&#x27;; fi#进入容器docker exec -it redis-7001 /bin/bash# 删除容器#docker rm -f $(docker ps -a |  grep &quot;redis-*&quot;  | awk &#x27;&#123;print $1&#125;&#x27;)\n\n创建删除脚本\n\n#!/bin/bashecho &quot;正在停止所有redis容器&quot;;docker stop $(docker ps -a |  grep &quot;redis-*&quot;  | awk &#x27;&#123;print $1&#125;&#x27;)echo &quot;正在删除所有redis容器&quot;;docker rm -f $(docker ps -a |  grep &quot;redis-*&quot;  | awk &#x27;&#123;print $1&#125;&#x27;)echo &quot;正在删除redis-net网络&quot;;docker network rm redis-netecho &quot;正在删除/usr/local/server目录&quot;;#rm -rf /usr/local/serverrm -rf 7001 7002 7003 7004 7005 7006\n执行脚本,创建容器,创建集群\n执行redis.sh脚本,创建容器,创建集群:\n\n#1 执行脚本 创建容器./redis.sh[root@localhost redis-cluster]# ./redis.sh 请输入本机IP地址：192.168.2.110正在下载redis-cluster.tmpl配置模板，请手动下载redis-cluster.tmpl文件并复制到/usr/local/server/redis-cluster目录正在创建redis-net网络2f24ef5a195f41775f7cd85d56218d6a7f34591f349c7c835d26b6c4ec9be019正在创建redis配置文件正在启动redis容器df2ceae9f7e44a2ebe4727d06717db7f636693ef8a2ff42458ce7e3cf573893786e34c9145760f65394615e221ec886d9634775966cfd30bb33a41a2ba0b8963fdda9586b0987c6d207b840290e5c21fc1ca624574404a3db744d54bdc074177f0c725bc27884e319a7d16575dc919063a8999d2d6ab1a62773af7ce3aee227f9a2373144fed4b48fb9a168cdc1ecb2fbbd3d5f08a8314580c6e4a5d2216ca321d0ed018e4c6ec2f6b292f668ac6d47658a183a7b5aa5839395eb098c2e46356172.18.0.2:7001 172.18.0.3:7002 172.18.0.4:7003 172.18.0.5:7004 172.18.0.6:7005 172.18.0.7:7006 #按回车确认请把输入要启动的docker容器名称，默认redis-7001：#2 创建集群cd /usr/local/bin/#进入到任意一个安装好的redis节点的bin目录，里面有个脚本对象redis-cli，然后执行集群创建 #--cluster-replicas 1 表示每个主节点有一个从节点./redis-cli --cluster create 172.18.0.2:7001 172.18.0.3:7002 172.18.0.4:7003 172.18.0.5:7004 172.18.0.6:7005 172.18.0.7:7006 --cluster-replicas 1\n验证集群是否创建成功#进入任意一个节点cd /usr/local/bin#连接任意节点 ./redis-cli -p 7001 -c #执行赋值操作,可看到进行了重定向操作:7001重定向到了7003,说明集群创建成功. #重定向原理:redis根据key值进行crc16%16384,计算出该key应该存到哪个节点的哈希槽中 127.0.0.1:7001&gt; set username zhangsan-&gt; Redirected to slot [14315] located at 192.168.2.110:7003OK192.168.2.110:7003&gt; #也可以在节点中执行cluster nodes查看集群中节点信息,及哈希槽分配信息.192.168.2.110:7003&gt; cluster nodes76579cdead091c604e60e03454bab68ae69caa36 192.168.2.110:7004@17004 slave 52c2332c4271dba57d3be960d5feef2334b767e5 0 1611586728573 3 connectedb7dde8f6eb6f0385303e45bc54c588e8ea422acf 192.168.2.110:7005@17005 slave 8bddaceb3363a9675e48e6a76c4194c50cc545ac 0 1611586729588 1 connected52c2332c4271dba57d3be960d5feef2334b767e5 192.168.2.110:7003@17003 myself,master - 0 1611586727000 3 connected 10923-163838bddaceb3363a9675e48e6a76c4194c50cc545ac 192.168.2.110:7001@17001 master - 0 1611586729000 1 connected 0-54604967d4c7cd28c8601eb9de843f1a1d449a343a7c 192.168.2.110:7006@17006 slave 21d108f7cb03af71f707fb314b730a76c33b8c74 0 1611586728000 2 connected21d108f7cb03af71f707fb314b730a76c33b8c74 192.168.2.110:7002@17002 master - 0 1611586727561 2 connected 5461-10922192.168.2.110:7003&gt; \n\n\n创建集群遇到的问题rpc error: code = 2 desc = oci runtime error: exec failed: container_linux.go:247: starting containe#查看我的docker 版本docker --versionDocker version 1.13.1, build 07f3374/1.13.1#更新yum 即可修复 （如果yum的仓库连接不成功， 可以使用阿里仓库） yum update -y\n创建集群后,一直点点点等待连接\n相关端口未打开\nfirewall-cmd --zone=public --add-port=7001/tcp --permanent   # 开放7001端口firewall-cmd --zone=public --remove-port=17001/tcp --permanent  #关闭17001端口firewall-cmd --reload   # 配置立即生效\n\n\n\n集群的扩容通过启动两个节点7007 7008,一主一从#docker安装Redis这里编写了一个脚本，安装脚本 redis-port.sh 如下#!/bin/bash #在/usr/local/server/redis-cluster下生成conf和data目标，并生成配置信息 #换行 echo -e &quot;\\n&quot; #输入信息 read -p &quot;请输入容器端口：&quot; DOCKER_PORT#输入端口赋值port=$DOCKER_PORT;echo -e &quot;$port&quot;#创建配置文件mkdir -p ./$&#123;port&#125;/conf &amp;&amp; PORT=$&#123;port&#125; envsubst &lt; ./redis-cluster.tmpl &gt; ./$&#123;port&#125;/conf/redis.conf &amp;&amp; mkdir -p ./$&#123;port&#125;/data;#创建redis容器docker run -d -it -p $&#123;port&#125;:$&#123;port&#125; -p 1$&#123;port&#125;:1$&#123;port&#125; -v /usr/local/server/redis-cluster/$&#123;port&#125;/conf/redis.conf:/usr/local/etc/redis/redis.conf -v /usr/local/server/redis-cluster/$&#123;port&#125;/data:/data --privileged=true --restart always --name redis-$&#123;port&#125; --net redis-net --sysctl net.core.somaxconn=1024 redis redis-server /usr/local/etc/redis/redis.conf;#查找ipecho -n &quot;启动$(docker inspect --format &#x27;&#123;&#123; (index .NetworkSettings.Networks &quot;redis- net&quot;).IPAddress &#125;&#125;&#x27; &quot;redis-$&#123;port&#125;&quot;)&quot;:$&#123;port&#125;&quot; 成功！&quot;;echo -e &quot;\\n&quot;\n启动完成,把7007加进集群,并分配哈希槽.#1 查看主节点信息 和从节点信息[root@localhost bin]# ./redis-cli -p 7001 cluster nodes|grep master52c2332c4271dba57d3be960d5feef2334b767e5 192.168.2.110:7003@17003 master - 0 1611589610513 3 connected 10923-163838bddaceb3363a9675e48e6a76c4194c50cc545ac 192.168.2.110:7001@17001 myself,master - 0 1611589610000 1 connected 0-546021d108f7cb03af71f707fb314b730a76c33b8c74 192.168.2.110:7002@17002 master - 0 1611589611527 2 connected 5461-10922[root@localhost bin]# ./redis-cli -p 7001 cluster nodes|grep slave4967d4c7cd28c8601eb9de843f1a1d449a343a7c 192.168.2.110:7006@17006 slave 21d108f7cb03af71f707fb314b730a76c33b8c74 0 1611589702041 2 connected76579cdead091c604e60e03454bab68ae69caa36 192.168.2.110:7004@17004 slave 52c2332c4271dba57d3be960d5feef2334b767e5 0 1611589702000 3 connectedb7dde8f6eb6f0385303e45bc54c588e8ea422acf 192.168.2.110:7005@17005 slave 8bddaceb3363a9675e48e6a76c4194c50cc545ac 0 1611589701540 1 connected[root@localhost bin]# #2 把7007添加到集群中#命令说明 将节点192.168.2.110:7007添加到节点192.168.2.110:7001所在的集群中./redis-cli --cluster add-node 192.168.2.110:7007 192.168.2.110:7001# 3 再次查看主节点信息,已能看到7007节点,但是7007没有分配哈希槽[root@localhost bin]# ./redis-cli -p 7001 cluster nodes|grep master52c2332c4271dba57d3be960d5feef2334b767e5 192.168.2.110:7003@17003 master - 0 1611590983590 3 connected 10923-163838bddaceb3363a9675e48e6a76c4194c50cc545ac 192.168.2.110:7001@17001 myself,master - 0 1611590981000 1 connected 0-546021d108f7cb03af71f707fb314b730a76c33b8c74 192.168.2.110:7002@17002 master - 0 1611590983000 2 connected 5461-10922eaf055c10e03a10e6493194bc3389d65919c3ecb 192.168.2.110:7007@17007 master - 0 1611590983590 0 connected#4 重新分配哈希槽#我们将 7001,7002,7003 中的 100 个哈希槽挪给 7007 ，命令如下：./redis-cli --cluster reshard 192.168.2.110:7001 --cluster-from 8bddaceb3363a9675e48e6a76c4194c50cc545ac,21d108f7cb03af71f707fb314b730a76c33b8c74,52c2332c4271dba57d3be960d5feef2334b767e5 --cluster-to eaf055c10e03a10e6493194bc3389d65919c3ecb --cluster-slots 100# 参数说明#--cluster-from：表示slot目前所在的节点的node ID，多个ID用逗号分隔 #--cluster-to：表示需要新分配节点的node ID #--cluster-slots：分配的slot数量# 5 再次查看主节点信息,哈希槽已成功分配给7007[root@localhost bin]# ./redis-cli -p 7001 cluster nodes|grep master52c2332c4271dba57d3be960d5feef2334b767e5 192.168.2.110:7003@17003 master - 0 1611591101000 3 connected 10956-163838bddaceb3363a9675e48e6a76c4194c50cc545ac 192.168.2.110:7001@17001 myself,master - 0 1611591102000 1 connected 33-546021d108f7cb03af71f707fb314b730a76c33b8c74 192.168.2.110:7002@17002 master - 0 1611591101598 2 connected 5495-10922eaf055c10e03a10e6493194bc3389d65919c3ecb 192.168.2.110:7007@17007 master - 0 1611591102514 7 connected 0-32 5461-5494 10923-10955[root@localhost bin]# \n把7008加进7007的从节点\n我们需要往集群中给 7007 节点添加一个从节点 7008 ，添加从节点的主要目的是提高高可用，防止主节点宕机后该节点无法提供服务。添加从节点命令如下：\n&gt;./redis-cli --cluster add-node 192.168.2.110:7008 192.168.2.110:7007 --cluster-slave --cluster-master-id eaf055c10e03a10e6493194bc3389d65919c3ecb&gt;#参数说明&gt;#add-node: 后面的分别跟着新加入的slave和slave对应的master &gt;#cluster-slave：表示加入的是slave节点 &gt;#--cluster-master-id：表示slave对应的master的node ID&gt;#再次查看从节点信息,7008已加入&gt;[root@localhost bin]# ./redis-cli -p 7001 cluster nodes|grep slavebdcc8f4553c05fe408a75045ca910b5156d5a11c 192.168.2.110:7008@17008 slave eaf055c10e03a10e6493194bc3389d65919c3ecb 0 1611591482000 7 connected&gt;4967d4c7cd28c8601eb9de843f1a1d449a343a7c 192.168.2.110:7006@17006 slave 21d108f7cb03af71f707fb314b730a76c33b8c74 0 1611591481472 2 connected&gt;76579cdead091c604e60e03454bab68ae69caa36 192.168.2.110:7004@17004 slave 52c2332c4271dba57d3be960d5feef2334b767e5 0 1611591482181 3 connected&gt;b7dde8f6eb6f0385303e45bc54c588e8ea422acf 192.168.2.110:7005@17005 slave 8bddaceb3363a9675e48e6a76c4194c50cc545ac 0 1611591482484 1 connected&gt;[root@localhost bin]# \n\n\n\n集群的收容集群面试题\n问题一: Redis的多数据库机制,了解多少?\n\n正常版: Redis支持多个数据库,并且每个数据库的数据是隔离的不能共享,单机下的redis可以支持16个数据库(dbo ~db15) ;高调版:在Redis Cluster集群架构下只有一个数据库空间,即dbo,因此,我们没有使用Redis的多数据库功能！\n\n\n问题二:懂Redis的批量操作么?\n\n正常版:懂一点。比如mset, mget操作等, blabla…高调版:在生产上采用的是Redis Cluster集群架构,不同的key会划分到不同的slot中,因此直接使用mset或者mget等操作是行不通的。\n\n\n问题三: Redis集群机制中,你觉得有什么不足的地方吗?.\n\n正常版:不知道高调版:假设有一个key,对应的value是Hash类型的。如果Hash对象非常大,是不支持映射到不同节点的!只能映射到集群中的一个节点上!还有就是做批量操作比较麻烦!\n\n\n问题四:在Redis集群模式下,如何进行批量操作?\n\n正常版：不知道高调版：如果执行的key数是比较少,就不用mget了,就用串行get操作。如果真的需要执行的key很多,就使用Hashtag保证这些key映射到同一台redis节点上。简单来说语法如下:\n\n\n 对于key为(foo}.student1, {foo}.student2, {foo}.student3,这类key一定是在同一个redis节点上。因为key中”{}”之间的字符串就是当前key的hash tags,只有key中{}中的部分才被用来做hash,因此计算出来的redis节点一定是同一个!\n\n\n问题五:懂Redis事务么?.\n\n正常版: Redis事务是一些列redis命令的集合,blabla..高调版：在生产上采用的是Redis Cluster集群架构，不同的key是有可能分配在不同的Redis节点上的,在这种情况下Redis的事务机制是不生效的。其次，Redis事务不支持回滚操作,简直是鸡肋,基本不用!\n\n\n\n缓存穿透 缓存击穿 缓存雪崩缓存穿透: key对应的数据在数据源并不存在,每次针对此key的请求从缓存获取不到,请求都会到数据源,从而可能压垮数据源。                一言以蔽之:查询Key,缓存和数据源都没有,频繁查询数据源\n\n比如用一个不存在的用户id获取用户信息,无论论缓存还是数据库都没有,若黑客利用此漏洞进行攻击可能压垮数据库。解决缓存穿透的方案主要有两种:.方案一:当查询不存在时,也将结果保存在缓存中。但是这可能会存在一种问题:大量没有查询结果的请求保存在缓存中,这时我们就可以将这些请求的key设置得更短一些; .方案二:**提前过滤掉不合法的请求,可以使用Redis中布隆过滤器**(快速过滤不存在的key,但是对于已经存在的key无法准确判断是否存在);\n\n缓存击穿: key对应的数据存在,但在redis中过期,此时若有大量并发请求过来,这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存,这个时候大并发的请求可能会瞬间把后端DB压垮\n\n​    一言以蔽之:查询Key,缓存过期,大量并发,频繁查询数据派\n业界比较常用的做法:使用互斥锁。简单地来说,就是在缓存失效的时候(判断拿出来的值为空) ,不是立即去load db (查询数据库) ,而是先使用缓存工具的某些带成功操作返回值的操作(比如Redis的SETNX或者Memcache的ADD)去set一个mutex key,就是只让一个线程构建缓存,其他线程等待构建缓存的线程执行完,重新从缓存获取数据。\nstring get(String key)&#123;  String value = redis.get(key);\tif (value == null)&#123;\t\t//如果key不存在,则设置为1\t\tif (redis.setnx(key_mutex, &quot;1&quot;)) &#123; \t\t\t//设置key的过期时间为3分钟\t\t\tredis.expire(key_mutex, 3 * 60) ;\t\t\t//从db中加载数据，但注意：只有一个线程能进入到这里,其他线程访问的时候已有课key_mutex\t\t\tvalue =db.get(key); \t\t\t//从数据库中加载成功,则设置对应的数据\t\t\tredis.set(key, value);\t\t\tredis.delete(key_mutex);  \t \t&#125; else &#123; \t\t\t//其他线程休息50毫秒后重试    \tThread.sleep (50);\t\t\tget(key);  \t&#125;\t&#125;&#125;\n缓存雪崩:当缓存服务器重启或者大量缓存集中在某一个时间段失效,这样在失效的时候,也会给后端系统(比如DB)带来很大压力。\n\n\n一言以蔽之:缓存不可用(服务器重启或缓存失效) ,频繁查询数据源与缓存击穿的区别在于这里针对很多key缓存,前者则是某一个key。\n缓存失效时的雪崩效应对底层系统的冲击非常可怕!大多数系统设计者考虑用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写,从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时**将缓存失效时间分散开,**比如可以在原有的失效时间基础上增加一个随机值,比如1-5分钟随机,这样每一个缓存的过期时间的重复率就会降低,就很难引发集体失效的事件。\n\n","categories":["db"],"tags":["redis"]},{"title":"开发中注意的小问题","url":"https://www.mele.cool/2021/01/22/开发注意代码整理/","content":"拼接in字段String mergeString = list.stream().map(demo -&gt; “‘“ + demo.getUserCode() + “‘“).distinct().collect(Collectors.joining(“,”));\nstream操作集合时注意判空,否则遇空会报错usercodess = users.stream().filter(map -&gt; StringUtils.isNotBlank((String) map.get(&quot;userCode&quot;))).collect(Collectors.groupingBy(map -&gt; (String) map.get(&quot;userCode&quot;)));\nstream的group操作1:value是集合Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; usercodess = users.stream().filter(map -&gt; StringUtils.isNotBlank((String) map.get(&quot;userCode&quot;))).collect(Collectors.groupingBy(map -&gt; (String) map.get(&quot;userCode&quot;)));\nstream的group操作2:value是集合中对象某字段的和Map&lt;String, Integer&gt; collect1 = resultList.stream().filter(item -&gt; StringUtils.isNotBlank(item.getGroupCode()))\t.collect(Collectors.groupingBy(ComplCountVO::getGroupCode, Collectors.summingInt(ComplCountVO::getComplAmount)));\ncontroller类或方法加注解防止跨域@CrossOrigin\n\n使用Sharding-JDBC多线程补偿HintManager.clear();HintManager hintManager = HintManager.getInstance();try &#123;\thintManager.setDatabaseShardingValue(customerserviceRoomUserVO.getRootDeptCode());\t//业务代码   &#125;catch (Exception e)&#123;\tthrow e;&#125;finally &#123;\thintManager.close();&#125;\n集合拆分：List&lt;List&lt;String&gt;&gt; partition = new ArrayList&lt;&gt;();if (roomCodeList.size()&gt;500)&#123;\tpartition = Lists.partition(roomCodeList, 500);&#125;else &#123;\tpartition.add(roomCodeList);&#125;\nmybatis参数条件集合\nif条件判断时需注意，如果字段类型是Integer，则不能使用,因为Integer无法和空字符串做比较。\n\n&lt;if test=&quot;roomCodeList!= null and roomCodeList.size&gt;0&quot;&gt;\tand b.room_code in\t&lt;foreach collection=&quot;roomCodeList&quot; index=&quot;index&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot; item=&quot;item&quot; &gt;\t\t#&#123;item&#125;\t&lt;/foreach&gt;&lt;/if&gt;\nfeign调用注解\nGET方式传参为对象或map时加注解 @SpringQueryMapPOST方式传参记得加注解 @RequestBody\n\n点击eureka中服务自动到swagger界面eureka.instance.status-page-url=http://$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;/swagger-ui.html#/\n写swagger代码\n对象入参@ApiOperation(value = &quot;方法功能&quot;)   @ApiImplicitParams(&#123;           @ApiImplicitParam(name = &quot;paramDTO&quot;, required = true, dataType = &quot;ParamDTO&quot;, value = &quot;字段含义&quot;, paramType = &quot;body&quot;),   &#125;)\n@Data@Accessors(chain = true)@ApiModel(description = &quot;参数对象说明&quot;)public class FeeOrderDTO &#123;    @ApiModelProperty(value = &quot;字段名称&quot;, example = &quot;传参示例&quot;, required = true)    @NotBlank(message = &quot;业主编码不能为空&quot;)    private String  ownerCode;&#125;\n零散入参@ApiOperation(value = &quot;方法功能&quot;)@ApiImplicitParams(&#123;        @ApiImplicitParam(name = &quot;levelCode&quot;, required = true, dataType = &quot;String&quot;, value = &quot;参数名称&quot;, paramType = &quot;header&quot;),        @ApiImplicitParam(name = &quot;userName&quot;, required = true, dataType = &quot;String&quot;, value = &quot;参数名称&quot;, paramType = &quot;query&quot;),&#125;)\neasyExcel导出excel\n\n依赖&lt;!--alibaba easy excel--&gt;&lt;dependency&gt;\t&lt;groupId&gt;com.alibaba&lt;/groupId&gt;\t&lt;artifactId&gt;easyexcel&lt;/artifactId&gt;\t&lt;version&gt;2.2.6&lt;/version&gt;&lt;/dependency&gt;\n实现代码import com.alibaba.excel.EasyExcel;   public void exportExcel(HttpServletResponse response, ParamVO paramVO) throws IOException &#123;       Assert.isBlank(paramVO.getUserCode(), &quot;用户编码不能为空&quot;);\tSimpleDateFormat df = new SimpleDateFormat(&quot;yyyyMMddHHmmssSSS&quot;);       // 组装导出数据       List&lt;ExportData&gt; recordExportData = testDaoGetList(paramVO);       if (CollectionUtils.isEmpty(recordExportData)) &#123;           throw new ServiceException(&quot;不存在要导出的数据&quot;);       &#125; else &#123;           response.setContentType(&quot;application/vnd.ms-excel&quot;);           response.setCharacterEncoding(&quot;utf-8&quot;);           String tempName = &quot;文件名&quot; + df.format(new Date());           log.info(&quot;导出文件名是:&quot; + tempName);           String fileName = URLEncoder.encode(tempName, &quot;UTF-8&quot;).replaceAll(&quot;\\\\+&quot;, &quot;%20&quot;);           response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename*=utf-8&#x27;&#x27;&quot; + fileName + &quot;.xlsx&quot;);           // 获取要导出的模板数据           EasyExcel.write(response.getOutputStream(), ExportData.class).sheet(&quot;template&quot;).doWrite(recordExportData);       &#125;   &#125;\n模板类package com.test;import com.alibaba.excel.annotation.ExcelProperty;import com.alibaba.excel.annotation.write.style.ColumnWidth;import lombok.Data;import java.math.BigDecimal;/** * 功能描述：导出模板 *\t生成excel列顺序由类中字段顺序决定。 * @Author: admin * @Date: 2020/11/24 10:36 */@Data//单元格宽度@ColumnWidth(value = 20)public class ExportData &#123;    @ExcelProperty(value = &quot;列名1&quot;)\tprivate BigDecimal money;    @ExcelProperty(value = &quot;列名2&quot;)\tprivate String name;&#125;","categories":["java"],"tags":["mybatis","java","bug","常用","代码","excel","stream","注解","swagger"]},{"title":"SQL语句性能提升","url":"https://www.mele.cool/2021/01/02/SQL语句性能提升/","content":"1.数据准备\n1). 准备tb_sku表, 导入数据 - 数据1000w\n2). 准备tb_seller表,导入数据 - 数据12条 \n\n2.慢查询分析2.1.show profiles\nshow profiles 是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优测量,show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。\n\n通过 have_profiling 参数，能够看到当前MySQL是否支持profile：\n\n默认profiling是关闭的，可以通过set语句在Session级别开启profiling： \n\nset profiling=1; //开启profiling 开关；\n通过profile，我们能够更清楚地了解SQL执行的过程。首先，我们可以执行一系列的操作:\nshow databases; use db01; show tables; select * from tb_ksu where id &lt; 5; select count(*) from tb_ksu;\n执行完上述命令之后，再执行show profiles 指令， 来查看SQL语句执行的耗时：通过show profile for query query_id 语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间：\n\n\nTIP ：\nSending data 状态表示MySQL线程开始访问数据行并把结果返回给客户端，而不仅仅是返回个客户端。 \n由于在Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整各查询中耗时最长的状态。 \n\n在获取到最消耗时间的线程状态后，MySQL支持进一步选择all、cpu、block io 、context switch、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间。例如，选择查看CPU的耗费时间 ： \n\n\n\n字段\n含义\n\n\n\nStatus\nsql 语句执行的状态\n\n\nDuration\nsql 执行过程中每一个步骤的耗时\n\n\nCPU_user\n当前用户占有的cpu\n\n\nCPU_system\n系统占有的cpu\n\n\n2.2 慢查询日志\n慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于min_examined_row_limit 的所有的SQL语句的日志。long_query_time 默认为 10 秒，最小为 0， 精度可以到微秒。\n\n2.2.1 文件位置和格式慢查询日志默认是关闭的 。可以通过两个参数来控制慢查询日志 ： \n# 该参数用来控制慢查询日志是否开启， 可取值： 1 和 0 ， 1 代表开启， 0 代表关闭 slow_query_log=1 # 该参数用来指定慢查询日志的文件名 slow_query_log_file=slow_query.log# 该选项用来配置查询的时间限制， 超过这个时间将认为是慢查询， 将进行日志记录， 默认10s long_query_time=10\n2.2.2 日志的读取慢查询日志记录的格式也是纯文本，可以被直接读取。\n1） 查询long_query_time 的值。\n\n2） 执行查询操作\n-- 由于该语句执行时间很短，为0s ， 所以不会记录在慢查询日志中。select * from tb_sku where id = &#x27;100000030074&#x27;\\G;  -- \\G表示换行显示数据-- 该SQL语句 ， 执行时长为 24.28s ，超过10s ， 所以会记录在慢查询日志文件中。select * from tb_sku where name like &#x27;%HuaWei手机Meta87384 Pro%&#x27;\\G;\n3） 查看慢查询日志文件\n直接通过cat 指令查询该日志文件 ：\n如果慢查询日志内容很多， 直接查看文件，比较麻烦， 这个时候可以借助于mysql自带的\nmysqldumpslow 工具， 来对慢查询日志进行分类汇总。\n\n3. explain执行计划通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN或者 DESC命令获取 MySQL如何执\n行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。\n查询SQL语句的执行计划 ： \nexplain select * from tb_sku where id = &#x27;100000030074&#x27;;\n\n\n\n\n字段\n含义\n\n\n\nid\nselect查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。\n\n\nSelect_type\n表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个SELECT）等\n\n\ntable\n输出结果集的表\n\n\ntype\n表示表的连接类型，性能由好到差的连接类型为( system —&gt; const—–&gt; eq_ref ——&gt; ref ——-&gt; ref_or_null—-&gt;index_merge —&gt; index_subquery —–&gt; range —–&gt;index ——&gt; all )\n\n\npossible_keys\n表示查询时，可能使用的索引\n\n\nkey\n表示实际使用的索引\n\n\nKey_len\n索引字段的长度\n\n\nrows\n扫描行的数量\n\n\nExtra\n执行情况的说明和描述\n\n\n1). id\nid 字段是 select查询的序列号是一组数字表示的是查询中执行select子句或者是操作表的顺序。\nid 情况有三种 ：\nA. id 相同表示加载表的顺序是从上到下。\nB. id 不同id值越大，优先级越高，越先被执行。\nC. id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。\n2). select_type\n表示 SELECT 的类型，常见的取值，如下表所示：\n\n3). type\ntype 显示的是访问类型，是较为重要的一个指标，可取值为：\n一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref\n4). key\nA. possible_keys : 显示可能应用在这张表的索引， 一个或多个。\nB. key ： 实际使用的索引， 如果为NULL， 则没有使用索引。\nC. key_len : 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。\n5). rows\n扫描行的数量。\n6). filtered\n这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例。\n4. 索引的使用4.1 概述及作用MySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。\n优势：\n1） 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。\n2） 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。\n劣势：\n1） 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。\n2） 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。\n4.2 索引结构MySQL数据库中默认的存储引擎InnoDB的索引结构为B+树，而根据叶子节点的内存存储不同，索引类\n型分为主键索引和非主键索引。\n主键索引的叶子节点存储的是整行数据，在InnoDB中主键索引页被称为聚簇索引。其结构如下：\n而非主键索引的叶子节点内容存储时的主键的值，在InnoDB中，非主键索引也被称为二级索引或辅助索引。其结构如下：\n\n4.3 验证索引在tb_sku表中一共存在1000w的记录 ;\nA. 根据主键ID查询速度很快\n\nB. 根据name查询速度变慢\nC.对name字段建立索引再次查询,速度很快.\ncreate index idx_sku_name on tb_sku(name);\n4.4 索引使用规则没有建立索引之前, 执行计划如下\n\n建立索引 : \ncreate index idx_seller_name_status_address on tb_seller(name, status, seller);\n1). 全值匹配 ，对索引中所有列都指定具体值。\n该情况下，索引生效，执行效率高。\nexplain select * from tb_seller where name=&#x27;小米科技&#x27; and status=&#x27;1&#x27; and address=&#x27;北京市&#x27;;\n\n2). 最左前缀法则\n如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列(并非要求索引第一字段必须在第一位,出现即可.)。\n匹配最左前缀法则，走索引：\n\n违法最左前缀法则 ， 索引失效:\n\n如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效：\n\n3). 范围查询右边的列，不能使用索引 。\n\n根据前面的两个字段name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。\n4). 不要在索引列上进行运算操作， 索引将失效。\n\n5). 字符串不加单引号，造成索引失效。\n\n由于，在查询时，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，造成索引失效。\n6). 用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。\n示例，name字段是索引列 ， 而createtime不是索引列，中间是or进行连接是不走索引的 :\nexplain select * from tb_seller where name=&#x27;黑马程序员&#x27; or createtime = &#x27;2088-01-01 12:00:00&#x27;\\G;\n\n7). 以%开头的Like模糊查询，索引失效。\n如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。\n\n解决方案 ：\n通过覆盖索引来解决\n\n8). 如果MySQL评估使用索引比全表更慢，则不使用索引。\n\n9). is NULL ， is NOT NULL 有时索引失效。\n\n10). in ， not in 有时索引失效\n\n11). 尽量使用覆盖索引，避免select *\n尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。\n\n如果查询列，超出索引列，也会降低性能。\n\nTIP :\nusing index ：使用覆盖索引的时候就会出现 \nusing where：在查找使用索引的情况下，需要回表去查询所需的数据 \nusing index condition：查找使用了索引，但是需要回表查询数据 \nusing index ; using where：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据 \n\n4.5 索引设计原则\n对查询频次较高，且数据量比较大的表建立索引。\n\n索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。\n\n使用唯一索引，区分度越高，使用索引的效率越高。\n\n索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。\n\n使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。\n\n利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。\n\n\n5. 常见的SQL优化5.1 环境准备CREATE TABLE `emp` (   `id` int(11) NOT NULL AUTO_INCREMENT,   `name` varchar(100) NOT NULL, `age` int(3) NOT NULL,   `salary` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;insert into `emp` (`id`, `name`, `age`, `salary`) values(&#x27;1&#x27;,&#x27;Tom&#x27;,&#x27;25&#x27;,&#x27;2300&#x27;); insert into `emp` (`id`, `name`, `age`, `salary`) values(&#x27;2&#x27;,&#x27;Jerry&#x27;,&#x27;30&#x27;,&#x27;3500&#x27;); insert into `emp` (`id`, `name`, `age`, `salary`) values(&#x27;3&#x27;,&#x27;Luci&#x27;,&#x27;25&#x27;,&#x27;2800&#x27;);insert into `emp` (`id`, `name`, `age`, `salary`) values(&#x27;4&#x27;,&#x27;Jay&#x27;,&#x27;36&#x27;,&#x27;3500&#x27;);insert into `emp` (`id`, `name`, `age`, `salary`) values(&#x27;5&#x27;,&#x27;Tom2&#x27;,&#x27;21&#x27;,&#x27;2200&#x27;); insert into `emp` (`id`, `name`, `age`, `salary`) values(&#x27;6&#x27;,&#x27;Jerry2&#x27;,&#x27;31&#x27;,&#x27;3300&#x27;);insert into `emp` (`id`, `name`, `age`, `salary`) values(&#x27;7&#x27;,&#x27;Luci2&#x27;,&#x27;26&#x27;,&#x27;2700&#x27;); insert into `emp` (`id`, `name`, `age`, `salary`) values(&#x27;8&#x27;,&#x27;Jay2&#x27;,&#x27;33&#x27;,&#x27;3500&#x27;); insert into `emp` (`id`, `name`, `age`, `salary`) values(&#x27;9&#x27;,&#x27;Tom3&#x27;,&#x27;23&#x27;,&#x27;2400&#x27;); insert into `emp` (`id`, `name`, `age`, `salary`) values(&#x27;10&#x27;,&#x27;Jerry3&#x27;,&#x27;32&#x27;,&#x27;3100&#x27;); insert into `emp` (`id`, `name`, `age`, `salary`) values(&#x27;11&#x27;,&#x27;Luci3&#x27;,&#x27;26&#x27;,&#x27;2900&#x27;);\n5.2 order by优化5.2.1 两种排序方式1). 第一种是通过对返回数据进行排序，也就是通常说的 filesort 排序，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。\n2). 第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。\n\n多字段排序\n了解了MySQL的排序方式，优化目标就清晰了：尽量减少额外的排序，通过索引直接返回有序数据。\nwhere 条件和Order by 使用相同的索引，并且Order By 的顺序和索引顺序相同， 并且Order by 的字段都是升序，或者都是降序。否则肯定需要额外的操作，这样就会出现FileSort。\n5.2.2 Filesort 的优化通过创建合适的索引，能够减少 Filesort 的出现，但是在某些情况下，条件限制不能让Filesort消失，那就需要加快 Filesort的排序操作。对于Filesort ， MySQL 现在采用的是一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要高。\nMySQL 通过比较系统变量 max_length_for_sort_data 的大小和Query语句取出的字段总大小， 来判定是否那种排序算法，如果max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种。\n可以适当提高 sort_buffer_size 和 max_length_for_sort_data 系统变量，来增大排序区的大小，提高排序的效率。\n\n5.3 group by优化由于GROUP BY 实际上也同样会进行排序操作，而且与ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作。当然，如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。所以，在GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引。\n如果查询包含 group by 但是用户想要避免排序结果的消耗， 则可以执行order by null 禁止排序。如下 ：\nexplain select age,count(*) from emp group by age;\n\n优化后:\nexplain select age,count(*) from emp group by age order by null;\n\n从上面的例子可以看出，第一个SQL语句需要进行”filesort”，而第二个SQL由于order by null 不需要进行 “filesort”， 而上文提过Filesort往往非常耗费时间。\n创建索引 ： \ncreate index idx_emp_age_salary on emp(age,salary);\n\n5.4 limit优化limit分页操作, 越往后, 性能越低 :\n优化方案: \nselect * from tb_sku t , (select id from tb_sku order by id limit 9000000,1) a where t.id = a.id;\n5.5 count优化在很多的业务系统中，都需要考虑进行分页操作，但是当我们执行分页操作时，都需要进行一次count操作，求取总记录数，如果数据库表的数据量大，在InnoDB引擎中，执行count操作的性能是比较低的，需要遍历全表数据，对计数进行累加。\n优化方案：\n①. 在大数据量的查询中，只查询数据， 而不展示总记录数 ； \n②. 通过缓存redis维护一个表的计数，来记录数据库表的总记录数，在执行插入/删除时，需要动态更新；\n③. 在数据库表中定义一个大数据量的计数表，在执行插入/删除时，需要动态更新。\n弊端:无法满足各种带where条件的count查询.\n5.6 大批量插入优化使用load命令!\n环境准备:\nCREATE TABLE `tb_user` (  `id` INT(11) NOT NULL AUTO_INCREMENT,   `username` VARCHAR(50) NOT NULL,   `password` VARCHAR(50) NOT NULL,   `name` VARCHAR(20) NOT NULL,   `birthday` DATE DEFAULT NULL,  `sex` CHAR(1) DEFAULT NULL,   PRIMARY KEY (`id`),   UNIQUE KEY `unique_user_username` (`username`)) ENGINE=INNODB DEFAULT CHARSET=utf8 ;\nLoad使用:\n-- fields terminated by &#x27;,&#x27; lines terminated by &#x27;\\n&#x27;可自定义别的符号.load data local infile &#x27;/root/sql1.log&#x27; into table `tb_user` fields terminated by &#x27;,&#x27; lines terminated by &#x27;\\n&#x27;;\n5.6.1 对于 InnoDB 类型的表，有以下几种方式可以提高导入的效率：1） 主键顺序插入因为InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。\n\n\n2） 关闭唯一性校验在导入数据前执行 SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行 SET UNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。\n\n3） 手动提交事务如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行 SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。\n\n","categories":["db"],"tags":["sql优化","explain"]},{"title":"集合分页工具类","url":"https://www.mele.cool/2020/12/15/集合分页工具类/","content":"工具类package com.test.demo;import java.util.Collections;import java.util.List;/** * 集合分页工具类 * @param &lt;T&gt; */public class ListPageUtil&lt;T&gt; &#123;    private List&lt;T&gt; data;    /** 上一页 */    private int lastPage;    /** 当前页 */    private int currentPage;    /** 下一页 */    private int nextPage;//    /** 每页条数 */    private int pageSize;    /** 总页数 */    private int totalPage;    /** 总数据条数 */    private int totalCount;    public ListPageUtil(List&lt;T&gt; data,int currentPage,int pageSize) &#123;        if (data == null || data.isEmpty()) &#123;            throw new IllegalArgumentException(&quot;data must be not empty!&quot;);        &#125;        this.data = data;        this.pageSize = pageSize;        this.currentPage = currentPage;        this.totalCount = data.size();        this.totalPage = (totalCount + pageSize - 1) / pageSize;        this.lastPage = currentPage-1&gt;1? currentPage-1:1;        this.nextPage = currentPage&gt;=totalPage? totalPage: currentPage + 1;    &#125;    public int getPageSize() &#123;        return pageSize;    &#125;    public List&lt;T&gt; getData() &#123;        int fromIndex = (currentPage - 1) * pageSize;        if (fromIndex &gt;= data.size()) &#123;            return Collections.emptyList();//空数组        &#125;        if(fromIndex&lt;0)&#123;            return Collections.emptyList();//空数组        &#125;        int toIndex = currentPage * pageSize;        if (toIndex &gt;= data.size()) &#123;            toIndex = data.size();        &#125;        return data.subList(fromIndex, toIndex);    &#125;    public int getLastPage() &#123;        return lastPage;    &#125;    public int getCurrentPage() &#123;        return currentPage;    &#125;    public int getNextPage() &#123;        return nextPage;    &#125;    public int getTotalPage() &#123;        return totalPage;    &#125;    public int getTotalCount() &#123;        return totalCount;    &#125;&#125;\n使用示例package com.test.demo;import java.io.IOException;import java.util.ArrayList;import java.util.List;public class Test &#123;    public static void main(String[] args) throws IOException &#123;        List&lt;String&gt; strings = new ArrayList&lt;&gt;();        for(int i=0;i&lt;100;i++)&#123;            strings.add(&quot;str_&quot;+i);        &#125;        ListPageUtil&lt;String&gt; pageInfo = new ListPageUtil&lt;&gt;(strings, 1, 10);        System.err.println(&quot;分页数据：&quot;+pageInfo.getData());        System.err.println(&quot;总页数：&quot;+pageInfo.getTotalPage());        System.err.println(&quot;总条数：&quot;+pageInfo.getTotalCount());    &#125;&#125;\n\n","categories":["工具类"],"tags":["工具类","java","分页","集合"]},{"title":"只修改几行，git却显示整个文件都被修改","url":"https://www.mele.cool/2020/12/10/只修改几行，git却显示整个文件都被修改/","content":"问题从git上拉取服务端代码，然后只修改了一处地方，准备提交时，用diff软件查看，却发现整个文件都被修改了。这是git自动转换换行符导致的问题。博主遇到的问题是，git提交时无异常，但是到gerrit上合代码时发现整个文件都被修改了。\n原因不同操作系统使用的换行符是不一样的。Unix/Linux使用的是LF，Mac后期也采用了LF，但Windows一直使用CRLF【回车(CR, ASCII 13, \\r) 换行(LF, ASCII 10, \\n)】作为换行符。而git入库的代码采用的是LF格式，它考虑到了跨平台协作的场景，提供了“换行符自动转换”的功能：如果在Windows下安装git，在拉取文件时，会自动将LF换行符替换为CRLF；在提交时，又会将CRLF转回LF。但是这个转换是有问题的：有时提交时，CRLF转回LF可能会不工作，尤其是文件中出现中文字符后有换行符时。\n解决方案禁用git的自动换行功能.在本地路径C:\\ Users\\ [用户名] \\ .gitconfig下修改git配置[core]，如果没有就直接添加上去：\n[core]    autocrlf &#x3D; false    filemode &#x3D; false    safecrlf &#x3D; true\n或者，git bash命令行也可以修改，最终也是修改.gitconfig配置文件：分别执行：\ngit config --global core.autocrlf falsegit config --global core.filemode falsegit config --global core.safecrlf true\n配置IDE开发环境，将它的换行格式指定为LF.http://mele.cool/idea_setting.png\n注意。使用diff查看时，会展示本地文件和远程文件的换行格式，只有两边一致时，上传上去才不会出现上述问题，如图：http://mele.cool/git_diff.png\n","categories":["bug"],"tags":["git","bug","idea"]},{"title":"使用freemarker导出word","url":"https://www.mele.cool/2020/12/10/导出word/","content":"\n整体步骤：\n\n制作要导出的word模板，另存为xml格式，使用idea编辑。\nxml模板编辑完成，修改文件格式为ftl格式。\n编写代码，封装导出数据，使用模板。\n\n\n\n注意：编写模板时，同一行文字应先在记事本中写好复制到模板中，不然生成xml文件后会自动换行。\n\n0.依赖&lt;!--word导出 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.freemarker&lt;/groupId&gt;    &lt;artifactId&gt;freemarker&lt;/artifactId&gt;    &lt;version&gt;2.3.28&lt;/version&gt;&lt;/dependency&gt;\n1.Controller@GetMapping(&quot;/exportWord&quot;)   public void exportWord(@RequestHeader(value = &quot;deptCode&quot;, required = true) String rootDeptCode,@Valid ParamVo vo, HttpServletResponse response)&#123;       String filePath = testService.exportWord(rootDeptCode,vo);       File file = null;       InputStream fin = null;       ServletOutputStream out = null;       try &#123;           if (StringUtil.isEmpty(filePath))&#123;               return;           &#125;           file = new File(filePath);           fin = new FileInputStream(file);           String fileName = &quot;bill-charge&quot;;           response.setContentType(&quot;application/x-download&quot;);\t\t//下面三行是关键代码，处理乱码问题           response.setCharacterEncoding(&quot;utf-8&quot;);           response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;+new String(fileName.getBytes(&quot;gbk&quot;), &quot;iso8859-1&quot;)+&quot;.doc&quot;);           out = response.getOutputStream();           byte[] buffer = new byte[512]; // 缓冲区           int bytesToRead;           // 通过循环将读入的Word文件的内容输出到浏览器中           while((bytesToRead = fin.read(buffer)) != -1) &#123;               out.write(buffer, 0, bytesToRead);           &#125;       &#125;catch (Exception e) &#123;           e.printStackTrace();           log.info(&quot;导出异常：&quot; + e.getMessage());       &#125;finally &#123;           try&#123;               if (fin != null) &#123;fin.close();&#125;               if (out != null) &#123;out.close();&#125;               if (file != null) &#123;file.delete();&#125; // 删除临时文件           &#125; catch (Exception e)&#123;               log.info(&quot;导出错误&quot;);           &#125;       &#125;   &#125;\n2.service@Override    public String exportWord(String rootDeptCode,ParamVo feeBillVo) &#123;        /** 1 查询业务数据集合*/       List&lt;T&gt; exportList = new ArrayList&lt;&gt;();\t    /** 2 封装导出*/        DateTimeFormatter df = DateTimeFormatter.ofPattern(&quot;yyyyMMddHHmmssSSS&quot;);        String format = df.format(LocalDateTime.now());        try &#123;            WordExport emw = new WordExport();            Map&lt;String, Object&gt; dataMap = new HashMap&lt;&gt;();\t\t\t//需要遍历            dataMap.put(&quot;feeList&quot;, exportList);\t\t\t//直接显示，无需遍历            dataMap.put(&quot;deptNameZhang&quot;, &quot;whatever&quot;);            emw.createWord(dataMap, &quot;bill-charge.ftl&quot;, &quot;/templates/bill-charge&quot;+format+&quot;.doc&quot;);        &#125; catch (Exception e) &#123;            log.error(&quot;导出异常：&quot; + e.getMessage());            e.printStackTrace();        &#125;        return &quot;/templates/bill-charge&quot;+format+&quot;.doc&quot;;    &#125;\n3.其他3.1 工具类-传入名，生成图片，图片转base64码返回package com.xwj.property.fee.util;import sun.misc.BASE64Encoder;import java.awt.Color;import java.awt.Font;import java.awt.Graphics2D;import java.awt.RenderingHints;import java.awt.font.FontRenderContext;import java.awt.geom.AffineTransform;import java.awt.geom.Ellipse2D;import java.awt.geom.Rectangle2D;import java.awt.image.BufferedImage;import java.io.*;import java.util.Date;import java.util.Objects;import javax.imageio.ImageIO;public class UtilsGraphics2D &#123;    private static final int WIDTH = 200;//图片宽度    private static final int HEIGHT = 200;//图片高度//    private static String message = &quot; 青岛有个很牛的有限公司&quot;;    private static String centerName = &quot;&quot;;    private static String year = &quot;&quot;;    /**     * 传入公司名，调用生成图片方法，图片转base64码返回     * @param message     * @return     */    public static String ImageToBase64(String message) &#123;        byte[] data = null;        try &#123;            BufferedImage image = startGraphics2D(&quot; &quot;+message);            String imgPath = &quot;/templates/&quot; + new Date().getTime() + &quot;.png&quot;;            ImageIO.write(image, &quot;png&quot;, new File(imgPath));            // 读取图片字节数组            InputStream in = new FileInputStream(imgPath);            data = new byte[in.available()];            in.read(data);            in.close();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        // 对字节数组Base64编码        BASE64Encoder encoder = new BASE64Encoder();        // 返回Base64编码过的字节数组字符串        return  encoder.encode(Objects.requireNonNull(data));    &#125;    public static void main(String[] args) throws Exception &#123;    &#125;    /**     * 传入公司名称，生成印章图片     * @param message     * @return     */    public static BufferedImage startGraphics2D(String message) &#123;        // 定义图像buffer                 BufferedImage buffImg = new BufferedImage(WIDTH, HEIGHT, 2);        Graphics2D g = buffImg.createGraphics();        g.setColor(Color.RED);        //设置锯齿圆滑        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);        //绘制圆        int radius = HEIGHT / 3;//周半径        int CENTERX = WIDTH / 2;//画图所出位置        int CENTERY = HEIGHT / 2;//画图所处位置        Ellipse2D circle = new Ellipse2D.Double();        circle.setFrameFromCenter(CENTERX, CENTERY, CENTERX + radius, CENTERY + radius);        g.draw(circle);        //绘制中间的五角星        g.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 50));        g.drawString(&quot;★&quot;, CENTERX - (50 / 2), CENTERY + (50 / 3));        //添加姓名        g.setFont(new Font(&quot;宋体&quot;, Font.LAYOUT_LEFT_TO_RIGHT, 30));// 写入签名        g.drawString(centerName, CENTERX - (40), CENTERY + (30 + 50));        //添加年份        g.setFont(new Font(&quot;宋体&quot;, Font.LAYOUT_LEFT_TO_RIGHT, 20));// 写入签名        g.drawString(year, CENTERX - (60), CENTERY + (30 + 80));        //根据输入字符串得到字符数组        String[] messages2 = message.split(&quot;&quot;, 0);        String[] messages = new String[messages2.length - 1];        System.arraycopy(messages2, 1, messages, 0, messages2.length - 1);        //输入的字数        int ilength = messages.length;        //设置字体属性        int fontsize = 20;        Font f = new Font(&quot;Serif&quot;, Font.BOLD, fontsize);        FontRenderContext context = g.getFontRenderContext();        Rectangle2D bounds = f.getStringBounds(message, context);        //字符宽度＝字符串长度/字符数        double char_interval = (bounds.getWidth() / ilength);        //上坡度        double ascent = -bounds.getY();        int first = 0, second = 0;        boolean odd = false;        if (ilength % 2 == 1) &#123;            first = (ilength - 1) / 2;            odd = true;        &#125; else &#123;            first = (ilength) / 2 - 1;            second = (ilength) / 2;            odd = false;        &#125;        double radius2 = radius - ascent;        double x0 = CENTERX;        double y0 = CENTERY - radius + ascent;        //旋转角度        double a = 2 * Math.asin(char_interval / (2 * radius2));        if (odd) &#123;            g.setFont(f);            g.drawString(messages[first], (float) (x0 - char_interval / 2), (float) y0);            //中心点的右边            for (int i = first + 1; i &lt; ilength; i++) &#123;                double aa = (i - first) * a;                double ax = radius2 * Math.sin(aa);                double ay = radius2 - radius2 * Math.cos(aa);                AffineTransform transform = AffineTransform.getRotateInstance(aa);//,x0 + ax, y0 + ay);                Font f2 = f.deriveFont(transform);                g.setFont(f2);                g.drawString(messages[i], (float) (x0 + ax - char_interval / 2 * Math.cos(aa)), (float) (y0 + ay - char_interval / 2 * Math.sin(aa)));            &#125;            //中心点的左边            for (int i = first - 1; i &gt; -1; i--) &#123;                double aa = (first - i) * a;                double ax = radius2 * Math.sin(aa);                double ay = radius2 - radius2 * Math.cos(aa);                AffineTransform transform = AffineTransform.getRotateInstance(-aa);//,x0 + ax, y0 + ay);                Font f2 = f.deriveFont(transform);                g.setFont(f2);                g.drawString(messages[i], (float) (x0 - ax - char_interval / 2 * Math.cos(aa)), (float) (y0 + ay + char_interval / 2 * Math.sin(aa)));            &#125;        &#125; else &#123;            //中心点的右边            for (int i = second; i &lt; ilength; i++) &#123;                double aa = (i - second + 0.5) * a;                double ax = radius2 * Math.sin(aa);                double ay = radius2 - radius2 * Math.cos(aa);                AffineTransform transform = AffineTransform.getRotateInstance(aa);//,x0 + ax, y0 + ay);                Font f2 = f.deriveFont(transform);                g.setFont(f2);                g.drawString(messages[i], (float) (x0 + ax - char_interval / 2 * Math.cos(aa)), (float) (y0 + ay - char_interval / 2 * Math.sin(aa)));            &#125;            //中心点的左边            for (int i = first; i &gt; -1; i--) &#123;                double aa = (first - i + 0.5) * a;                double ax = radius2 * Math.sin(aa);                double ay = radius2 - radius2 * Math.cos(aa);                AffineTransform transform = AffineTransform.getRotateInstance(-aa);//,x0 + ax, y0 + ay);                Font f2 = f.deriveFont(transform);                g.setFont(f2);                g.drawString(messages[i], (float) (x0 - ax - char_interval / 2 * Math.cos(aa)), (float) (y0 + ay + char_interval / 2 * Math.sin(aa)));            &#125;        &#125;        return buffImg;    &#125;&#125;### 3.2 word导出工具类\npackage com.test.util;\nimport freemarker.core.ParseException;import freemarker.template.*;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import sun.misc.BASE64Encoder;\nimport java.io.*;import java.util.Map;\npublic class WordExport {\nprivate static final Logger log = LoggerFactory.getLogger(PropertyUtil.class);\n\nprivate Configuration config = null;\n\npublic WordExport() &#123;\n    config = new Configuration(Configuration.VERSION_2_3_28);\n    config.setDefaultEncoding(&quot;utf-8&quot;);\n&#125;\n/**\n * FreeMarker生成Word\n * @param dataMap 数据\n * @param templateName 目标名\n * @param saveFilePath 保存文件路径的全路径名（路径+文件名）\n * @Author boguotong.ex\n */\npublic void createWord(Map&lt;String, Object&gt; dataMap, String templateName, String saveFilePath) &#123;\n    //加载模板(路径)数据\n    config.setClassForTemplateLoading(this.getClass(), &quot;/templates&quot;);\n    //设置异常处理器 这样的话 即使没有属性也不会出错 如：$&#123;list.name&#125;...不会报错\n    config.setTemplateExceptionHandler(TemplateExceptionHandler.IGNORE_HANDLER);\n    Template template = null;\n    if(templateName.endsWith(&quot;.ftl&quot;)) &#123;\n        templateName = templateName.substring(0, templateName.indexOf(&quot;.ftl&quot;));\n    &#125;\n    try &#123;\n        template = config.getTemplate(templateName + &quot;.ftl&quot;);\n    &#125; catch (TemplateNotFoundException e) &#123;\n        log.error(&quot;模板文件未找到&quot;, e);\n        e.printStackTrace();\n    &#125; catch (MalformedTemplateNameException e) &#123;\n        log.error(&quot;模板类型不正确&quot;, e);\n        e.printStackTrace();\n    &#125; catch (ParseException e) &#123;\n        log.error(&quot;解析模板出错，请检查模板格式&quot;, e);\n        e.printStackTrace();\n    &#125; catch (IOException e) &#123;\n        log.error(&quot;IO读取失败&quot;, e);\n        e.printStackTrace();\n    &#125;\n    File outFile = new File(saveFilePath);\n    if(!outFile.getParentFile().exists()) &#123;\n        outFile.getParentFile().mkdirs();\n    &#125;\n    Writer out = null;\n    FileOutputStream fos = null;\n    try &#123;\n        fos = new FileOutputStream(outFile);\n    &#125; catch (FileNotFoundException e) &#123;\n        log.error(&quot;输出文件时未找到文件&quot;, e);\n        e.printStackTrace();\n    &#125;\n    out = new BufferedWriter(new OutputStreamWriter(fos));\n    //将模板中的预先的代码替换为数据\n    try &#123;\n        template.process(dataMap, out);\n    &#125; catch (TemplateException e) &#123;\n        log.error(&quot;填充模板时异常&quot;, e);\n        e.printStackTrace();\n    &#125; catch (IOException e) &#123;\n        log.error(&quot;IO读取时异常&quot;, e);\n        e.printStackTrace();\n    &#125;\n    log.info(&quot;由模板文件：&quot; + templateName + &quot;.ftl&quot; + &quot; 生成文件 ：&quot; + saveFilePath + &quot; 成功！！&quot;);\n    try &#123;\n        out.close();//web项目不可关闭\n    &#125; catch (IOException e) &#123;\n        log.error(&quot;关闭Write对象出错&quot;, e);\n        e.printStackTrace();\n    &#125;\n&#125;\n/**\n * 获得图片的Base64编码\n * @param imgFile\n * @return\n * @Author boguotong.ex\n */\npublic String getImageStr(String imgFile) &#123;\n    InputStream in = null;\n    byte[] data = null;\n    try &#123;\n        in = new FileInputStream(imgFile);\n    &#125; catch (FileNotFoundException e) &#123;\n        log.error(&quot;加载图片未找到&quot;, e);\n        e.printStackTrace();\n    &#125;\n    try &#123;\n        data = new byte[in.available()];\n        //注：FileInputStream.available()方法可以从输入流中阻断由下一个方法调用这个输入流中读取的剩余字节数\n        in.read(data);\n        in.close();\n    &#125; catch (IOException e) &#123;\n        log.error(&quot;IO操作图片错误&quot;, e);\n        e.printStackTrace();\n    &#125;\n    BASE64Encoder encoder = new BASE64Encoder();\n    return encoder.encode(data);\n\n&#125;\n\n}\n3.3 word模板&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; standalone&#x3D;&quot;yes&quot;?&gt;&lt;?mso-application progid&#x3D;&quot;Word.Document&quot;?&gt;&lt;pkg:package xmlns:pkg&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;2006&#x2F;xmlPackage&quot;&gt;    &lt;pkg:part pkg:name&#x3D;&quot;&#x2F;_rels&#x2F;.rels&quot; pkg:contentType&#x3D;&quot;application&#x2F;vnd.openxmlformats-package.relationships+xml&quot;              pkg:padding&#x3D;&quot;512&quot;&gt;        &lt;pkg:xmlData&gt;            &lt;Relationships xmlns&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;package&#x2F;2006&#x2F;relationships&quot;&gt;                &lt;Relationship Id&#x3D;&quot;rId3&quot;                              Type&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;relationships&#x2F;extended-properties&quot;                              Target&#x3D;&quot;docProps&#x2F;app.xml&quot;&#x2F;&gt;                &lt;Relationship Id&#x3D;&quot;rId2&quot;                              Type&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;package&#x2F;2006&#x2F;relationships&#x2F;metadata&#x2F;core-properties&quot;                              Target&#x3D;&quot;docProps&#x2F;core.xml&quot;&#x2F;&gt;                &lt;Relationship Id&#x3D;&quot;rId1&quot;                              Type&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;relationships&#x2F;officeDocument&quot;                              Target&#x3D;&quot;word&#x2F;document.xml&quot;&#x2F;&gt;            &lt;&#x2F;Relationships&gt;        &lt;&#x2F;pkg:xmlData&gt;    &lt;&#x2F;pkg:part&gt;    &lt;pkg:part pkg:name&#x3D;&quot;&#x2F;word&#x2F;_rels&#x2F;document.xml.rels&quot;              pkg:contentType&#x3D;&quot;application&#x2F;vnd.openxmlformats-package.relationships+xml&quot; pkg:padding&#x3D;&quot;256&quot;&gt;        &lt;pkg:xmlData&gt;            &lt;Relationships xmlns&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;package&#x2F;2006&#x2F;relationships&quot;&gt;                &lt;Relationship Id&#x3D;&quot;rId8&quot;                              Type&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;relationships&#x2F;fontTable&quot;                              Target&#x3D;&quot;fontTable.xml&quot;&#x2F;&gt;                &lt;Relationship Id&#x3D;&quot;rId3&quot;                              Type&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;relationships&#x2F;webSettings&quot;                              Target&#x3D;&quot;webSettings.xml&quot;&#x2F;&gt;                &lt;Relationship Id&#x3D;&quot;rId7&quot; Type&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;relationships&#x2F;image&quot;                              Target&#x3D;&quot;media&#x2F;image2.png&quot;&#x2F;&gt;                &lt;Relationship Id&#x3D;&quot;rId2&quot;                              Type&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;relationships&#x2F;settings&quot;                              Target&#x3D;&quot;settings.xml&quot;&#x2F;&gt;                &lt;Relationship Id&#x3D;&quot;rId1&quot;                              Type&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;relationships&#x2F;styles&quot;                              Target&#x3D;&quot;styles.xml&quot;&#x2F;&gt;                &lt;Relationship Id&#x3D;&quot;rId6&quot; Type&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;relationships&#x2F;image&quot;                              Target&#x3D;&quot;media&#x2F;image1.png&quot;&#x2F;&gt;                &lt;Relationship Id&#x3D;&quot;rId5&quot;                              Type&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;relationships&#x2F;endnotes&quot;                              Target&#x3D;&quot;endnotes.xml&quot;&#x2F;&gt;                &lt;Relationship Id&#x3D;&quot;rId4&quot;                              Type&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;relationships&#x2F;footnotes&quot;                              Target&#x3D;&quot;footnotes.xml&quot;&#x2F;&gt;                &lt;Relationship Id&#x3D;&quot;rId9&quot; Type&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;relationships&#x2F;theme&quot;                              Target&#x3D;&quot;theme&#x2F;theme1.xml&quot;&#x2F;&gt;            &lt;&#x2F;Relationships&gt;        &lt;&#x2F;pkg:xmlData&gt;    &lt;&#x2F;pkg:part&gt;    &lt;pkg:part pkg:name&#x3D;&quot;&#x2F;word&#x2F;document.xml&quot;              pkg:contentType&#x3D;&quot;application&#x2F;vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml&quot;&gt;        &lt;pkg:xmlData&gt;            &lt;w:document mc:Ignorable&#x3D;&quot;w14 w15 wp14&quot;                        xmlns:wpc&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordprocessingCanvas&quot;                        xmlns:mc&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;markup-compatibility&#x2F;2006&quot;                        xmlns:o&#x3D;&quot;urn:schemas-microsoft-com:office:office&quot;                        xmlns:r&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;relationships&quot;                        xmlns:m&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;math&quot;                        xmlns:v&#x3D;&quot;urn:schemas-microsoft-com:vml&quot;                        xmlns:wp14&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordprocessingDrawing&quot;                        xmlns:wp&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;drawingml&#x2F;2006&#x2F;wordprocessingDrawing&quot;                        xmlns:w10&#x3D;&quot;urn:schemas-microsoft-com:office:word&quot;                        xmlns:w&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;wordprocessingml&#x2F;2006&#x2F;main&quot;                        xmlns:w14&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordml&quot;                        xmlns:w15&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2012&#x2F;wordml&quot;                        xmlns:wpg&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordprocessingGroup&quot;                        xmlns:wpi&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordprocessingInk&quot;                        xmlns:wne&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2006&#x2F;wordml&quot;                        xmlns:wps&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordprocessingShape&quot;&gt;                &lt;w:body&gt;\t\t\t\t# 遍历集合，指定别名                    &lt;#list feeList as fee&gt;                    &lt;w:p w:rsidR&#x3D;&quot;00956EAA&quot; w:rsidRDefault&#x3D;&quot;00956EAA&quot;&#x2F;&gt;                    &lt;w:tbl&gt;                        &lt;w:tblPr&gt;                            &lt;w:tblStyle w:val&#x3D;&quot;a5&quot;&#x2F;&gt;                            &lt;w:tblW w:w&#x3D;&quot;10322&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                            &lt;w:jc w:val&#x3D;&quot;center&quot;&#x2F;&gt;                            &lt;w:tblLook w:val&#x3D;&quot;04A0&quot; w:firstRow&#x3D;&quot;1&quot; w:lastRow&#x3D;&quot;0&quot; w:firstColumn&#x3D;&quot;1&quot; w:lastColumn&#x3D;&quot;0&quot;                                       w:noHBand&#x3D;&quot;0&quot; w:noVBand&#x3D;&quot;1&quot;&#x2F;&gt;                        &lt;&#x2F;w:tblPr&gt;                        &lt;w:tblGrid&gt;                            &lt;w:gridCol w:w&#x3D;&quot;10322&quot;&#x2F;&gt;                        &lt;&#x2F;w:tblGrid&gt;                        &lt;w:tr w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidTr&#x3D;&quot;00A470B5&quot;&gt;                            &lt;w:trPr&gt;                                &lt;w:trHeight w:val&#x3D;&quot;4978&quot;&#x2F;&gt;                                &lt;w:jc w:val&#x3D;&quot;center&quot;&#x2F;&gt;                            &lt;&#x2F;w:trPr&gt;                            &lt;w:tc&gt;                                &lt;w:tcPr&gt;                                    &lt;w:tcW w:w&#x3D;&quot;10322&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                                &lt;&#x2F;w:tcPr&gt;                                &lt;w:p w:rsidR&#x3D;&quot;00ED0EF3&quot; w:rsidRDefault&#x3D;&quot;00ED0EF3&quot; w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                    &lt;w:pPr&gt;                                        &lt;w:jc w:val&#x3D;&quot;center&quot;&#x2F;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot; w:cs&#x3D;&quot;微软雅黑&quot;&#x2F;&gt;                                            &lt;w:b&#x2F;&gt;                                            &lt;w:sz w:val&#x3D;&quot;24&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                    &lt;&#x2F;w:pPr&gt;                                &lt;&#x2F;w:p&gt;                                &lt;w:p w:rsidR&#x3D;&quot;00ED0EF3&quot; w:rsidRDefault&#x3D;&quot;00ED0EF3&quot; w:rsidP&#x3D;&quot;00ED0EF3&quot;&gt;                                    &lt;w:pPr&gt;                                        &lt;w:jc w:val&#x3D;&quot;center&quot;&#x2F;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot; w:cs&#x3D;&quot;微软雅黑&quot;&#x2F;&gt;                                            &lt;w:b&#x2F;&gt;                                            &lt;w:sz w:val&#x3D;&quot;24&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                    &lt;&#x2F;w:pPr&gt;                                    &lt;w:r w:rsidRPr&#x3D;&quot;00ED0EF3&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot; w:cs&#x3D;&quot;微软雅黑&quot;                                                      w:hint&#x3D;&quot;eastAsia&quot;&#x2F;&gt;                                            &lt;w:b&#x2F;&gt;                                            &lt;w:sz w:val&#x3D;&quot;24&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;\t\t\t\t\t\t\t\t\t\t# 遍历：取集合中字段                                        &lt;w:t&gt;$&#123;fee.roomFullName&#125; 收费单&lt;&#x2F;w:t&gt;                                    &lt;&#x2F;w:r&gt;                                &lt;&#x2F;w:p&gt;                                &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00ED0EF3&quot;                                     w:rsidP&#x3D;&quot;00ED0EF3&quot;&gt;                                    &lt;w:pPr&gt;                                        &lt;w:jc w:val&#x3D;&quot;right&quot;&#x2F;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                    &lt;&#x2F;w:pPr&gt;                                    &lt;w:r w:rsidRPr&#x3D;&quot;00ED0EF3&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot; w:cs&#x3D;&quot;微软雅黑&quot;                                                      w:hint&#x3D;&quot;eastAsia&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;\t\t\t\t\t\t\t\t\t\t# 遍历：取集合中字段                                        &lt;w:t&gt;日期：$&#123;fee.dateTime&#125;&lt;&#x2F;w:t&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:t xml:space&#x3D;&quot;preserve&quot;&gt;   &lt;&#x2F;w:t&gt;                                    &lt;&#x2F;w:r&gt;                                &lt;&#x2F;w:p&gt;                                &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00BD58CB&quot;                                     w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                    &lt;w:pPr&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                    &lt;&#x2F;w:pPr&gt;                                    &lt;w:r w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot; w:cs&#x3D;&quot;微软雅黑&quot;                                                      w:hint&#x3D;&quot;eastAsia&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;\t\t\t\t\t\t\t\t\t\t# 遍历：取集合中字段                                        &lt;w:t&gt;亲爱的业主：&lt;&#x2F;w:t&gt;                                    &lt;&#x2F;w:r&gt;                                &lt;&#x2F;w:p&gt;                                &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00BD58CB&quot;                                     w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                    &lt;w:pPr&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                    &lt;&#x2F;w:pPr&gt;                                &lt;&#x2F;w:p&gt;                                &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00BD58CB&quot;                                     w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                    &lt;w:pPr&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                    &lt;&#x2F;w:pPr&gt;                                    &lt;w:r w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:tab&#x2F;&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot; w:cs&#x3D;&quot;微软雅黑&quot;                                                      w:hint&#x3D;&quot;eastAsia&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:t&gt;您尚有如下费用需缴纳：&lt;&#x2F;w:t&gt;                                    &lt;&#x2F;w:r&gt;                                &lt;&#x2F;w:p&gt;                                &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00BD58CB&quot;                                     w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                    &lt;w:pPr&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                    &lt;&#x2F;w:pPr&gt;                                &lt;&#x2F;w:p&gt;                                &lt;w:tbl&gt;                                    &lt;w:tblPr&gt;                                        &lt;w:tblStyle w:val&#x3D;&quot;a5&quot;&#x2F;&gt;                                        &lt;w:tblW w:w&#x3D;&quot;0&quot; w:type&#x3D;&quot;auto&quot;&#x2F;&gt;                                        &lt;w:jc w:val&#x3D;&quot;center&quot;&#x2F;&gt;                                        &lt;w:tblLook w:val&#x3D;&quot;04A0&quot; w:firstRow&#x3D;&quot;1&quot; w:lastRow&#x3D;&quot;0&quot; w:firstColumn&#x3D;&quot;1&quot;                                                   w:lastColumn&#x3D;&quot;0&quot; w:noHBand&#x3D;&quot;0&quot; w:noVBand&#x3D;&quot;1&quot;&#x2F;&gt;                                    &lt;&#x2F;w:tblPr&gt;                                    &lt;w:tblGrid&gt;                                        &lt;w:gridCol w:w&#x3D;&quot;1867&quot;&#x2F;&gt;                                        &lt;w:gridCol w:w&#x3D;&quot;1867&quot;&#x2F;&gt;                                        &lt;w:gridCol w:w&#x3D;&quot;1867&quot;&#x2F;&gt;                                        &lt;w:gridCol w:w&#x3D;&quot;1869&quot;&#x2F;&gt;                                        &lt;w:gridCol w:w&#x3D;&quot;1868&quot;&#x2F;&gt;                                    &lt;&#x2F;w:tblGrid&gt;                                    &lt;w:tr w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidTr&#x3D;&quot;008D4E44&quot;&gt;                                        &lt;w:trPr&gt;                                            &lt;w:trHeight w:val&#x3D;&quot;319&quot;&#x2F;&gt;                                            &lt;w:jc w:val&#x3D;&quot;center&quot;&#x2F;&gt;                                        &lt;&#x2F;w:trPr&gt;                                        &lt;w:tc&gt;                                            &lt;w:tcPr&gt;                                                &lt;w:tcW w:w&#x3D;&quot;1867&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                                                &lt;w:tcBorders&gt;                                                    &lt;w:top w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:left w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:bottom w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:right w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                &lt;&#x2F;w:tcBorders&gt;                                            &lt;&#x2F;w:tcPr&gt;                                            &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00BD58CB&quot;                                                 w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                                &lt;w:pPr&gt;                                                    &lt;w:jc w:val&#x3D;&quot;center&quot;&#x2F;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                &lt;&#x2F;w:pPr&gt;                                                &lt;w:r w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot; w:cs&#x3D;&quot;微软雅黑&quot;                                                                  w:hint&#x3D;&quot;eastAsia&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                    &lt;w:t&gt;费用名称&lt;&#x2F;w:t&gt;                                                &lt;&#x2F;w:r&gt;                                            &lt;&#x2F;w:p&gt;                                        &lt;&#x2F;w:tc&gt;                                        &lt;w:tc&gt;                                            &lt;w:tcPr&gt;                                                &lt;w:tcW w:w&#x3D;&quot;1867&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                                                &lt;w:tcBorders&gt;                                                    &lt;w:top w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:left w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:bottom w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:right w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                &lt;&#x2F;w:tcBorders&gt;                                            &lt;&#x2F;w:tcPr&gt;                                            &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00BD58CB&quot;                                                 w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                                &lt;w:pPr&gt;                                                    &lt;w:jc w:val&#x3D;&quot;center&quot;&#x2F;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                &lt;&#x2F;w:pPr&gt;                                                &lt;w:r w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot; w:cs&#x3D;&quot;微软雅黑&quot;                                                                  w:hint&#x3D;&quot;eastAsia&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                    &lt;w:t&gt;账单月份&lt;&#x2F;w:t&gt;                                                &lt;&#x2F;w:r&gt;                                            &lt;&#x2F;w:p&gt;                                        &lt;&#x2F;w:tc&gt;                                        &lt;w:tc&gt;                                            &lt;w:tcPr&gt;                                                &lt;w:tcW w:w&#x3D;&quot;1867&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                                                &lt;w:tcBorders&gt;                                                    &lt;w:top w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:left w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:bottom w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:right w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                &lt;&#x2F;w:tcBorders&gt;                                            &lt;&#x2F;w:tcPr&gt;                                            &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00BD58CB&quot;                                                 w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                                &lt;w:pPr&gt;                                                    &lt;w:jc w:val&#x3D;&quot;center&quot;&#x2F;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                &lt;&#x2F;w:pPr&gt;                                                &lt;w:r w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot; w:cs&#x3D;&quot;微软雅黑&quot;                                                                  w:hint&#x3D;&quot;eastAsia&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                    &lt;w:t&gt;单价&lt;&#x2F;w:t&gt;                                                &lt;&#x2F;w:r&gt;                                            &lt;&#x2F;w:p&gt;                                        &lt;&#x2F;w:tc&gt;                                        &lt;w:tc&gt;                                            &lt;w:tcPr&gt;                                                &lt;w:tcW w:w&#x3D;&quot;1869&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                                                &lt;w:tcBorders&gt;                                                    &lt;w:top w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:left w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:bottom w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:right w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                &lt;&#x2F;w:tcBorders&gt;                                            &lt;&#x2F;w:tcPr&gt;                                            &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00BD58CB&quot;                                                 w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                                &lt;w:pPr&gt;                                                    &lt;w:jc w:val&#x3D;&quot;center&quot;&#x2F;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                &lt;&#x2F;w:pPr&gt;                                                &lt;w:r w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot; w:cs&#x3D;&quot;微软雅黑&quot;                                                                  w:hint&#x3D;&quot;eastAsia&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                    &lt;w:t&gt;应缴金额&lt;&#x2F;w:t&gt;                                                &lt;&#x2F;w:r&gt;                                            &lt;&#x2F;w:p&gt;                                        &lt;&#x2F;w:tc&gt;                                        &lt;w:tc&gt;                                            &lt;w:tcPr&gt;                                                &lt;w:tcW w:w&#x3D;&quot;1868&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                                                &lt;w:tcBorders&gt;                                                    &lt;w:top w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:left w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:bottom w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:right w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                &lt;&#x2F;w:tcBorders&gt;                                            &lt;&#x2F;w:tcPr&gt;                                            &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00BD58CB&quot;                                                 w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                                &lt;w:pPr&gt;                                                    &lt;w:jc w:val&#x3D;&quot;center&quot;&#x2F;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                &lt;&#x2F;w:pPr&gt;                                                &lt;w:r w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot; w:cs&#x3D;&quot;微软雅黑&quot;                                                                  w:hint&#x3D;&quot;eastAsia&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                    &lt;w:t&gt;未缴金额&lt;&#x2F;w:t&gt;                                                &lt;&#x2F;w:r&gt;                                            &lt;&#x2F;w:p&gt;                                        &lt;&#x2F;w:tc&gt;                                    &lt;&#x2F;w:tr&gt;                                    &lt;#list fee.billList as bill&gt;                                    &lt;w:tr w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidTr&#x3D;&quot;008D4E44&quot;&gt;                                        &lt;w:trPr&gt;                                            &lt;w:trHeight w:val&#x3D;&quot;335&quot;&#x2F;&gt;                                            &lt;w:jc w:val&#x3D;&quot;center&quot;&#x2F;&gt;                                        &lt;&#x2F;w:trPr&gt;                                        &lt;w:tc&gt;                                            &lt;w:tcPr&gt;                                                &lt;w:tcW w:w&#x3D;&quot;1867&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                                                &lt;w:tcBorders&gt;                                                    &lt;w:top w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:left w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:bottom w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:right w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                &lt;&#x2F;w:tcBorders&gt;                                            &lt;&#x2F;w:tcPr&gt;                                            &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00BD58CB&quot;                                                 w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                                &lt;w:pPr&gt;                                                    &lt;w:jc w:val&#x3D;&quot;center&quot;&#x2F;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                &lt;&#x2F;w:pPr&gt;                                                &lt;w:r w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot; w:cs&#x3D;&quot;微软雅黑&quot;                                                                  w:hint&#x3D;&quot;eastAsia&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                    &lt;w:t&gt;$&#123;bill.chargeItemName&#125;&lt;&#x2F;w:t&gt;                                                &lt;&#x2F;w:r&gt;                                            &lt;&#x2F;w:p&gt;                                        &lt;&#x2F;w:tc&gt;                                        &lt;w:tc&gt;                                            &lt;w:tcPr&gt;                                                &lt;w:tcW w:w&#x3D;&quot;1867&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                                                &lt;w:tcBorders&gt;                                                    &lt;w:top w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:left w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:bottom w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:right w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                &lt;&#x2F;w:tcBorders&gt;                                            &lt;&#x2F;w:tcPr&gt;                                            &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00BD58CB&quot;                                                 w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                                &lt;w:pPr&gt;                                                    &lt;w:jc w:val&#x3D;&quot;center&quot;&#x2F;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                &lt;&#x2F;w:pPr&gt;                                                &lt;w:r w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                    &lt;w:t&gt;$&#123;bill.payMonth&#125;&lt;&#x2F;w:t&gt;                                                &lt;&#x2F;w:r&gt;                                            &lt;&#x2F;w:p&gt;                                        &lt;&#x2F;w:tc&gt;                                        &lt;w:tc&gt;                                            &lt;w:tcPr&gt;                                                &lt;w:tcW w:w&#x3D;&quot;1867&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                                                &lt;w:tcBorders&gt;                                                    &lt;w:top w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:left w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:bottom w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:right w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                &lt;&#x2F;w:tcBorders&gt;                                            &lt;&#x2F;w:tcPr&gt;                                            &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00BD58CB&quot;                                                 w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                                &lt;w:pPr&gt;                                                    &lt;w:jc w:val&#x3D;&quot;center&quot;&#x2F;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                &lt;&#x2F;w:pPr&gt;                                                &lt;w:r w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                    &lt;w:t&gt;$&#123;bill.price&#125;&lt;&#x2F;w:t&gt;                                                &lt;&#x2F;w:r&gt;                                            &lt;&#x2F;w:p&gt;                                        &lt;&#x2F;w:tc&gt;                                        &lt;w:tc&gt;                                            &lt;w:tcPr&gt;                                                &lt;w:tcW w:w&#x3D;&quot;1869&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                                                &lt;w:tcBorders&gt;                                                    &lt;w:top w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:left w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:bottom w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:right w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                &lt;&#x2F;w:tcBorders&gt;                                            &lt;&#x2F;w:tcPr&gt;                                            &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00BD58CB&quot;                                                 w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                                &lt;w:pPr&gt;                                                    &lt;w:jc w:val&#x3D;&quot;center&quot;&#x2F;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                &lt;&#x2F;w:pPr&gt;                                                &lt;w:r w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                    &lt;w:t&gt;$&#123;bill.chargeMoney&#125;&lt;&#x2F;w:t&gt;                                                &lt;&#x2F;w:r&gt;                                            &lt;&#x2F;w:p&gt;                                        &lt;&#x2F;w:tc&gt;                                        &lt;w:tc&gt;                                            &lt;w:tcPr&gt;                                                &lt;w:tcW w:w&#x3D;&quot;1868&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                                                &lt;w:tcBorders&gt;                                                    &lt;w:top w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:left w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:bottom w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:right w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                &lt;&#x2F;w:tcBorders&gt;                                            &lt;&#x2F;w:tcPr&gt;                                            &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00BD58CB&quot;                                                 w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                                &lt;w:pPr&gt;                                                    &lt;w:jc w:val&#x3D;&quot;center&quot;&#x2F;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                &lt;&#x2F;w:pPr&gt;                                                &lt;w:r w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                    &lt;w:t&gt;$&#123;bill.unpayMoney&#125;&lt;&#x2F;w:t&gt;                                                &lt;&#x2F;w:r&gt;                                            &lt;&#x2F;w:p&gt;                                        &lt;&#x2F;w:tc&gt;                                    &lt;&#x2F;w:tr&gt;                                &lt;&#x2F;#list&gt;                                    &lt;w:tr w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidTr&#x3D;&quot;00A470B5&quot;&gt;                                        &lt;w:trPr&gt;                                            &lt;w:trHeight w:val&#x3D;&quot;335&quot;&#x2F;&gt;                                            &lt;w:jc w:val&#x3D;&quot;center&quot;&#x2F;&gt;                                        &lt;&#x2F;w:trPr&gt;                                        &lt;w:tc&gt;                                            &lt;w:tcPr&gt;                                                &lt;w:tcW w:w&#x3D;&quot;7470&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                                                &lt;w:gridSpan w:val&#x3D;&quot;4&quot;&#x2F;&gt;                                                &lt;w:tcBorders&gt;                                                    &lt;w:top w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:left w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:bottom w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:right w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                &lt;&#x2F;w:tcBorders&gt;                                            &lt;&#x2F;w:tcPr&gt;                                            &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00BD58CB&quot;                                                 w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                                &lt;w:pPr&gt;                                                    &lt;w:tabs&gt;                                                        &lt;w:tab w:val&#x3D;&quot;left&quot; w:pos&#x3D;&quot;4575&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:tabs&gt;                                                    &lt;w:jc w:val&#x3D;&quot;left&quot;&#x2F;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                &lt;&#x2F;w:pPr&gt;                                                &lt;w:r w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot; w:cs&#x3D;&quot;微软雅黑&quot;                                                                  w:hint&#x3D;&quot;eastAsia&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                    &lt;w:t&gt;合计大写：（人民币）$&#123;fee.totalMoneyChinese&#125;&lt;&#x2F;w:t&gt;                                                &lt;&#x2F;w:r&gt;                                            &lt;&#x2F;w:p&gt;                                        &lt;&#x2F;w:tc&gt;                                        &lt;w:tc&gt;                                            &lt;w:tcPr&gt;                                                &lt;w:tcW w:w&#x3D;&quot;1868&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                                                &lt;w:tcBorders&gt;                                                    &lt;w:top w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:left w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:bottom w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                    &lt;w:right w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                                                &lt;&#x2F;w:tcBorders&gt;                                            &lt;&#x2F;w:tcPr&gt;                                            &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00BD58CB&quot;                                                 w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                                &lt;w:pPr&gt;                                                    &lt;w:jc w:val&#x3D;&quot;left&quot;&#x2F;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                &lt;&#x2F;w:pPr&gt;                                                &lt;w:r w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                                    &lt;w:rPr&gt;                                                        &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot; w:cs&#x3D;&quot;微软雅黑&quot;                                                                  w:hint&#x3D;&quot;eastAsia&quot;&#x2F;&gt;                                                    &lt;&#x2F;w:rPr&gt;                                                    &lt;w:t&gt;合计：$&#123;fee.totalMoney&#125;&lt;&#x2F;w:t&gt;                                                &lt;&#x2F;w:r&gt;                                            &lt;&#x2F;w:p&gt;                                        &lt;&#x2F;w:tc&gt;                                    &lt;&#x2F;w:tr&gt;                                &lt;&#x2F;w:tbl&gt;                                &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00BD58CB&quot;                                     w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                    &lt;w:pPr&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                    &lt;&#x2F;w:pPr&gt;                                &lt;&#x2F;w:p&gt;                                &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00544882&quot;                                     w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                    &lt;w:pPr&gt;                                        &lt;w:ind w:firstLineChars&#x3D;&quot;100&quot; w:firstLine&#x3D;&quot;210&quot;&#x2F;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                    &lt;&#x2F;w:pPr&gt;                                    &lt;w:r&gt;                                        &lt;w:rPr&gt;                                            &lt;w:noProof&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:drawing&gt;                                            &lt;wp:anchor distT&#x3D;&quot;0&quot; distB&#x3D;&quot;0&quot; distL&#x3D;&quot;114300&quot; distR&#x3D;&quot;114300&quot; simplePos&#x3D;&quot;0&quot;                                                       relativeHeight&#x3D;&quot;251658240&quot; behindDoc&#x3D;&quot;0&quot; locked&#x3D;&quot;0&quot;                                                       layoutInCell&#x3D;&quot;1&quot; allowOverlap&#x3D;&quot;1&quot; wp14:anchorId&#x3D;&quot;1074CA75&quot;                                                       wp14:editId&#x3D;&quot;6B87AFCF&quot;&gt;                                                &lt;wp:simplePos x&#x3D;&quot;0&quot; y&#x3D;&quot;0&quot;&#x2F;&gt;                                                &lt;wp:positionH relativeFrom&#x3D;&quot;column&quot;&gt;                                                    &lt;wp:posOffset&gt;4848225&lt;&#x2F;wp:posOffset&gt;                                                &lt;&#x2F;wp:positionH&gt;                                                &lt;wp:positionV relativeFrom&#x3D;&quot;paragraph&quot;&gt;                                                    &lt;wp:posOffset&gt;195580&lt;&#x2F;wp:posOffset&gt;                                                &lt;&#x2F;wp:positionV&gt;                                                &lt;wp:extent cx&#x3D;&quot;995680&quot; cy&#x3D;&quot;1009015&quot;&#x2F;&gt;                                                &lt;wp:effectExtent l&#x3D;&quot;0&quot; t&#x3D;&quot;0&quot; r&#x3D;&quot;0&quot; b&#x3D;&quot;635&quot;&#x2F;&gt;                                                &lt;wp:wrapNone&#x2F;&gt;                                                &lt;wp:docPr id&#x3D;&quot;3&quot; name&#x3D;&quot;图片 3&quot;&#x2F;&gt;                                                &lt;wp:cNvGraphicFramePr&gt;                                                    &lt;a:graphicFrameLocks noChangeAspect&#x3D;&quot;1&quot;                                                                         xmlns:a&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;drawingml&#x2F;2006&#x2F;main&quot;&#x2F;&gt;                                                &lt;&#x2F;wp:cNvGraphicFramePr&gt;                                                &lt;a:graphic                                                        xmlns:a&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;drawingml&#x2F;2006&#x2F;main&quot;&gt;                                                    &lt;a:graphicData                                                            uri&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;drawingml&#x2F;2006&#x2F;picture&quot;&gt;                                                        &lt;pic:pic                                                                xmlns:pic&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;drawingml&#x2F;2006&#x2F;picture&quot;&gt;                                                            &lt;pic:nvPicPr&gt;                                                                &lt;pic:cNvPr id&#x3D;&quot;1&quot; name&#x3D;&quot;&quot;&#x2F;&gt;                                                                &lt;pic:cNvPicPr&#x2F;&gt;                                                            &lt;&#x2F;pic:nvPicPr&gt;                                                            &lt;pic:blipFill&gt;                                                                &lt;a:blip r:embed&#x3D;&quot;rId6&quot; cstate&#x3D;&quot;print&quot;&gt;                                                                    &lt;a:extLst&gt;                                                                        &lt;a:ext uri&#x3D;&quot;&#123;28A0092B-C50C-407E-A947-70E740481C1C&#125;&quot;&gt;                                                                            &lt;a14:useLocalDpi val&#x3D;&quot;0&quot;                                                                                             xmlns:a14&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;drawing&#x2F;2010&#x2F;main&quot;&#x2F;&gt;                                                                        &lt;&#x2F;a:ext&gt;                                                                    &lt;&#x2F;a:extLst&gt;                                                                &lt;&#x2F;a:blip&gt;                                                                &lt;a:stretch&gt;                                                                    &lt;a:fillRect&#x2F;&gt;                                                                &lt;&#x2F;a:stretch&gt;                                                            &lt;&#x2F;pic:blipFill&gt;                                                            &lt;pic:spPr&gt;                                                                &lt;a:xfrm&gt;                                                                    &lt;a:off x&#x3D;&quot;0&quot; y&#x3D;&quot;0&quot;&#x2F;&gt;                                                                    &lt;a:ext cx&#x3D;&quot;995680&quot; cy&#x3D;&quot;1009015&quot;&#x2F;&gt;                                                                &lt;&#x2F;a:xfrm&gt;                                                                &lt;a:prstGeom prst&#x3D;&quot;rect&quot;&gt;                                                                    &lt;a:avLst&#x2F;&gt;                                                                &lt;&#x2F;a:prstGeom&gt;                                                            &lt;&#x2F;pic:spPr&gt;                                                        &lt;&#x2F;pic:pic&gt;                                                    &lt;&#x2F;a:graphicData&gt;                                                &lt;&#x2F;a:graphic&gt;                                                &lt;wp14:sizeRelH relativeFrom&#x3D;&quot;margin&quot;&gt;                                                    &lt;wp14:pctWidth&gt;0&lt;&#x2F;wp14:pctWidth&gt;                                                &lt;&#x2F;wp14:sizeRelH&gt;                                                &lt;wp14:sizeRelV relativeFrom&#x3D;&quot;margin&quot;&gt;                                                    &lt;wp14:pctHeight&gt;0&lt;&#x2F;wp14:pctHeight&gt;                                                &lt;&#x2F;wp14:sizeRelV&gt;                                            &lt;&#x2F;wp:anchor&gt;                                        &lt;&#x2F;w:drawing&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                            &lt;w:noProof&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:drawing&gt;                                            &lt;wp:inline distT&#x3D;&quot;0&quot; distB&#x3D;&quot;0&quot; distL&#x3D;&quot;0&quot; distR&#x3D;&quot;0&quot; wp14:anchorId&#x3D;&quot;55A2C36B&quot;                                                       wp14:editId&#x3D;&quot;602FB73C&quot;&gt;                                                &lt;wp:extent cx&#x3D;&quot;790575&quot; cy&#x3D;&quot;771525&quot;&#x2F;&gt;                                                &lt;wp:effectExtent l&#x3D;&quot;0&quot; t&#x3D;&quot;0&quot; r&#x3D;&quot;9525&quot; b&#x3D;&quot;9525&quot;&#x2F;&gt;                                                &lt;wp:docPr id&#x3D;&quot;1&quot; name&#x3D;&quot;图片 1&quot;&#x2F;&gt;                                                &lt;wp:cNvGraphicFramePr&gt;                                                    &lt;a:graphicFrameLocks noChangeAspect&#x3D;&quot;1&quot;                                                                         xmlns:a&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;drawingml&#x2F;2006&#x2F;main&quot;&#x2F;&gt;                                                &lt;&#x2F;wp:cNvGraphicFramePr&gt;                                                &lt;a:graphic                                                        xmlns:a&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;drawingml&#x2F;2006&#x2F;main&quot;&gt;                                                    &lt;a:graphicData                                                            uri&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;drawingml&#x2F;2006&#x2F;picture&quot;&gt;                                                        &lt;pic:pic                                                                xmlns:pic&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;drawingml&#x2F;2006&#x2F;picture&quot;&gt;                                                            &lt;pic:nvPicPr&gt;                                                                &lt;pic:cNvPr id&#x3D;&quot;0&quot; name&#x3D;&quot;图片 1&quot;&#x2F;&gt;                                                                &lt;pic:cNvPicPr&gt;                                                                    &lt;a:picLocks noChangeAspect&#x3D;&quot;1&quot;                                                                                noChangeArrowheads&#x3D;&quot;1&quot;&#x2F;&gt;                                                                &lt;&#x2F;pic:cNvPicPr&gt;                                                            &lt;&#x2F;pic:nvPicPr&gt;                                                            &lt;pic:blipFill&gt;                                                                &lt;a:blip r:embed&#x3D;&quot;rId7&quot; cstate&#x3D;&quot;print&quot;&gt;                                                                    &lt;a:extLst&gt;                                                                        &lt;a:ext uri&#x3D;&quot;&#123;28A0092B-C50C-407E-A947-70E740481C1C&#125;&quot;&gt;                                                                            &lt;a14:useLocalDpi val&#x3D;&quot;0&quot;                                                                                             xmlns:a14&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;drawing&#x2F;2010&#x2F;main&quot;&#x2F;&gt;                                                                        &lt;&#x2F;a:ext&gt;                                                                    &lt;&#x2F;a:extLst&gt;                                                                &lt;&#x2F;a:blip&gt;                                                                &lt;a:srcRect&#x2F;&gt;                                                                &lt;a:stretch&gt;                                                                    &lt;a:fillRect&#x2F;&gt;                                                                &lt;&#x2F;a:stretch&gt;                                                            &lt;&#x2F;pic:blipFill&gt;                                                            &lt;pic:spPr bwMode&#x3D;&quot;auto&quot;&gt;                                                                &lt;a:xfrm&gt;                                                                    &lt;a:off x&#x3D;&quot;0&quot; y&#x3D;&quot;0&quot;&#x2F;&gt;                                                                    &lt;a:ext cx&#x3D;&quot;790575&quot; cy&#x3D;&quot;771525&quot;&#x2F;&gt;                                                                &lt;&#x2F;a:xfrm&gt;                                                                &lt;a:prstGeom prst&#x3D;&quot;rect&quot;&gt;                                                                    &lt;a:avLst&#x2F;&gt;                                                                &lt;&#x2F;a:prstGeom&gt;                                                                &lt;a:noFill&#x2F;&gt;                                                                &lt;a:ln&gt;                                                                    &lt;a:noFill&#x2F;&gt;                                                                &lt;&#x2F;a:ln&gt;                                                            &lt;&#x2F;pic:spPr&gt;                                                        &lt;&#x2F;pic:pic&gt;                                                    &lt;&#x2F;a:graphicData&gt;                                                &lt;&#x2F;a:graphic&gt;                                            &lt;&#x2F;wp:inline&gt;                                        &lt;&#x2F;w:drawing&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:tab&#x2F;&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:tab&#x2F;&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:tab&#x2F;&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:tab&#x2F;&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:tab&#x2F;&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:tab&#x2F;&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:tab&#x2F;&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:tab&#x2F;&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:tab&#x2F;&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:tab&#x2F;&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:tab&#x2F;&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r w:rsidR&#x3D;&quot;00216D28&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:t xml:space&#x3D;&quot;preserve&quot;&gt;       &lt;&#x2F;w:t&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:bookmarkStart w:id&#x3D;&quot;0&quot; w:name&#x3D;&quot;_GoBack&quot;&#x2F;&gt;                                    &lt;w:bookmarkEnd w:id&#x3D;&quot;0&quot;&#x2F;&gt;                                    &lt;w:r w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot; w:cs&#x3D;&quot;微软雅黑&quot;                                                      w:hint&#x3D;&quot;eastAsia&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:t&gt;单位名称：&lt;&#x2F;w:t&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:t xml:space&#x3D;&quot;preserve&quot;&gt; (&lt;&#x2F;w:t&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot; w:cs&#x3D;&quot;微软雅黑&quot;                                                      w:hint&#x3D;&quot;eastAsia&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:t&gt;盖章&lt;&#x2F;w:t&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:t&gt;)&lt;&#x2F;w:t&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r&gt;                                        &lt;w:rPr&gt;                                            &lt;w:noProof&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:t xml:space&#x3D;&quot;preserve&quot;&gt; &lt;&#x2F;w:t&gt;                                    &lt;&#x2F;w:r&gt;                                &lt;&#x2F;w:p&gt;                                &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00ED0EF3&quot;                                     w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                    &lt;w:pPr&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                    &lt;&#x2F;w:pPr&gt;                                    &lt;w:r w:rsidRPr&#x3D;&quot;00ED0EF3&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot; w:cs&#x3D;&quot;宋体&quot;                                                      w:hint&#x3D;&quot;eastAsia&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:t&gt;下载APP 缴费更方便&lt;&#x2F;w:t&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:tab&#x2F;&gt;                                    &lt;&#x2F;w:r&gt;                                    &lt;w:r w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot;&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                        &lt;w:tab&#x2F;&gt;                                    &lt;&#x2F;w:r&gt;                                &lt;&#x2F;w:p&gt;                                &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00BD58CB&quot;                                     w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                                    &lt;w:pPr&gt;                                        &lt;w:rPr&gt;                                            &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                                        &lt;&#x2F;w:rPr&gt;                                    &lt;&#x2F;w:pPr&gt;                                &lt;&#x2F;w:p&gt;                            &lt;&#x2F;w:tc&gt;                        &lt;&#x2F;w:tr&gt;                    &lt;&#x2F;w:tbl&gt;                    &lt;w:p w:rsidR&#x3D;&quot;00BD58CB&quot; w:rsidRPr&#x3D;&quot;00BD58CB&quot; w:rsidRDefault&#x3D;&quot;00BD58CB&quot; w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot; w:cs&#x3D;&quot;Times New Roman&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009541BD&quot; w:rsidRDefault&#x3D;&quot;00E03B56&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRDefault&#x3D;&quot;009300C4&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRDefault&#x3D;&quot;009300C4&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRDefault&#x3D;&quot;009300C4&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRDefault&#x3D;&quot;009300C4&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRDefault&#x3D;&quot;009300C4&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRDefault&#x3D;&quot;009300C4&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRDefault&#x3D;&quot;009300C4&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRDefault&#x3D;&quot;009300C4&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRDefault&#x3D;&quot;009300C4&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRDefault&#x3D;&quot;009300C4&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRDefault&#x3D;&quot;009300C4&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRDefault&#x3D;&quot;009300C4&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRDefault&#x3D;&quot;009300C4&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRDefault&#x3D;&quot;009300C4&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRDefault&#x3D;&quot;009300C4&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRDefault&#x3D;&quot;009300C4&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRDefault&#x3D;&quot;009300C4&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRDefault&#x3D;&quot;009300C4&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRDefault&#x3D;&quot;009300C4&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:p w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRPr&#x3D;&quot;00956EAA&quot; w:rsidRDefault&#x3D;&quot;009300C4&quot;&gt;                        &lt;w:pPr&gt;                            &lt;w:rPr&gt;                                &lt;w:rFonts w:ascii&#x3D;&quot;黑体&quot; w:eastAsia&#x3D;&quot;黑体&quot; w:hAnsi&#x3D;&quot;黑体&quot;&#x2F;&gt;                            &lt;&#x2F;w:rPr&gt;                        &lt;&#x2F;w:pPr&gt;                    &lt;&#x2F;w:p&gt;                    &lt;w:sectPr w:rsidR&#x3D;&quot;009300C4&quot; w:rsidRPr&#x3D;&quot;00956EAA&quot; w:rsidSect&#x3D;&quot;00655E80&quot;&gt;                        &lt;w:pgSz w:w&#x3D;&quot;11906&quot; w:h&#x3D;&quot;16838&quot;&#x2F;&gt;                        &lt;w:pgMar w:top&#x3D;&quot;1440&quot; w:right&#x3D;&quot;1800&quot; w:bottom&#x3D;&quot;1440&quot; w:left&#x3D;&quot;1800&quot; w:header&#x3D;&quot;851&quot; w:footer&#x3D;&quot;992&quot;                                 w:gutter&#x3D;&quot;0&quot;&#x2F;&gt;                        &lt;w:cols w:space&#x3D;&quot;425&quot;&#x2F;&gt;                        &lt;w:docGrid w:type&#x3D;&quot;lines&quot; w:linePitch&#x3D;&quot;312&quot;&#x2F;&gt;                    &lt;&#x2F;w:sectPr&gt;\t\t\t\t\t# fee_index中fee是上面集合遍历时指定的别名\t\t\t\t\t**&lt;#if fee_index?if_exists+1%2 &#x3D;&#x3D;0&gt;&lt;&#x2F;span&gt;**\t\t\t\t\t**&lt;w:br w:type&#x3D;&quot;page&quot;&#x2F;&gt;&lt;&#x2F;span&gt;&lt;!--此标签用于强制分页--&gt;**        &lt;&#x2F;#if&gt;        &lt;&#x2F;#list&gt;                &lt;&#x2F;w:body&gt;            &lt;&#x2F;w:document&gt;        &lt;&#x2F;pkg:xmlData&gt;    &lt;&#x2F;pkg:part&gt;    &lt;pkg:part pkg:name&#x3D;&quot;&#x2F;word&#x2F;footnotes.xml&quot;              pkg:contentType&#x3D;&quot;application&#x2F;vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml&quot;&gt;        &lt;pkg:xmlData&gt;            &lt;w:footnotes mc:Ignorable&#x3D;&quot;w14 w15 wp14&quot;                         xmlns:wpc&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordprocessingCanvas&quot;                         xmlns:mc&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;markup-compatibility&#x2F;2006&quot;                         xmlns:o&#x3D;&quot;urn:schemas-microsoft-com:office:office&quot;                         xmlns:r&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;relationships&quot;                         xmlns:m&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;math&quot;                         xmlns:v&#x3D;&quot;urn:schemas-microsoft-com:vml&quot;                         xmlns:wp14&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordprocessingDrawing&quot;                         xmlns:wp&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;drawingml&#x2F;2006&#x2F;wordprocessingDrawing&quot;                         xmlns:w10&#x3D;&quot;urn:schemas-microsoft-com:office:word&quot;                         xmlns:w&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;wordprocessingml&#x2F;2006&#x2F;main&quot;                         xmlns:w14&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordml&quot;                         xmlns:w15&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2012&#x2F;wordml&quot;                         xmlns:wpg&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordprocessingGroup&quot;                         xmlns:wpi&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordprocessingInk&quot;                         xmlns:wne&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2006&#x2F;wordml&quot;                         xmlns:wps&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordprocessingShape&quot;&gt;                &lt;w:footnote w:type&#x3D;&quot;separator&quot; w:id&#x3D;&quot;-1&quot;&gt;                    &lt;w:p w:rsidR&#x3D;&quot;00E03B56&quot; w:rsidRDefault&#x3D;&quot;00E03B56&quot; w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                        &lt;w:r&gt;                            &lt;w:separator&#x2F;&gt;                        &lt;&#x2F;w:r&gt;                    &lt;&#x2F;w:p&gt;                &lt;&#x2F;w:footnote&gt;                &lt;w:footnote w:type&#x3D;&quot;continuationSeparator&quot; w:id&#x3D;&quot;0&quot;&gt;                    &lt;w:p w:rsidR&#x3D;&quot;00E03B56&quot; w:rsidRDefault&#x3D;&quot;00E03B56&quot; w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                        &lt;w:r&gt;                            &lt;w:continuationSeparator&#x2F;&gt;                        &lt;&#x2F;w:r&gt;                    &lt;&#x2F;w:p&gt;                &lt;&#x2F;w:footnote&gt;            &lt;&#x2F;w:footnotes&gt;        &lt;&#x2F;pkg:xmlData&gt;    &lt;&#x2F;pkg:part&gt;    &lt;pkg:part pkg:name&#x3D;&quot;&#x2F;word&#x2F;endnotes.xml&quot;              pkg:contentType&#x3D;&quot;application&#x2F;vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml&quot;&gt;        &lt;pkg:xmlData&gt;            &lt;w:endnotes mc:Ignorable&#x3D;&quot;w14 w15 wp14&quot;                        xmlns:wpc&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordprocessingCanvas&quot;                        xmlns:mc&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;markup-compatibility&#x2F;2006&quot;                        xmlns:o&#x3D;&quot;urn:schemas-microsoft-com:office:office&quot;                        xmlns:r&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;relationships&quot;                        xmlns:m&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;math&quot;                        xmlns:v&#x3D;&quot;urn:schemas-microsoft-com:vml&quot;                        xmlns:wp14&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordprocessingDrawing&quot;                        xmlns:wp&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;drawingml&#x2F;2006&#x2F;wordprocessingDrawing&quot;                        xmlns:w10&#x3D;&quot;urn:schemas-microsoft-com:office:word&quot;                        xmlns:w&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;wordprocessingml&#x2F;2006&#x2F;main&quot;                        xmlns:w14&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordml&quot;                        xmlns:w15&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2012&#x2F;wordml&quot;                        xmlns:wpg&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordprocessingGroup&quot;                        xmlns:wpi&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordprocessingInk&quot;                        xmlns:wne&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2006&#x2F;wordml&quot;                        xmlns:wps&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordprocessingShape&quot;&gt;                &lt;w:endnote w:type&#x3D;&quot;separator&quot; w:id&#x3D;&quot;-1&quot;&gt;                    &lt;w:p w:rsidR&#x3D;&quot;00E03B56&quot; w:rsidRDefault&#x3D;&quot;00E03B56&quot; w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                        &lt;w:r&gt;                            &lt;w:separator&#x2F;&gt;                        &lt;&#x2F;w:r&gt;                    &lt;&#x2F;w:p&gt;                &lt;&#x2F;w:endnote&gt;                &lt;w:endnote w:type&#x3D;&quot;continuationSeparator&quot; w:id&#x3D;&quot;0&quot;&gt;                    &lt;w:p w:rsidR&#x3D;&quot;00E03B56&quot; w:rsidRDefault&#x3D;&quot;00E03B56&quot; w:rsidP&#x3D;&quot;00BD58CB&quot;&gt;                        &lt;w:r&gt;                            &lt;w:continuationSeparator&#x2F;&gt;                        &lt;&#x2F;w:r&gt;                    &lt;&#x2F;w:p&gt;                &lt;&#x2F;w:endnote&gt;            &lt;&#x2F;w:endnotes&gt;        &lt;&#x2F;pkg:xmlData&gt;    &lt;&#x2F;pkg:part&gt;    &lt;pkg:part pkg:name&#x3D;&quot;&#x2F;word&#x2F;media&#x2F;image2.png&quot; pkg:contentType&#x3D;&quot;image&#x2F;png&quot; pkg:compression&#x3D;&quot;store&quot;&gt;        &lt;pkg:binaryData&gt;iVBORw0KGgoAAAANSUhEUgAAAL4AAAC6CAIAAAHogFBKAAAAAXNSR0IArs4c6QAAAARnQU1BAACx            jwv8YQUAAAAJcEhZcwAAIdUAACHVAQSctJ0AAHARSURBVHhe7d0HuFbFtT&#x2F;+3ORnqtEoiRoLlqhg            7CV6RaPR2LADdlGj2DGoYEVQRLBhwYax965YIgI2sKIRFAtibGBH1NhSNTfv&#x2F;7P32mfY5y2HcxBM            7v&#x2F;yfd5nP&#x2F;OuWbNmzZo1a9bs&#x2F;ZZvVLr0qmzf9CqXG73q8nfp9Y3K1gfPllch6L&#x2F;+67++UUKlUikX            XGGrrbZ69dVXEyWvz5DV1RX0z3&#x2F;+8&#x2F;&#x2F;9v&#x2F;8377zzzjPPPNHg1FNPVSBomWWW8VbtP&#x2F;7xj3&#x2F;961&#x2F;K            rg0FAdYQAVtuuSVBJ5100u9&#x2F;&#x2F;&#x2F;ugqGooSOcaB5S&#x2F;+93v&#x2F;uhHP&#x2F;re97631FJLde7c+cgjjwxBkydP            &#x2F;uSTT7744guCCu68yxmClD&#x2F;44APXdu3aKbz33nvt27dX+Oijj2hE0Pe&#x2F;&#x2F;&#x2F;0f&#x2F;vCHU6ZM+ctf&#x2F;rLQ            Qgu98847OGnkWi0IVKyyyiqrrrqq65dffumKQtChhx46ceJE5bvvvnuttdZaffXVgx8DZKUk6NJL            L73kkktQ9tlnHwXXvffem+F+8IMfPPPMM2ph9OjRlOrRo4daQ0MhWrmZIG28VdG&#x2F;f&#x2F;&#x2F;&#x2F;+Z&#x2F;&#x2F;UfCW            UgMGDNh5550Z+4EHHvjjH&#x2F;84dOjQQYMG4VHFzMcff3xwzhB0TY6rc6jbddddXa+44oo&#x2F;&#x2F;&#x2F;nPwVDZ            tmfv3r2jM1JopIB59913byZo0qRJ2ftKRYFGxVxA10Mr&#x2F;&#x2F;iicsYVlROHmbVNNtnkxRdfXHnllc3s            CjmKhkmQudCDKxBk4v&#x2F;6178Wgv44tXL+dcZ522238WxsyK6UxYyzmSDUBDPtypXmm2++yvnXZwx7            9XVFf&#x2F;311&#x2F;kEV9LWW9fPP&#x2F;+8mSBjMfIYP424nAKGJZZYYuutt+ZHqkwIe1MB83e+8x0M3&#x2F;rWt0LB            GYKUkSBcnqCsOkc4JM+Ot9EyccbbGYJQAZU6YFI+++wzb9944420xMCiNeriTS4CczNB2Zsm8eoo            n1ijEGuNsQ2NvmYt6KFXtaBARAJhRHnxxRdX5pCuUaugGypHuVqQxn&#x2F;PEQ3MCEHeGpr1RdDJJ58s            HqGY8m9&#x2F;+9smS1khkwJlQUQEBJDp06e&#x2F;+eab77&#x2F;&#x2F;&#x2F;vPPP6&#x2F;zmDXWsfqFPWWeQRecUC3I1AImNlJY            brnllGP6xIrDDjvMAqYFG3Xo0EFVQjNBlRdeadVr0qvZKwpl+gxBX&#x2F;n1jeodqqqcXoilXWwGPV4n            nD+bNDrunFxQk9dBlNnYddlll33kkUe22267zJw53ZVnxMQlNBNkpjJSDgWCYi8IQWeccYbyyy+&#x2F;            rKq8RAItCXL98MMPc7ZCx1&#x2F;96lc&#x2F;+9nPFAj65je&#x2F;mdcUaCaI1weUqcN9p02bRoUxY8bccssthx9+            +K9&#x2F;&#x2F;WuCLFquSFDBnaOZIMhkVyp82pUHMoSIY2i33357v3791CKSFZpi+&#x2F;GPf+xarRHPtnMlcXau            Rx99NDz4448&#x2F;FvZtZ8p&#x2F;+9vfnnzySX3giV0va1UWFIvYVmWfUu262267devWzeZjXOi21gMPPPCU            U065+OKLMUBq1UwQY9ut7GLKmLKRVyrennDCCTFrUWVcCoAHP0GZxCqNYpMKqLZEs5C0&#x2F;W8zBtvM            O9M+&#x2F;fRTNrJfMjYerYK5mSAtA&#x2F;YpVxQQNLLaQRdl+1rOFmEEdIzzhRdeyPa1siAQH0KEa4RH05&#x2F;V            3vVg5YFxCksvvbQdkR9RNusz3wddmwlSDbGjucYSyWZH7baHVPY81hjRDW3BBRekjnJCM0GMHbrE            bsXYCjTiBPzIxGUK5LV6Et4U8NeZtXKo9TZmDcIhCYq3NCIoLZEgVgsK8cFBkKvV36lTp6DAK6+8            4mosrjGC4G8mqCA1FcphRAFi0Sa26NU1e1slqIzgZqMII95KtFBiaFHrGmgmiKpMqAAKuBVMtqFJ            ImL&#x2F;khlZ&#x2F;TE0PK7FvlYlKJOdw1Zljueff37LkqBrr72WsWkkv5LQhCA8rvCnP&#x2F;2pmaCXXnop9jVl            1TrnfmKQbfK+++5D6dq1q4LaSG+DWaus5xmCYm+KPatqw6q7i1W9Zgj66q&#x2F;ZJmh2vZop9O9FXYWs            t7SEAubZFT3egsySj0VZEoZBrmpZy6CCCBIy9IRwbgs9TgtFxMhRLDFoQaFcSAaUuIZCEViSQrF9            QygU5SqIFqJuKBRADCUCM1dI8IjQHgjuUEjZCrVXGqtCKLTeeuthSwrJoAUbSTSiCGT96FIZP&#x2F;NE            9yJrJjqHMkpDhRLixJIKzCZtoKtI&#x2F;vbbbzvpRq3VLA4gOvyYMvFBgqAJOFDbZ4zEXsRCKDFlWgUD            pHImq5FCDCAGgYK3Ao0RhIV0HERbtukbP378YostNnLkSFMmnT&#x2F;qqKMkFwMHDsR244034jR6J+x3            3313kUUWkbEssMACIZmd1Gb2zAMZStZxI4XYOa5RELY0I8IEBZ5++mkiFO69915VTmxOvldddVU0            SaCWWmzc6Oc&#x2F;&#x2F;&#x2F;nkyZOVWdqVNJIVsJHvmnVcVyGW0Gb77bd3bL311lujgB4biPLw4cO95ddSJnMn            fZKrop9zzjkrrrjiSiut1KVLl2effZYnyaMOOOAAEkzTLrvscvPNN6sKjwmxMU69wEwU2iOHBlde            eaUCuisbXH755Ri6d+&#x2F;urTRu4YUXRrznnnt40plnnrnGGmvICm0wGvLr9957j&#x2F;b77bcfU8nt+G&#x2F;4            kCYhc88996SQLlAaKmTXgyi4Em1DdWVeV6LZHxzV6a1Q2eOYrOETz1Z2OLxy9tWV7kdXdjwcxSrL            +qhUpk6dan3JwvA7vJodV0jyAxlr6FCl0E9&#x2F;+lMTwQfDE7G6ohOnjGihRf4AtMxuTlw&#x2F;ovL5nysv            vFqZ&#x2F;qfsddplRPFfDf&#x2F;whz+YI8vNKtOWPZyjk9i4IkYXhQ5VCv0wB1awXKWuQdFMmYV4j8ISSywx            QyENBfdPPsuywr2Oc+ZAobcTs2kKA1NIfmBlaQvaxhXUFuXQoUqhgI7jitsVDBR0E3keA3hrgWy6            6aaVcROzfDm9bhnVs2fPO++806QEs6suTRw5sXWA5rpwDeFZry0oFNAsXQNp60Bk&#x2F;CCCIJTOlQF7            WeZhuS9m&#x2F;efZY+jH2OgKOWPhRlmprkIWUXAEmjUoJckg14v4EelpWSFL7K677lKgjWkt72VxLyZ0            CiThDRUK&#x2F;41mUUAPYhicb4k9RJsyzpTyZXD6Ou6442SX2kIyT3G7rCmJRimX4+1MFArW1ABdmYVY            PiiB8G5TVrxv2lyThVAcmJQhpqwusupGChUsJWTcOeiaruUps5cZbtzjAhbCY32JNwqqbMD4KRQ2            RnGNkUMmGhoplPgAJa5srhDmcbb&#x2F;61&#x2F;&#x2F;SqirBM05YMSIEWbQbq8&#x2F;9rBq7BI4bXMcCIVCtvRkoTiX            ogcybaAFhUQqsDOgaOmqe5HN3p6mzPQ98cQT2Cyo0aNHS06s9oMOOkjKYb6Eg1hla6+9tmC95JJL            RiubDGJEXXuLLqKMWF+hdWvAAOi0jLfrr7++t0LcL3&#x2F;5SwVC999&#x2F;fwWwJQXPU0891bt3b4W33noL            nUspMxtReX01onk9hf4TXplCtffqqii1d&#x2F;Vqm7T8Cv5WyPnPMs9&#x2F;pja79Cl86t+CQ0+t1sbijAVZ            hnX73&#x2F;&#x2F;93woSK63SnQWw&#x2F;lGibOnlUjNErCtvdt46iii8+OKLOXszZBlcXW2syWgf2HbbbUObOF0E            dFM8K2pSRSE2k0BoUwaiJs4Ccfsj2AK&#x2F;&#x2F;e1vW9LmueeeCxGOVKEN6QShONOwjeAbA4XUcUTzMjEl            OhAnp6SN7oN+wQUXtFmbsI1TC210lmwTbKBcd7+DuPmU6Zhj9mgTlNAG2CYogSCmcromeGsA7No2            bTbccMP8WF1g6623LtuGARxMZZzRgatNMbJMVbFBJm2ojkKIslY2UWXaSOxz2QUOOeSQhtqYhSrQ            xg7lqOuYJz1t166dHThuDquN3TSuSQ&#x2F;0VEt110gBwjaZ0Oaorw0RAZMdnqFjshRs4wTJFqQTCy64            YNRCnEDi6q1r3BuARHfl49OmTaMNHrYMBmkrOQpZF420sRYGDhx4xBFHKMfxlmGY1LpwIjNKjVle            bTzMCT1ihbOct6Cw0EILobCNq0OjMVCLKH6pVgbC5LIRLtjQNnqSvliK0iiGof7mm29OeviNLCKi            HBEoQXdF0UQ5CkGPt7RXWHzxxbVVBQ7RBnzhhRdiGzJkyKGHHjpy5Mj62jz44IP8wwgOO+wwa+rg            gw+WT0kxeYzTwiqrrOLcNHHixNVXXz0e0AQ0jFu3rs8880wQubC3Osb5+OOPO8xjC4wdOxbR4lp0            0UVPP&#x2F;10k1VfG83kvJdeeqkUeNCgQU7KG2+8MSIHd0YJOK2xtkL0Sldl&#x2F;FWIWrZUu+qqq7oSwiPN            mo5owAfOPPNM2dn9999fRxscsl3eoHsNnn32WRbaZ599hg4damqkvcp77723K4VcdeatyKt8ySWX            GENAW9ff&#x2F;OY3GOKTGRdddNGee+4Za4rTmBrp4q9&#x2F;&#x2F;WtX6Sz+OtpE9JPPHnvssbfddhvbnHvuue+8            884xxxxjHdLp1ltvNThtd9ppJ1f6ueJE33777fXtCvRz5fiuO+64Ix5Xlthtt91ow3&#x2F;FGEGPNqZV            czlyQ200fvTRR7HKW48&#x2F;&#x2F;vjJkyejhG9C9lAgx4knnjhgwADX&#x2F;v37o6d9Kp6zKdBGwbIICrZTTjmF            NtzlpZde8vbyyy+X3mvVMPrRRn7PqmusscZmm23G4SdMmEDWFVdcwaomiFX22GOP7t27kxK3jFjC            FRElrlGgzdVXX80e3t5www0R&#x2F;awvc+ec+vDDD7O99attdqKo1cZ6MYtGT8o111wj6vAyrmOVUmL3            3XdPh6PLLrvMda+99qpceUfRPL32Oo5naJ5bMItGsO+++4Y2loW9z+nHOdDUx7NFA66jDY+xQJiE            0w0ePJgqP&#x2F;nJT+wvt9xyS0TVSZMmsR8Yt+sH06cXbUc9Wtm5T+VPn2bXrQ++dXD2WDtgajR87bXX            NLESRTwNr7vuOlaPxztQf6Z4qLkUb+ghFrsOGzaMBmJg+E3awwPnDh2aNezRr&#x2F;Lw+MoZVxZ3d7Y+            eHjvfmp5zAorrMCfSLBaLXJW79Chg3lhD9Gva9euqkAwq6ONSGDTfuihh&#x2F;r06XPyySezB9uOGjWK            aNoIWVxkueWWy7aVHMf36581lI&#x2F;SJm7FeeXaOEfa2iwWA1Cmk1hMG55n3u13BNo0zHjfvn2zLmq1            YUyN2VObo446yqHf8ouEIRo7SxNKp2ba7HpkZexTlTfeqdzzcGX&#x2F;E1BoY1cRFPBEJqTAbyih3L59            e2J5Nx77lL7qz5TZZQ+Ooo2+RUkBA2XcuHGMych2DKNksNjDC20uu63y8ITKxbdmNwb&#x2F;8tfKNgd&#x2F;            8eATajP7N3mxpcS1rRIw70YYEqzw0047LRtwXdtgTeA3t99+u4KDNxVFKlZxoCedkciyBxVtvXY8            PDPMdtnT+fPPGorfMPDMM888JGjl6q3opQoEcXui6NqrVy8bQB1tcIMNwX5pM5MkAEs+8sgj1GcV            UmKscQNLlRhXOf+GGTcoz7qq8mn2UBe&#x2F;K4a42m1cF1hggVhitkIjJ9CufPbZZyvU0cba22ijjdRh            pY1mw4cPDz0Icp4y8eRmhs2BodCpKb8pa8BvcDKJt&#x2F;yXA8mKOnbsiEi+kLbJJpuYqXPOOSeT1cg2            Adqw0DbbbCMTDUr5zBB6JHibja8JJjQxKEC4mgLnQ+S28Rggdoasi7ramMu8eYE77rjDmo8tHdgm            7VMJ2FyTbXLaDORiMmJoA3FmSNo0tI2ZigaBsI1CaJNsE0CPpZ7zNrONt67CkkL5PGUkyrSJt9CS            NqQ&#x2F;8MADK664ooKFRxuFsI148&#x2F;zzz4dtYqYgZoQe8bYKoY1IEWwBM2WHsk&#x2F;lymRzOpPTnTWlmXBs            hSuE3yRtUCxsLhl9qHJNCKIrOrYgQlBAQVSjjQKE39TXJhpA6ME2xfum&#x2F;MZM8cdMfA7iVBVvmhAU            14jFMVNaKbMr24Q2EgkpFOLMT74Rb+QS4TcgmIbflLUB4qB4kyPeuqaZyllmeHEtZmKbKqSTbzRO            u6ZyXKHsPVEbCEr4b1gIdB&#x2F;0OIfXX+FVayqQ4o3+TE1cvVUVbxVcgxII5pipqDLRwiBtxOJlllmG            NrLHeKjb0go3UwKlyQZBM+5RYPZW3mPPIzdskxZLXE0iSsxLUEJIULxVcDQLou1PGokiy1GboQW&#x2F;            0Rh4T2ijJ4JiZwA66U8+QAg25bhr7y0iJIqrhuiuH330USY0f6RCj1133TWYi3lvvTY2FEZ+6qmn            JKYyN3uQLAclOtB3uEUoFwUUKYQCh0t0emjl5GumKGQPFinOOuusLBdopI2plQBI2Pr165dmSvfr            rLNOeU3FgwKgjWtQXJWjoBU4gXtrGChyDBkSY9x0000yCjrZwK3c+rkfbdZee+0&#x2F;lmBLD224yz33            3INiZJJRo3SlB4orhuWXX15&#x2F;gBIfH3bUReclynIj+b+CbcFWaMwiiOGZr4ZebBbiYUQZ0mTMcdgD            TuMtcZmI&#x2F;FlJaBPlgHKnTp3iKYlZQNl0003ZNWqrcOONN2aNq7Xpdlj1x7riVfvRrxY+DNby58TK            tVWc+2UJdUmb&#x2F;4zXXG3+t7z+4x7g&#x2F;Ue96linS6&#x2F;KdXc3e13fdI1XFb2qqupavEYUlHg1qx0xg1Ku            zQpa5bWJmK4hMArB0Kw2pxeFptrEk2oTJRXik0fpVcc6efJlz7s8xxVXXBGFMsrE7LPk+Yca4q0q            e2oWZPNbbtddd13Qy7jllltSHLeXFdTLL7&#x2F;&#x2F;&#x2F;vsTvRayomDTRXZrtzkkuKGVQqRWYAtPTaJQRpk4            derUrEHTxlC8GlnHTmqLtCdKjH7XAPERs9he4+mRNAE97v8D69Bg6NChciw5z7nnnhsNb7jhBlZg            xP33399JSUMpHbotdb&#x2F;99is+F9cc+OX4OIFiO+20k7ZlDBs2LIQreCvRlTXG8d&#x2F;xPapqYXT2XjxZ            jg5tso6W5uGNN96Q0O6+++4OrgoQtxvlQeSGdWQejvx77bVXcCrIaOhntMrm89JLL91zzz2zW5hN            +PzzzzWJW72LLbaYhjI9nCeeeKJydkOlhGSdIUOGmOpIncqQgYMu4uuDMjKJRFhHQqP5hAkTMtVz            9aLAGdHZEc+sWyflqQlxCCxbxwkS88iRIyVW7du3d3iQ3Gj7yCOPSPNkcJtvvjltxowZg&#x2F;mtt97C            HFh11VUJkYVpaDJRDAZFphYMgQ033FCaG5wbbLBB5OAmafTo0RJcZaZhDvLJAf3y3LJ1jF+5DGep            r8k6sbIWXXRRaTHThHWy&#x2F;vL1ZVU71DtXqV1iiSUiqy5jyy23xGmEOI855piC+o1vHHHEESgSRuWI            DppHFZCjR3oqaxvdOeIuueSSTqZVvjOnrKPjZ5tDKMVTa53HHntMbUz+iiuuuNpqq8VNUYWOHTsS            6DSEoawo35k4cWI8xIrvY8SNz0B8zZMayjGAyZMnWyOMgmIryNXJYA70pSNwSIgPtJato7ZgbYID            zVeyjmbG0whqIVkHf5zuzBvfEVZM44ILLujoqfD+++873VkFGOJJIC8QmB5++GGixGZ0Z2RC+Au6            kxeeWus4MDkBOznhUbbEHGHRHd9EXx199tln88wzj36T70AoXBfB0Dbr6PuD1sGZDr+ZMRUGTK0n            n3zSeZXbi532e0FdYamllnrnnXdiOwvh1lo8qqZcjGfeeedVjq9aWLzKYR37d+ooTo5OoPjjqRWj            KItlNkG+wEDoEZXbOorWWqcWcVMunuUH4n5Y+A7QLMGGZYbVgjFTNOjBGQgK38HTuXNn5eHDhyuX            rVMXJpxr4xfI4nlCLim7ZcFngyesEx29mn+1vAwHavxxLzJQjGIWrBN3ScMJy9ZhAhMl+mR3e77z            HQsnVpZQ8oMf&#x2F;EBZYA5QxcRaYvExESsLPy9Qjs&#x2F;rRlSOlRXWIVzDo48+Olc+A9uFNBBl8JBgqcbK            4kE81LJio&#x2F;ApVaHYsssuS89oGM9GMaCfd9556DPu10KbrGNrJEikpE3gtNNOM4C0Z0VsCpTjTrw1            sXTNJWUfzmG+oEPeIitHIawjjuri1FNPReeqiWI7D+YAsdwhapnm+9&#x2F;&#x2F;PqKlrQtVIhGvyZWdAczG            H82jx4C3Z599Ngai8LTZOtpLZJVjZQXCOjyC0Eh27Vbe5o2aLTFvzSeHFxqMJIhiashJKPtOQWoF            4mZWyGSjWE3KmRI1CLZAPIo+&#x2F;&#x2F;zz6T8re1YCWUWp1EG8Tffh4fHHH9dTPB5oEzp16qQh5ZS32247            5aKPBoioHGAd0TQyQ1tkbdwp7+ihs1wcZeONN9ZRrCkHnVTbWuvUZoPhL4HwozvuuKN435TvBOIz            nlWIlVW1o0dVQiPfiW8OxEmCYkJS+gpBijvhOxEK056VdnTQHFtYJ6Jy3mdzzIJ1omHtyqras3BW            +Y6ZTHGnESIqB8J34ssC8SsEbUL4jjmIQAONcuWvumeVrUNQgqhcyMt9J4j4XelUa53IQRLsGkVd            E6ws9PhWB+sQcsoppyg7baL37ds358pgALmMLF0I3xG&#x2F;CIyVBY18h3ViFKFnQLlsnbbFnbJ1JN2F            jCbU+k45VwZa2jKDuRa22NAvw8efVSZMyr7q9sSz&#x2F;3zs6b8&#x2F;&#x2F;NTfH&#x2F;pDcX1k&#x2F;GcTJ4+65574kZUA            xYqGTZlhoHzOStYJymuvvYahvLLEnRkKlNFK62hsGgMMlChRjlUmTKBEOGAaUEjwlpYJTtj0FkTj            7aabbvqvkQ&#x2F;P6HTbnpVtehbl7X6bfesgVXntesQJ&#x2F;foV01sCK6dOFaQ84Tt8VplbiYDRHdAz6Z8+            PpUwK74TLcs7emSD5RgUsKPrOK0s+lEu668RaBlf&#x2F;4vXG+9kH4W6fHjl1nubvS6+JRiG965jHUh7            VvKdgBgk9+nQoUPykYg73bt3V661TtviDqFGa7NgI9ZRFiaVWSfKJPId5dR9rXVUJQRPwJ6VfQYq            rLNP&#x2F;+wDP&#x2F;DQ+EqvUypHnFE58ozsesSQ7HXI4NCKde68805dAIuIO5QxhSEc0bUclcM6yy+&#x2F;vCps            VJJSKV955ZXKG220ER5NdJuaZzrMQtwp7+jlqBygdCa3ZJ20o&#x2F;NzFKcHhaAEmlnH9cNPskdtY5&#x2F;K            nu9dcXvllnsrZ12Zfdf26rsqb74XWrFOdAdMELkytOw7wd8IskFG6dWrl3LbVhbTWsCBp556KsTB            YYcdhsJ3TJGDTzCA0zDrOOmgx5IUleO0FaK4EoZMgyrreAk6H36craz3P6ocfNIMTc6+OuPe&#x2F;Sjl            O488Ie6lrrDCCsTG&#x2F;aCqqBwdsUs8C0&#x2F;gQaygufLee++dycwRe1a4W3GjtpXWMTnaZGe4euBH9LBn            Fe+&#x2F;852xY8dmRsphJRpArCzX6dOn00CYpLdawlln4IknirVFj116VU67tHLZ8Mq0Dyt&#x2F;&#x2F;Xvlnfcr            706v&#x2F;P0f2ecNBw4Lni&#x2F;HvxDCAwxBTlgnFJBtvvfee&#x2F;rlrVEL5qNo0ITYyMyl8sEHH6zhWWedpVw0            aaV1yuC90pb4XCBByoMGDaLWjTfeqBywko0&#x2F;MHnyZHZBfP&#x2F;99+P2DXAoenMuQiin9kuKCjRVvde+            tj3kf158zfwbOeF2n29961tPP&#x2F;00CUsttZTl88477ygvssgikm89KgOfpUM5V44Z2m+&#x2F;&#x2F;ShgLpXP            PfdcNj300EOV77nnnmyorbQOG0sTdKwPo5VQnWi2808PFr194xsLL7wwemD8+PE4OTynY82U7yy5            5JLBsPrqq6ddrHySYG5N4lasjcOiOPbYY5WPOuooAeXoo49WG8eUSy65RFkrZRlQiGWgWMhWVkRl            b9H570svvTRmzJhgg33yn1R0lCckxhUrq&#x2F;jARaCV1nnzzTd&#x2F;&#x2F;vOf77XXXilYBMI6P&#x2F;7xj9Vee+21            zz&#x2F;&#x2F;fHrwhnPttddGv&#x2F;feeydOnLhKDgd0niJO44QI2FOnTsXG3ZSfeeYZ5d13312tVE1Zlowu&#x2F;CuX            EW5oNa288srxrVa5MieK6Cs4AqOolb6OGzeOi5V3dHbRxYUXXkiUcSXrmAx0tRlTm1YWF2X+9BgE            DjjgABJ32GEH5R49emy44YYXXXSRcsqSYc899zRyNuLAfNCsOtfgBIWCqQkaak6I&#x2F;XH&#x2F;&#x2F;fdXjmzY            VTketILB8CY8b7&#x2F;9dlCgHJXXX399e3Zkg1ZfEDkaISyFOfKd+CxpIKwjpST20UcfzUittI4o4xh1            0kkn5b1UQ7qx7bbbnnfeeXh+8YtfoKRPxcL9999vO8u+MbL99hGtEgQ&#x2F;TeL3mwJxCl1rrbXQOTmx            V1xxBbp1pByf7MGjVtDNW2ROyvQou+2229Zbbx22SDu69eu81rlz51hxYFkx7pNPPmkbkccGG8z6            yvrggw8kAl27dtXeOlL+7W9&#x2F;67reeuuhRO5jwhGtfJS4vzNs2LCzzz5bLU4FHZtJYUj88xYiyY5z            FmceOnSoFYQ5jmwrrrgiCrZ0jQJ+tQKqsuDCQeIU2q9fP5RQzNaTmoCjLKs5bakSd1HkrrkBZuDm            m29WK55qKBhlpFZaRzDnydakbkA5cPzxx5966qkkipdBGThwIAaBgHVSNhhR2exRHQ+G&#x2F;v37CwQ0            1nzw4MGIJKRyt27dNCzDsUgrK1SZXZQxg8WerAMEmozoQq1ruXDxxRcbS&#x2F;kUWgYHP&#x2F;LII9dcc021            bcsGOaoVG987EFmVww+t5A022IDQFI+kM5ncUq68xhprGJXlY4nZgxjll7&#x2F;85brrrhtLQPSx4jSM            xVi+v1OG8evINOhFIFMO&#x2F;l122YVwAyNBlSUWUVncsZoYLtcliwwO4qIM&#x2F;cvWGTVqFFFyWnRBnYT4            eYe2WceeR5zpJUVotLz5kR03vgMXK2vAgAF4yrjtttt0Ew+LrX+68m38VWAyzPGJA06qSfz2cC1q            n&#x2F;Y5+jm77LzzztGjJWnJUEytkZshCxlxs80247lSJDzmQ3OplrJtVLldu3Z56wwRGdpmHX3IF954            4w1lsUN52rRpygYj&#x2F;Ymy7UM5sOqqq9Imdi5bpv4Ei+WWW46&#x2F;sIUtM9jIcR09ejSGyHcmTJgg04sn            v3Y0+VufPn2UA4ah9pZbbtEqBfhwB5T27dvjsXPh+ctf&#x2F;iK3cM6IIGX7r+r0d7&#x2F;7XS5yBuLbgPxL            uW3Wief5vGCm4Nv4JalSpMjHbS7MCijAiKY06ztPMjVZZ5111HJPlFhZFguKrcDIRY1c+RngL9Ec            OnXqJMPErExC1k2OsJF0VKppnuLul7QguiPW+Imyjqh0ww03KIsDap0ZNY+b0621TpzRLVELhB&#x2F;V            BbfUR3FnpATeK82NlWW&#x2F;k6encKCVJrFn0enb3&#x2F;62kITTYlGmOjuWrWPxaoKI3waPx2yjeEuaZG&#x2F;e            eedNd93xi0ERhsI6sdAUMIR1DIqQeHJpS1WbDmUZ2mSduINhD9J3GfYIPNTVR7IOTocdtfJXS4xR            2IiQ8h0MoxLvYzyso3n5vjKlQzieAO1Tw5gMZ+NchQwx1GSd+eabT78c0HJWpfdgC8TJRlAvROef            9wnhMzAL1mnN53cMEn&#x2F;Uph3daMUpGpvPdOcUW3wmvWwd0JGdCCU9R8cZiJWFAexlxNpu4i1oq9b4            tQ3+TIkSxF0Owj3jbfAkzEo22FbrGLbBB6ws&#x2F;iJtk+&#x2F;ZKWLSQAEdA&#x2F;PF7RHEsI4jMkositpPGcTz            LHkAnkmTJpEQyyEOX+WVlcCPBOlcnWxKMMTK2nXXXVF0pywJ1FZCSCznxTMr1sma1UPtyqITShw1            odGOHnEneMqofdoXO3psyQGKBXPAyNO9wTijB1tAnNaRPFjZwsRffiYRGZw0OkRlaJN1sh5mhrJ1            IhtMoCuN6QGWWHhHvMVfXlkhAZTr7lnoEXeA2CLxL1kHzIT54A6RdrYSs7Ky&#x2F;o9i5taZ+0qvudZp            6ZVZp+anz+r8KppCXWKjQu2rXFXL1vraFl6JrbaQXiitZOvaq&#x2F;LO+3N9p8Frm56Vt+dap9FrrnVa            es21Tkuv+ta5+q7i21zpm13Z1728mr4PlmpnVDXVlquK2iZ6uTajp1eJodkruit1WnVt1GNc41VF            zwqNBV57VzM71LfO34pj8f85fPllMzu0YJ2RI0deXvr2W&#x2F;lrcIFEcYD44IMPoozoYJFOBlOmTAk6            lCWkZy9wyy23pKqqxztlOB8EDxQnxhKckwkJOXFTDahx6623JuEJiZIK119&#x2F;fXacbL11fv3rXxfn            kBbxrW99i9xnmn6VDtZcc82spxzppkEVHnvssWCApfMv5ATSwGrhmFYw5TfYC2oTnLaLum98Y+zY            sUFkHafQgtoifvzjH3&#x2F;JNG21TnyTsS7iyVTZOgvkXzC87bbbku84K6Jssskmart37563y8B3tBo0            aND+++&#x2F;&#x2F;wx&#x2F;+0HE3vhR54IEHHnLIIXVuSjW3ziKLLJJ917GE4447LiTDoYceijJu3LhkHQf9oq4G            5513HoZZtM5HTd9&#x2F;rYXVhKFsnSWXXDLZpYwjjjhCbfyyX8I&#x2F;&#x2F;&#x2F;nPeIgKztx&#x2F;zp9k&#x2F;vSnP&#x2F;3+97&#x2F;&#x2F;            t3ofqStbpxYsEl27&#x2F;vKXv0S5+uqrk3X+mP+xTl38Nf81l1m3jmH07t07fZcyvh1KaNk6VKfNRRdd            FLWu559&#x2F;PiHjx4&#x2F;XZODAgWqPOuoo5eKDIPkwRowYgf6T&#x2F;Bueu+yyi9pLLrlEFCBhr732qvKgsM5S            Sy111VVXxb+OlRHWufLKKwlZaKGFUKqsYxQcUy3EWPbdd19dfFXraFZ+mB8QPsvWwU+V119&#x2F;PWph            1113RYy4c9ppp6mNX4ssP8ZGhKq4Q&#x2F;J3vvOdeeaZJ+74JYR1BDVN4ktLZYR14hsPgSrrGEVMQ4IV            zUm&#x2F;Duu8kv&#x2F;syjbbbPPAAw9YzOhhnffff&#x2F;&#x2F;BBx885phj1LKL8pv5z7UflH&#x2F;FNvC9733vm9&#x2F;8Znzd            dqutthJxhSFQKDhydMr&#x2F;0WveeedVji&#x2F;aLrfccroTYpTDOqxASODd&#x2F;G8z&#x2F;iOsU447f&#x2F;jDH4wtrBOo            jTvlL1VAOe4UpFZgrbXW0l3cSExxp4z&#x2F;LOsoL7744rHsy9b505&#x2F;+NHXqVMtebTxB&#x2F;Hb+HemEZJ14            uJpqv&#x2F;vd7&#x2F;LKJ598kuT55puPkLhzHsBGVNyrLUflLl266EWm859lnTLK1glE3KmLZB1QSM8wfvCD            Hwicb731FoYF8&#x2F;&#x2F;GKn&#x2F;6tYyyderuWXPKOgb&#x2F;0ksv5d9QngFbQK11rAtVN954o7IpXXnllcUXooYM            GbLSSivJhtCtMjyqlAN2rhCIc6ONNvp5&#x2F;tveUVVrHaEasxxX7QorrDBx4kRvQThni8GDB+tIwoUi            ipetozxp0qRgDjz&#x2F;&#x2F;PM6&#x2F;UrWYQIi6mLatGkYytaJuGN6Y3hirTiNk0XSQ4LYsyLuYEN&#x2F;+eWX8SBC            xJ2gK9Rah3zMsmEM0iVDirauYM9CV6tMq2QdqzUYamERYJhF61DU+OsiBqBQ1zo777yz&#x2F;u644w4M            dnTlvffeG0+yjuaPP&#x2F;44umUrgpSzQRrzEUGn7soi0NrR8IknnlCOZ9ZOEspDhw794osv1CqXV5a+            UOoiRtFm62y22WZ0minECNbh4crLLLOMwVBatiLuUJR10FlHuUePHsqOJoSvt956LMI66PIdWn78            8cfK8RheOCCnbB1lUSOsYzCaY9ZcWaaqzOiEOxawSDnuWKfoM4V+22adTz&#x2F;91LKaKWJ500&#x2F;ZYjbD            VJ8+fbrQoLz99tujW1nKF154obJ1Tvgnn3wiFdpggw3QY&#x2F;ZEpSjXWof&#x2F;68XGl6xjPJiFVWXTo3zY            YYeF8CrraIU+UwivmNtgnSpobEjAU4KiEJRMbg47rn2Xcqquu+46Km6xxRYYWAddmh9sAWPecMMN            jTCClEKUy9aRKDJ09BIYM2YMZkbEjFOZnypbX9RgHTzxkyKsU&#x2F;SUf0oumifQEHhAvFX4StbhHaEu            QUFh8lBUN0HRQUJYJxAnCQi2QFDA0cnKMgDlqpVVtK8B98QsD1I+8sgjczGZcOf7YICydWTVBTWH            OdCdgaTUoc1xJ0HH&#x2F;NMORVbZOryxXbt25FojZpixwvkNLFZW1IJwgP7ZZ5+hx8qKT9ngVBZ3rJRy            VA7rLLroopZMaA+mIQS6du7cGbOkHD0+sCGKEy7rURsf5Bg2bBhKwMkDHWLxss4bb7wxZcoU3UUX            xM6idTTr2LFjmLlsHS5jGCbBJKuF+GTFhAkTUHbbbTe1gazjSsWBCE984MEZiihBRLmudchxFW5i            qPCjH&#x2F;0oF5YhzFq2zjnnnEO4nYv140TGH3OlMsh0oqFFFLm1PYGxvDWj3s6idbQ3yaussgqhsPDC            C9tBzDztBY5wgQgcUN7Ru3XrpjZlwBC58qBBg9AdkfA4QyprlaxjA7a4+Gl0wfT0dvLUkHUQA9wQ            s2mgkoiDcsYZZyjbEI1WLpIrOwOvvvoqacZCsre5stmB9r0cKHbbWbGOrYTqcuUsc&#x2F;rnP6klvsa6            ZZfw0ugMqrJB12233bYQ1GQdxKgtl5N1oguuZ25jA0KxCjAkfhD4MXNetU6hKPYsw5MNKkc2WAZO            tQ6AavOeC3jLhYNBX222jhnjotJZ7W3YchniyGUdM8anwFtEBSmSPrhx0OHgg7P&#x2F;jJPmS4iEzIK6            yiq26ly9Ask62o4bN85q0qm+tJJnjh492jQUrDlWW201VbTS3WWXXUagbRFnnz59lPlUrnszMIEt            Mu88A7uQ6UCzxhpraPhC&#x2F;kNPs26d2LMK7XLrqKUcup6EvcL8ORQSvKW6JpdeemlB+te&#x2F;ZuMdjOgu            7rqLPrn4ZptjQlQBS5keeQD3FM41nMW4w7Riweuvv66xvFPcDbAOCqs5wpDOOnoVLFFqse++++I5            +eSTi&#x2F;cvv2zyUQLt27fXxXP5H9+svfbaRQcNsHjpa&#x2F;thHVunhpIGtaJPLj5DpDA2JuX43CCYwlde            eUWgMBaOw2WcRTV0ZGOyNlsnM3UDjxB3CjWbrFO+c9p6CJnMGqldHLVbQOxTgaq7X0Zele+ojXOW            M3oMgZlEUs5udgVp25kFkQvOx9h669xzzz3Wgl2QUW+++WbLO&#x2F;O9Jkh8L7roIoE20LNnz0suuSS+            9udA5MCJ6JrgbSjKO5TjDtnWW2+tyj6iiwMOOEDZaUOnRLkGlK+&#x2F;&#x2F;noMVoG3VpDmW265peacDmXA            gAEoxx13nHLfvn0JseupLVuHBelvEZWtQ+B+++0nzyiGBK23TtXdL9GHuBAC1q18oTB5&#x2F;u1FzIHy            074yjEFt+Ywu2Y2qhLpxJ&#x2F;57NN11x1a+6x75TjnulM9ZYR2gv6y1bJ28w+aYBeuYtwMPPLBr1648            6LYct9566w477LDTTjspDB8+nC2sKQfOTTfdVBO5Q&#x2F;C4xneGAueffz4ep3ZlSUqXLl1EBOVRo0Yl            fjnkNttsE4mCAn5szEoHO72yXUkTW5uyWojj25133okimSKERyg7kSXrGAuKw81NN91kCYd1LOfb            b789+r377ruzGZ0F6yhD7Z4VccdIkqfUxh0jjKoWUPXExuYlHNjULYSCo9WIJzbxM+uQrFN15zSs            85XOWVXWMXsnnnjiMcccI09Dt85POOGE&#x2F;v37H3&#x2F;88W2yDk8RKcro168faZHvVVnHQjjppJOCTewo            ROQ3A1AEPuN&#x2F;5JFHlOnmGipl3AMGSIjK1qEkCWpDZ5Jnm3V0E6C6NCEkiju6REwM8RW6MsTdqEqI            X6Asw57FMWPPevvtt81qWEdfVlM6Z4kXIUF3EXfsWRQ4Jf8po0CjuGMLz5vOUBVmj3V4jdW+xx57            xI&#x2F;zhroXX3yxXQARqCjZVxAgRAG46qqr0tck0eP5bBRWWGEFdJOMJ0BLXQgKyiTssssuVisoRBk&#x2F;            GAkJHI1uDkeYBTIqycjUbr755voVjwy7bB0xBWePHj1w2sKZwOaobC8Wd6655hq1Gt544410mBXr            kNjCExvas075vrK2UL6&#x2F;U4sZ0fqLLyovvxE&#x2F;3OT1j&#x2F;jJpuyVFf72xMQpz73Q8+CeyUaxZwXKuU&#x2F;d            JzbBBsstt9xs3rPuvfdeHRBn8GK7MksHlJl&#x2F;r732UoDdd989EhDbvHIgvphdhgnUdosttlA21Tfc            cEPlvQ+y31GnRJUC5VeXXv9z672nDB5MuObFL53kKFunQ4cOOh05cmSV7&#x2F;B6dNEgrMNBbFv8hRvm            ahawKbfNdxhFg4BuQAFRQS1dF1xwQW7FP00FbVyjkJAtjxJkaxoefvjhypbJm6++VtntyBmdbnvI            jHKXXlUm+&#x2F;OTE+V+mUlKYB2iUqfKKe4oMwH1WE0ZRH3rMcZiFPSPVoE2xx0hRuZiTTmGOK1ETx07            dgyfJN1sYADSVTm&#x2F;PPbYY9EZ2K2EW8QEy17D6dOnK2cHtycmzujxN8dV&#x2F;vRJZc9js78+3P2o7Ld4            rvl9VvbaNjPTFz36rbjiiplJSrCpESV10p2AJXv6OP&#x2F;OrtCOLmmm29ixY5Maq6++uiBNjdlgnY03            3jhasoKOI99J9warpNees2qfFFfj9vtn9NhzEF+tHHpK9Y9+ee11LIYvu&#x2F;RaKf&#x2F;tsVqkc1Y4dYId            AN0hOd4avHxHOiKSsk5skQltto6cwhYQK7audX70ox854OKBuPnWeuv85je&#x2F;+Uv6+Csl&#x2F;vC8cFo5            aGDlzCuzV&#x2F;rTSq9dsj&#x2F;SrLLOU089Ze+Tr+vU5kABq0Z54MCB6HFDtmwdSbxDua3g2WefFdeVn376            6dA8EFt+G6yDm43j&#x2F;o5sSnwJ6&#x2F;DesL24U45EUGudEJIYEjbZZJPPr2n6c9PR+Scs8ex7fOkn0Zp+            GG2Hw&#x2F;CwjpVFVEA2LNzEGb3cRdwbjFw5rPPiiy+qFRyEHha0kRsRHplUtErNoQ3W6datm8Muu7z1            1lv0cD7kTcZvMcchWB8K6KRnw2uyziqrrGLlRwiwieCJZxJlzLBOt0Mr&#x2F;&#x2F;hH9iNWhBw3dMafi8br            9bcj7rCOsyhRgc6dO7&#x2F;77ru8xpBEYhR5kLKYgm6f1UVYx5JRa4KVF1pooYUXXjiiuIKQ6lwNGHjT            rMSdlO&#x2F;ogCCBMOXKAZ1VWad8Rr&#x2F;rrrtQyoeAQDPfGXZjFoNsqHZ3jqN81R2Vo8&#x2F;Kfj+OJii5deLH            DgLlT+S2HHdaQNwbBOU2xx1OyBbGGdYhwsqSSska0K0sZfuXclIrrMOHYw3CVltthcGqDIaEZtax            lx8wIPOdHv2yrm+7N&#x2F;sj1iefrezUp&#x2F;LBnypj&#x2F;4CHdUwvUfHDB2Gd8ePH6yJy93I2uOGGG6KHvwRe            eOEFS4kJMDvKkQMGMv&#x2F;881MVQ5utwz&#x2F;DtEyQjtFkEYoo6HBIfQQPU1LL0sMQ6oaNuuR&#x2F;cy2i43FV            DjSzjtcJF2RxZ8AFlZden0HcLv+P2j9OoSXr2I81ZBFi+bVyba5sGnTEOnjKsJ0b&#x2F;OKLL85f4pEk            pHMWBstWDG2DdaS&#x2F;ZMG8885rqKEEeBtPgtgiGOC&#x2F;&#x2F;&#x2F;u&#x2F;KacDXQqK2GwoynQlqm&#x2F;fvniuyH+RKdDM            OuLuR59k1jn7qsqnn2cLijeJRw88kRHF7K0P&#x2F;tcOh8Vt+ejCrCjXWkdmrKP77rsPTxmRBHKfCMa5            CoV1QIEHYGiDdST70bguREQuyurx1lEw+dETTzyBLlUnJLwmvnd&#x2F;4YUXKmcOnAv&#x2F;8z0PFd1RwsoS            bo4&#x2F;PwvPn&#x2F;658sa7lU8+r&#x2F;zji8ozL2ZmYp3f9OWeufgMEXfDOlYQBRz9KdCrVy9lJ3i1YMDlVuBt            WEfBIphvvvksrqC3zToamK5GaNeunTDJ5PGWoiJRYO2110bXnJC7774bJe7dyMSU40lxpuXnf46R            N3s5Q+x6ZGW&#x2F;4ys9+md&#x2F;udxE&#x2F;9t1v9ddLj6DEzIhYR2mp8AZZ5yBfvbZZyvHBIABr7zyytEkwBZW            FgPRX3Ko&#x2F;OGHH6Ivkf&#x2F;vRxusk6APO2WkmGCrViZR4kC0MowbN06QDjjmYDO96I58BhAQKdXG7s6Z            s4PFU89nwaWq99pX36GPPvSQ1a252SbKQib8gQceULamlFlH7VlnnZVpk4NH0Dzu7wS0ZZHI1yQi            Ys20adNkABpKU2bROpott9xyYq3+eC&#x2F;zp+1AIbDaaqtZRDghFvn111+PHslF4OKLL1ZLMzI7depk            9WUPUuxKN96T58dXVM7Mk+O4RuHCmyoTJn34&#x2F;nSRzhg0t2xDGuERDXWhbGVRQDaYaZPDgb5sHcwM            QQJiDIrjmDDTnHRug3XIcj7QTGO7gHTTcmAdYS&#x2F;1Zy8LxD+J0O+1116TPSrH&#x2F;R0HjoJj6aWLf73M            UX4m8cYbb2gVVltqqaXshjqy+zAHOAo43BqtmafP7bffTqzgUghdeun4iElE5bivzC&#x2F;QL7roIvwc            OdgkJWKlXpyoo7uIyiYp1yhH661jW6ETF81bZdB92TrUqvIX+Y4mv&#x2F;jFL&#x2F;Qd1pHvBAPE+ANl67C7            kCReKBuYyQzr0JsEbJB3OMNf1ltvvULol1&#x2F;GndOydcaMGYMuG8TvDBVsgMF6F3HEQZHxK1nHQVEC            RkQ0DCTrdOzY0fHCKVSipdeotYtpYj9Cjx&#x2F;MPOCAA9Atb5SAUIWy8847Ozd5q+yIqDxx4kRvWc32            ZwzsLsEhISE+v2U8yrvvvruGRqhJ3Khmi+eee86Ornb48OHo8ZMi6YxOSWWnUPJ1ZyBhHRODuc2n            0LpI1qFZ+c5pUZ0jPqFSPqPHpwwC8bSvCmzBZdSyb0GqQflpX6Cc7wTi7pdMunjf4A5GUMI6wdbm            XDkgd+CoEF9ccaoUyYi75557RowYIR796le&#x2F;sndQNHkQhRB79uyplblCGTZsGM5AOfoEHn&#x2F;8cRJs            0mqdyyST1imLjx07NsrBZo8jNn7&#x2F;N1C2jg1I8&#x2F;grybhzGhCbqW0uG1nHRGq47bbbZh211Tq27aKf            GsSTYr3qIO5+FW1yRNxp5dO+8idUynFHUK89oyWUrRNxB7HKOoH0tK&#x2F;WOrMYdx599NE77rij6h5g            glW94447YrDIq6xjp0SXejDNgAEDgpggOqiN6BNgHcuTT92Z&#x2F;8aiIwiLWGsKoGA5qyrfb9eckPiZ            2HgEVLbOkUceic6bQlVgHa4hNnXt2tVhIoR8JeukO6d1keJOoGwdU1oVd8qIINqm7xSXvwkQSE&#x2F;7            dNqaOxhZYlWDr2QdSa0NkisaqkOTslPMQQcdFEdw1gGU2ETDOtJQB4XTTz8d0clTXh8&#x2F;emUw6N66            WuT4WUdk4S8ovXv3FqTitBE&#x2F;V4sIqcAB6WAYKBZsCMTszI1ywgkn6O64447jrcEfEL&#x2F;xhOYyaQE7            Fm+C9atrQyBEctS2uGO0kO6cxlsdpD0rKDw&#x2F;rax090tP5bhT3rMCrIMnvlP8yiuvWEoR7GeK2LPC            OoH4NDfTFO+b48UXX1SbnvZlVmlCpn2ewWFr857FnEcdddTJJ58s3Uo&#x2F;FkwVngzxNoDhsssu01P5            3mBYh1oYTL4mFgKKgKV8zDHHoA8aNEhbZeYL30kQiQYOHMiVFMzH4MGD825PjdsgZes49BLVv39&#x2F;            taRBcEYhAlxd6&#x2F;CdY489lvsQ0mbrxJNiIVazuDcIZtjOyhApWpfznVrfCcQ3AfZu+gaScjlXLsed            BOuXn4qgCuIr59IKsyuUrRMQd6gRPIHgBOWydRLxK+U7zzzzjITFwtGrs5+UhKKGJIvfYIMNRo8e            nadBWR4UnUFYx4kRwyGHHKLWBKI4AQs3i+T36hlarTREbXZMb2AdkNTZGe677z7BS6azZf7XdZIp            zUVc&#x2F;eb9j4nvFItB6PKdXJEMJ510klYOccrJOoZDDk4namX51KhRozSfxWwwgSxxMVc7g7hTVJQQ            1gnEnmXfLd43R6M9qwqR75T3LIk4eu1d94DQW1CbP89K1nFGcbIVKJP+zIStzdaxJsUIvm2Z9OjR            Y+utt47PkYWNSOeZGMqQrfz+97+3BWAI6zT6lZBOnToRGBstryQ5tsIq1FrHtqgLmY7uSHC1W3Eu            QHf45siiGHrkO3xWOeKAA13nzp2jI4dBdIhPPcxi3JFZRtxh+7i&#x2F;U3XOKqP8TYCWrQMp7gDHjHNW            FWqtE6jaswpqDgrU5sozRZut8+abb3JLbfRnTpxiBSB+9PLLLysrqMIQiNsuZesw4vL5V0LQTWbB            l0NzGUCyjuDC83Mls4&#x2F;8Pf3005KseEuOqnXXXXfSpEk2&#x2F;nz4GQRsckQZPHIOHdn+dG2PUw7vthVE            d6BHEqypXGoBpncMnDhxovJXjTsto&#x2F;zppsiVcwUKULTga0KjPUuubORpKwlYI5wrGpZRe85q9O01            MHjnrKIuh&#x2F;mzqc9i3BFEbAQzRfv27fmUaMfX3s3&#x2F;i0aXyjYLiELsTQG5j1bO+qpworAOS4lBOFmh            ZeuYas3jMVm5oyFDhqDLiZUjsYpPN9me0G0XYR0r9Pnnn4&#x2F;nbqZw0UUX1bsmZiXLS1pvnYg7M4V4            lMktgU4orlXlQDy9iT1LFdjvKS2QBWcL1sEQ&#x2F;hJ7Vll4bAUOEChxfyesE&#x2F;eVmT6sIyTLD5VTmGMm            zQu01TrTpk3jF3XBUzDUWkfcMTwbqrKtRBCJf+0JJOuIXNaXWkGBReabbz7lqpVlDDZNfWloVBjW            WWcdb4VqFB2hSLWVwzp8ECXaxsrKNc0+3JdWFgPFtiUv49RqsRVoq3XibghtopsE0xJ7Vtk6Cqqk            joa32267KUe0LscdEdoAxo0bxzpxznq19IncKVOmyM5FBDwg4oYhgHUwrLHGGhZUrsLfmRil&#x2F;E0A            ymgVUc+ZI9gCjC64oIdkaNeuXSztGZgF67D6iiuuSPsy0o5eto71rMr0mvCrrrpKOWapbJ1QlMy6            1uHnlNYpHpBAJOFhHSPPus8RLla2zumnn06x+Ma1rgu+JmiL+Pbbb4dwSMILzJp10jkroco6eIwk            &#x2F;uisfApV62gmnVUbsYMvKNdax3Ybx3TDMKV8E1vAtuItTTCYczzGqRzo27cvsWEdUdmYpZrKZbBj            bPOsY&#x2F;EWcpuQ2SUwh6xjR6cxoJStI51VtppUpc+cKpfvYLCOwWMD+VFYhxFjtsGmw3zBIwnQxFkv            +AGd2LAO4I9CGVIeAmNlhcwE9s3sEphD1rFNihEBjm0VXHnllcrbbbedOBJpiEOQcp8+fdCdITWP            b&#x2F;iFdRwR1C600ELJOjHbEHsWa2IYO3as5s4BNEREiclP1kkw7EybHLowiojKwj9K8CjrkZC48TCn            rEN1&#x2F;h94&#x2F;PHHDWz33XdXdgpVtmHjdFW2f6HbdJVtMehpZaGYzEbWoQmKbU5zwYuG8Vke58G61uGq            mTY5qBfWiZVl9bGdPSumhBBdYJgV6xAt0C6cg+eDQpV18IMx2ObHjBmDJ57z1Z6zZIN4NtlkkxAF            8WHopZZaSjnilOguzRMsGMvcrpz&#x2F;S18KatEXWM6a2NEJFI9pxbLRC5x&#x2F;&#x2F;vnoVMI5ffp0wbhjx46s            4CSELomNPFBfhKywwgqGOSvWyTWpg1rrxB0Mm26iNDqFlu9glPHT5t&#x2F;tK59Cg1K2TiDuYMRJIm5y            lyHi4Fl22WXpWXUHI+5+QcjJ0FbryLgkmnURAbLWOj&#x2F;&#x2F;+c&#x2F;pFDw33HCDY2QgDvdCo7KjpsFwEDzG            H81BzLKKaY8T+LzTo+SoQ4cOnAtlpZVW0kTDokGTdfbaay9ZZe&#x2F;evQkve9CoUaPwL7HEEmSS88IL            L4QaTiQTJkyw0HRRCIK2WmemqLVOGelpH1vsXbpzCjw57VnBExAUzGfeuoDlwILhqoEW7n6R3KY7            GLNoHRuNmZwpJBfJOgJeQW2C&#x2F;TuqYPDgwSh2+nirFXuhWDhBCQiiG264Yd66wLbbbiswiaDF+3XX            jaAWsDkW1HXXvfHGG1ln3333Ld63AvoqBEHrrfN&#x2F;Ea2yzjOTs&#x2F;&#x2F;jfuGV6hdiI3oVpfxq1OorvmYq            tlybyo1aBfHZPzazQ33rzH3Fa651WnrNtU5Lr7nWaek11zpzX7Py4jfHnTPXdea+2v6a6zpzX7P4            mus6c1+z+GqD63Q9tHh1aypUvRK9EcNMX9HQNRVSVbxmyhCvRgyJWEVPryqGMltdYvnViCERq+jp            leiJM96mVxXDLL9mKqeWgX9UuUF6tdZ1dupT+fizyt&#x2F;+1vT6e&#x2F;5Kb6teVbVVnLVtq5iraqteX6Vt            1auKv6pt66uqalt+VfFXtW1Z1Ezb1lLK5ara8qte28&#x2F;&#x2F;UjlkcLUnpFdrXWeXPpmsufg&#x2F;hS+&#x2F;rP6z            5vJrFlzntdde69Kly09mHxZaaKGRI0fGDfvnn39+iy22KCpK2HjjjSdPnpxu6ge+&#x2F;PJLDX&#x2F;2s58V            TDPD2muv&#x2F;YfSt8cSnnjiiTXXXLNgKqF79+7xczUFX+uA&#x2F;6OPPtp1110LKU1YZJFFttpqq9dff73g            a4Bhw4YtscQSRZsmLLbYYo8&#x2F;&#x2F;nj2FLIEHf3xj39cZ511CqbZgQ4dOowaNaroaLa7ziuvvPLrX&#x2F;86            nsJ985vf&#x2F;F7+TeUftBFapWea3&#x2F;rWt+66665wi2eeeea&#x2F;m35vWRfYgr9Tp07x8zmhQ+CLL74YMWLE            T3&#x2F;60xA4T9PHnDX89re&#x2F;ndomrLzyyryExYGov+a&#x2F;6wH33XffkksuGW0pkxpaIdbJZ5999uc&#x2F;&#x2F;&#x2F;nv            +ae4io5bBLYPP&#x2F;yQl4TABJINzdqIThvhrLPOateuXSiQsMACC9x&#x2F;&#x2F;&#x2F;2f5j9D8Zf8p1byQfyLTcrf            I&#x2F;&#x2F;Od75TNGg1zB2kufjxj3&#x2F;8+9&#x2F;&#x2F;PvscAcxR1&#x2F;nVr371p&#x2F;zHEmIkrccHH3yw7bbbhrp1XYf8pZZa            6uP8twaiSfRehagCZk1fzllwwQUvvfRSJi7qmkMrq+qNN96Ip69laL7llltylOC8&#x2F;fbb+SVNGPfI            I4+s&#x2F;uhcA2hY13VaiUMPPZR&#x2F;lE0aXr7++uvHx1Tmn3&#x2F;+q6++Oryn7DpLL720INTWuQjh6TMHX6vr            CM66j6rWozWu0759e65jeNGkZYgNVa7DIkVdDbjO1KlTW3CdYPt3uU74biEuF2gsv8x&#x2F;NxHDj370            oxZcp5XmSgjh&#x2F;07X0dlzzz1nGKzfAnr37m1JEdLIdUKUncgG8eqrrwrURcsmfDf&#x2F;HFnMIjYNOQo6            g5522mkiDeK0adN69OghGqPbfWwBmd7NwWTREYwdOzY+8ALGlfeTYbvttnvzzTdNEg8+5ZRTksAz            zzyz2acvm4PksuusscYasjS9aDJmzBgTHPRGSK4jnPfq1ct4Q5kwOMzUdYzL9HP6aFgXDCupYkb8            &#x2F;xGuU&#x2F;t5wiocfvjhLbsO+0ovJARgRmWv2W9e&#x2F;PznpjY+xWPYMtBwHZ2aDMkvhtVXX93sPpv&#x2F;&#x2F;Z6E            pmfPnqussgr6qquumn5CSytZagiPP0cIXHPNNYs3&#x2F;fPCvPPO27FjRw1XXHHFPfbY45FHHsEguaZ5            5FK0Fd7Gjx9flpDKCuzw2GOPbbDBBiGQKLm8qokTJ1511VUS3qBzQeZaIYeDQvKM5Dq24MGDB8co            Qp8oGO+dd97JF1t2HTlv0Ovihz&#x2F;84QUXXPD&#x2F;K9cpb1hS17RhPfXUU6yGWHadMlqzYbFsysHrQvO6            G1ZRPVux1lprsaTRia+nnnoqTwp67YbVCHjmuk5917FARSCc4HyxXP51v0auQ+zxxx&#x2F;PXvxGiLrw            wgvfeecdG0cZgoftI++zPqpc55577hESnHeE9zS1ZVDShqJWp7LXcFyQlNjdEGG++eaLHKUKjnvW            g6HRs3&#x2F;&#x2F;&#x2F;umTkXVdh3E++eSTGAWDm2yUua5T33UCegkU7xu7DhMAITB9+vR99tnHZBeNm1CIaIwq            10kChTS7YdXnXkH6PHDgQMrgcWRjjfAezmRPibZPPvnkMvnPcddFrVYtpMkMhb+Vuc7&#x2F;GtdxZkHf            fvvtHVuE4vK1jJRgtsZ1vv3tb8tgoqH8I9Y95k033VQKYkpEkZdffpkRNTRaKS0K+n333bfNNtuk            2zxLLLFECFlppZUEgyCWIb8RA+RV66yzjpljymyc+X80Pv300wTKug455JAkMIG0k046KRR46623            kusINiYghMh+pNtMQX6HDh2S&#x2F;2kbnYZuCWeccQYTmVHZjGNgjOjRRx&#x2F;dcccdCQG9CIct5Drm4uGH            H95kk01CoCZVV5CK3XzzzeF&#x2F;&#x2F;2bXQadEK4F5pq5Dvlwn3TRiQXtH1Ro1T1wEj4bl+zplmG+TEf02            ynU6derkNBcdBQiE4cOHt5zrtMZ1Con5b&#x2F;U+9NBDJjjachp+X+60DA2Ni7+GQNuitma0qG5CXdcp            d9oa&#x2F;HtcRzD43e9+5+AghLYJTobpf+hacJ3aNDnou+yyiyN69+7dDzvssMsuu4zAyy+&#x2F;vF+&#x2F;fijo            O+ywg60zMgyhK&#x2F;1cn6lKriOGbbHFFpjBceyiiy4ixFHrgQcesKCDP6XJROk9OrVdGnUIb43ryE7I            IZyVzjnnnH333ZcQeh588MFMh37ttddOmDChmK1KhTdcf&#x2F;31MaK+ffvihD333FPbsPMNN9zA0YUW            lim7jh3q9NNPb+tc4Hek2GyzzULI1+c6swVtch1zY&#x2F;IsFHRzfMcdd8QXFm06p512WkRgIW3vvfe2            UtFFneQ6KeqYeLuYjQAz2P4iGBDewi3B6NSBSMYWwltwHSMKITSPFFDV+uuvz3rRqTgadM5NeLpR            dPbZZ+sO3bi4S4xI7UxvCc4WcB2azynXee+996zv+Pu32YIuXbqwY7jOlClT2DHoXMR+fFsOocVi            lTSgizTodhN00atbt26IXbt2HTRoUPyf3I033tinTx9i0dVyr9DcWSaEk7PbbruRSQhIgRfK&#x2F;06R            l9hHLOu8z9uOOeYY5yb08t1kc1bXdUQXZolOCecxeZ8zXIdwuY6jX3Q6ZMiQ6NTK0YTO0enJJ58c            IyIkAgAX4bV1XYe&#x2F;il6YZxf22GOPNBez33W+HtD+9ddfd7JlLDCj8k1Ekea6665LtwdTrtPWBxF1            n2E1QmtcpxGS67QSLZywqlynqJ5z+Ppdx8SMGDHiN7&#x2F;5jU3axmHnrp1FM23Z8XE8rjb7wtOb4K3M            VwCwGQOB8nFGLLuOddy+fXtHj8gGzOKVV17JrFawvSmlLLUgnAJkhvD+&#x2F;fsL1CFw1VVXveSSS4Ju            FluOOjwVv+iY5SMN0LlzZ5tpCF82&#x2F;0vgEH7iiSemqLPVVlvx9aBb9DQ3UpuUt8ZFiDRr4YUXxgyN            XGf69Om9e&#x2F;eOTuuCnQcPHpwO5FdccUXMURkHHniguTCDmcSv33WMXHoRxpWNCgacoKhrgnREwAhb            WEwp15kpyq5TRuQ6LbhLC2hlrlPrOm0C4eutt55cJ4Q3ynUSRFMHn4ijZTRynddeey3umjaCgUhS            P89&#x2F;aNWMHHTQQbVmnLNpcl3w0zfffJNN7dCwxhprRHRt5DqmYezYsU40YG1JX7KjTnNY9DFO&#x2F;OzC            vohWBoGaRFtGjILY9vzzz8dyEVEuvvhiSwq&#x2F;VZt+ffndd9894YQTQkivXr3Sl93b5Dq6MOu606le            LABhIzf7DBi1ABCKlTFq1KhkikauM3LkSKGaDWkuezNAEJO4BU3wS&#x2F;wl+0JdZqMcYfN99tnHOTE6            CrO4yucOOOAA+ud6ZX9+tdNOO2GOCBRBGk&#x2F;8TzL8G1xHZ3XvJjdynQSeoe3WW28ddknwtk3PsMqQ            sbJjBIaWT1hBb5PrlMGzjzvuuNpbheXDeSM0cp2qE1ZsXuVcpxHK93USnActswWa&#x2F;5gi&#x2F;PCHPzz&#x2F;            &#x2F;POJDeFf032dMix0S4Qjw&#x2F;777y9LkGdIUEABrr322oEDB3Lz4DGMyHs4k&#x2F;0liJIVMxSqJzRyHVVm            3RlEQz5ESDzZKKPsOppIR6IjaYdJzcVnN9k22WSToG+88cYxW1Wu4&#x2F;zidGYsVrBRSDgwG4vt1ZRg            MK&#x2F;PPvvsTTfdhOeCCy6gYcwuOc7hITyBtpIqkS+EU&#x2F;Luu+9mIvsv4WqDrW&#x2F;fvoxGoHjgiLfzzjtH            2&#x2F;POO0+oS4atBa2EW+YSF8ePH7&#x2F;vvvtquMMOO6y99tr0yQc9AyKlnSGZUXgjgXBHv7fffrtIHuao            6zz44IMWh+mhykorrfRy&#x2F;n&#x2F;vZVhMp59+Oh8Pje1o6RmWSBPEuiCz&#x2F;FEva7Tu3WRC4oRVRtl12oQq            10lA4aORGUQYq01Nyvd16iL8qeonYYAXnnLKKcJzsKUTVvlusq7t70X2OjOIGSJHy8+wyiB8aP7H            XNX4+l2H6sOGDRMzxBKHCH6Tpjy5Dh5uwcFBkiQABE&#x2F;Hjh2tHtOA&#x2F;v777xeRM&#x2F;9dmfj5qTLeeeed            Tz75JFJjYuUxiy++uE6lBRSYOnVqwdeERx99dPXVVw9N6qLKdaQmq6yyyqKLLipFSN4P8803H4qO            yjBVtTtXFexNwl7wSy9ef&#x2F;11LmKJU140CiUdwcJ0yyyzDB994403ENXG5hKKtQxs9tb33nsvBCaw            6m233RY++oMf&#x2F;ODkk0+mAPqUKVP4a2glcI4ePbow+5x2HfuoKM3oK6+8criOuYwTFm+oQnKdMBlY            SQ4LKdexuTz++ONho8TTGnDEPn36xBo1PbZOHlDUNeGll15aZ511sjmsQahn7rmOsB&#x2F;8ch1+Y3RR            O2soOqjBWmutxVzGGIge4ayzzjKvGjKsXEdMKipKwJ9Zv8ZEiV5G4jEv9913n6Mo4ZHrMBH7u8p1            cmX&#x2F;ywL4mnIdcdv4TYkEzSqPDICWgm3QoyoVBJKIuhjkRssvv7wIseyyy6YjQHIdQqwSQQJDGZih            eFN6a42mZFAIFBUkocGTsNRSS9XdxfTCppMnT37xxRflGSuuuGLwO7yMGzcufsAtDSGVIb0tEwNR            BbfeeqvkrOiphOQ6Vo6TkZitR2OxACZOnEjChAkTrLQOHTqEMjFSkKPIwCJ9tv1tttlmwWC7FD+q            vIdwC0ATDfF07do1hD&#x2F;zzDMijRwA0XiHDBkS2hJobTN+1ni2uw7lTD&#x2F;VgXuGrq768zboGKrGEEgN            p02b5lgrSFRhtdVWe&#x2F;jhhw2YFxpGuptsQVj9fKLgaxHY8EdDiKDYAj1SEApTTOpqRQY9fTY5dG4Z            xs4CyRpppE888YRpI03veiz6bvrMMuEWvb1DMIhOzahdGF06KBhIRKJt0jzd19FL+RmWheFtdJrm            hRnTCYuE8n2dnj17WrGEC3LCWz4&#x2F;zTHbXee1117bdtttaQORpTIZS02aNIk5EB3wjj322LrnZ8cQ            WwAe47Qc5bMfNcdjjz220UYb5bKz&#x2F;&#x2F;1M9pJzCACsWfC1CH7QvXt3iYWGTHPSSScFXa5trSMSS437            778&#x2F;6OwYtjYQtg4i3HzzzRZlKDNTyBLicxGGySZOLkHfYIMNLHEjFXFHjBgh988HlClmgPxAOhi&#x2F;            NBqdCgByDg3FKpuXVtrK6my1YY1GrsO9OL2G7dq1cy6TGtKkkeuYLy5Lz+g0jr3VmO2uU&#x2F;fzOkzm            oC66ShcsFJHWfBheFeSA888&#x2F;Px72EnW5V9CNJIQLp2IABmDc3CYZOKWqxJ8Qaz3aJrD1fvvtZx0T            YmGlb0TYIEI4r1p66aV5UtAjQhQSS5BUmr&#x2F;QpBwwIlxlKpYgt5X5kWNiKCCmBt2Uc2W9qHrkkUfM            dNATaHj00UenI5vDDpdCtwKV0U0&#x2F;Y&#x2F;7yl79k2KDbValX5TpmhPdgwKZ3+S8ejnL55ZfztmBIrgNM            l4+yGqyhNlPl63EdnelSx8ZptJZOzByYJ4gyl+Lp2OT&#x2F;hhdVhio1Cw+IWSSEl5jp8oZVnq1o6LAg            &#x2F;hEYiiUQVXaF5JdBJzyQ6E5eoguBSXL0sv3220vgaGKMgwcPpidN0E8&#x2F;&#x2F;XRZOcmFoBzRURi9SoEY            WtlEwR9lV8zBA2lGxZtevXoZI30Yc8yYMWJDVEVHUHYdvivwE8j+lqXQFQPhT8FQdh2+6OSf5ihB            qzmYJtd1nagKMMTZZ58teOaz8O2kOti8rUjDE4HNejBIXZPrJHjr6BhPHxuBM&#x2F;G&#x2F;Wtcpg5kYIpur            xhg7dmy4DpRDnVyHnjQR20899dTkOvEZ0BaEx+yGAgmYiVIVPOEuiI2ESAeZS0yilTkW0iICQV3X            SXeTSZOx2ZFjRAn0l1Mn1&#x2F;k3PMOaqeuEgRxxwdKRahh5aMbukjJYbLHFbAcGEGzsaDxF+xyEzBbX            oYntgALRb1UhrhtuuKHdljJEyW&#x2F;SKWymroM+YMAAmURZLCy++OL33HNPKJBgjDI5x5ngTLk5Vzjz            zDPNWQgJCQoCgBXIvOwjcZECWo3ofOKGG24Ii9V1HTD3XCRsWwa1w1&#x2F;&#x2F;g1yHNiZJGBdUUALKdlzG            NeDQjK72XbYWXSNNDmhLAuEKRoUiI37hhRd4GOYyNE&#x2F;SxLPNN9+chxX91YAcO+PBBx8c&#x2F;HIUsxIK            lGEtxt058zFy5MjIUqFbt24OQYQ4Z51wwgkWLiH81WIwLvLfeuut3r17c6aQn8DjzW7owCYxE+E6            q666agjnOk8&#x2F;&#x2F;TTh8VA2+WvZRMOGDQsXsVXV&#x2F;aiXY&#x2F;aaa64ZAp20Ix&#x2F;XKRtG2DM1NlxLIpRBR0Hn            RjRfZJFFom3Cz372M07&#x2F;tbqOzp599tnax59VSLcEyw8iWCS+eoJe&#x2F;oBp3e+cM2XdD120Bg7J6X5j            ayCPPuCAA3bZZRcHloBy+a1jVNeuXTfeeONlllkmPUmogqllsUJiCenxZxXSg4iCL9&#x2F;p6rpOUd0E            J18DxIBtyy23FO8RhbT4N5Nc9jeErtiwoslMMNtdR5jdaqutLCw5bOfOnXm0WefjgoQjNGIVcAYz            8HRh4JNPPnnjjTdsB1EFNi9yOIp1mT6853RjcSOCJgE+d+mll0YAaARux7eiR0E+RQVTdd9995EW            cVtOXvnL3ypPT6oMuriy7&#x2F;GVbodVj3qmrx0PrxxwYmXo1f&#x2F;649RP3p&#x2F;+uwsvtI71DjwpFHA4jxNW            FRq5Ts+ePcUhSooQJp6ejVwHndmxhX3YP77wJRiboHAdbFaaDTSU2XTTTdk&#x2F;TB0IqxZv8k4tzljG            s991QmNhJhAu7Kq&#x2F;gtQYNnUDMLaf&#x2F;OQnt99+Oy1BRJWy2AjQWYfdcxtmQKlFWLAFCLwXXXSRmKxH            K9g6LiqabjSPefDBLz&#x2F;5rHLBDdkP3VWNdJZf3Y&#x2F;5182jpk5+aYsttlhwwQWdcWLIECaqQiPXMfwY            Zrt27c4991z20byR68h17FPBn0ynnFynPC+a3HvvvWH&#x2F;RmAcKTbmTMXZ7jqG4RAo8pcxbty4iRMn            qsJAV9klCvoTTzwxZcoU44+2XCcyFQNwgBdj8Dgbr7feejFsBwqJ5Nprr73OOuusttpqdb2ETTHY            1xrB2jJzlqwe2UuyGXQyxYBTTznl09emVo4+q7JtzW8s7nB4ZcAFokjl2LOzH2FMdAHphAsqV95R            ufTW7Of1tj2ksk2pVen1j8EXXT70vA4dOkg2Y8iNwIZyKVoZi605jVTcWmuttagqK0jpsNW17777            durUCb+k&#x2F;rzzznvkkUdYzzDt+zG0bIR5Yd1119177715SczLyy+&#x2F;HPY3L4JuyhTrYo6nyXb3cmwA            DpuenFOUi0Q6Im736dNHGIy2yXUaofwMq+4JS3DadWYf9ZoJROORj1R27F09Ri&#x2F;b1uTXM4ZHJlSO            GFIZ9WjlyeeK1+TXKv&#x2F;4ovLlPytvTas89XzlyWez1xMTK78fU9nv+CThy517Dz92IFPM1HUSuHib            fq7AdtO9e&#x2F;fYhfmoRL6K2cTrPT50YWfHLB9F&#x2F;&#x2F;e7jjRln332Mcdgc43lUus6cWRgkfKnBJPr8ABL            TW6UEAJlnfF3UHPCdbSSS7779jtf3jyqWVCJl1hyysWVjz4R5SsPj6&#x2F;s2beyfa&#x2F;iN2BbeOFhxCYh            X3bpNbx3v7quY0T2UFuMowCwFX2MlOtcfPHFIk3YgRtJxdDNnxOcWI7ZVdtwkUauI+QrY2bAK664            QogiTeTeb7&#x2F;9Yk9Av+WWW6TtYeoqRO+i8oN28znkOjGv0h24&#x2F;&#x2F;77bb2xPbfJdWQDch0qhpwEksmP            Lma761DPXnZC&#x2F;&#x2F;6fX3NHNutpdJxm&#x2F;xMqY&#x2F;9Q+fs&#x2F;Mr&#x2F;xEnWOOSvLoKe+k72m5NeqQvZ6u&#x2F;L4xMpB            A5OoFlyHWR5++GH5jcUGTgP0SYOFsgXwc5FevXoJG5jt4w899JDaoNd1Hati+eWXx8xEdjHpMH7+            5ITF2ujmyCZoLmrNnhC9h8DZ7zrWhHP42By8e5NNNpHB2YDt3LzBCLnt4MGDndvRbW19+&#x2F;a176KD            40NsZA4+lhcJQXduKtRtgjGUXWfeeeddY401CCR2wIABkcfgmT59ulSJHHu&#x2F;cIgSzevCVNH2+H7N            XWeXI7KN6c9&#x2F;LZzmf&#x2F;LrQ+OzzavnSZXDT81fpzW94m3T65BBmWVKeU+4jhk1uhhabqdsmMxy1VVX            ORAYhcXdo0ePN99806hNGM3pH2zyAVOLLsycddZZyYzCCU6jKLuOQ+i1116b9&#x2F;PQzTffHL&#x2F;7ZCVL            d+68804C7VDHHXcc6+VWzB4Fjh49Gl13Tq8EhgIsk2k5dqxswVwUZpztrjPT+zq8+&#x2F;DDD4+UmZ+V            P2BaFxZE7ZdpvC27jjAbX+ErqnNYx&#x2F;LEuGnBOjP9Mk191&#x2F;HiAc+&#x2F;nKUyL0&#x2F;NAokZeuipzG+GXlO5            7LbKlbdnCXJcLx+eUSTL3r48pfLFl5UHnqjsekQSFa6z6KKLhtplCAZxB7nQpglfJdeZZZiRRh9r            NxdzasPilY6+R+X43e9+F&#x2F;dIdJa+EcEV2GjQoEGn5Dj++OODGTbaaCMWxMNSXbp0OfLII4PuuNGy            61hP3PHkk09m5RAb0EtI6Nev34xNugEauo7XXsdWxjxV6Ts0+7c5rjP2qUr3oyt9Ts9c6pPPs5j0            8adZGvTBnyqvv1W5+s7szOUU5oT&#x2F;179VLrklyQnXYQcxOBTbY489wrmrXMchlBljCJ07dw6zQF3X            sSSuueaaGPsJJ5yw+uqrM3LwJ+hFWqNHVpUyhi9ic2LlGUcffXTok0BObsJTTjrpJIlRCJmzaTIY            WEJQyq5TRuQ6n+R&#x2F;eAwp13HAFjD4R9BDSBlVrlMXzB3PsBoJqUJLrhMv4efN9&#x2F;SdbVj8ZtIrlT99            WjnvukqXXgWDpHjv4yqHnZo1F5Y++jjb3V54OftThZwh5TrWbmiV7t9Uuc4s301uhPLjz&#x2F;IJi+&#x2F;a            GTJVSjAj&#x2F;4ZnWKbKtsoJyhgyZIhDuI4LFZogrtqnRYtg4+m9e&#x2F;cWP1yttiCWIRuwHI2N6whvFgdm            2G233eR6BNooJYOWEaIeLVyGppWwb6s+++yzCbngggvsnrWbV0uuI18xxrvHZsM0bdLkIZdlkea1            NyuHntKMM2PuWTnopMqEF4vEaNKr6aj&#x2F;z669nr3gClunhRSdymMs69D2nHPOMaigz9R1HAWcQmJE            Z5xxhrBx2GGH5caojxNPPHHatGkky12ef&#x2F;55YRjRuhWuwkRlSJaT6&#x2F;BIiUcI0Sp9E3KO5Dq193Va            CcqlZ1gCRkEtwSnxscceY7joK2GmX+GTVDJThH1OVvfnCixKWVrmOtf&#x2F;vvqxw059sujy0pTKn&#x2F;+S            mWzs+MqZV2b&#x2F;qEKT6X+qXD+icszQSq+Tsx3tslsrU9&#x2F;NeAQnJpYbHTe0mZzHnin6axEzdR1LtPzT            TBZGMaOzA2XXIfxr+jKN6MeRnaGEDYhCo7dQpsh7jj322GOOOcaxSwTK65sxDxw4kONjSAh+xwSr            CoMANnz48IiosbzQMVjT6zR9BJMtttxyS1s+OmmOxKH5hx9+SPMxDz74j5deK9&#x2F;Ha&#x2F;ZyUN&#x2F;h8MrO            fbJXv3MrF99SuevBzBuemVx58bXKS69nMWbCpMpdY7KbQHv1rWz323Lzfx566tMj7jWiTPXmMASp            YW3Ucapw4HJsDAswEeMYddlEMpLa8yP3EmbE+6KD5gi7Gf6NN94YUQe&#x2F;xdO&#x2F;f39VQLhwSLirTqOJ            srxzTkWdrwKxt5zr1EYXR9D&#x2F;bvrhrTIanbAcQSMJbQSbvU6LBglf&#x2F;jM7TPU5LRt&#x2F;1Uhn+SUNGnDB            Ry+9um+PHnWPP41yHRq2&#x2F;MXhoNeC9cqf16mLlOvgZ710N9kJ69&#x2F;wM5R1wU8tiwMOOMC5SXp&#x2F;2WWX            &#x2F;SP&#x2F;VIAU5LbbbrPFoINs3yKjoiGtvfba2+e&#x2F;y1TGXnvtJX3RpAoPPPDAx&#x2F;kHMIxKFNlpp5203W67            7QipnSfWOfjgg602DYUoKU4oKYsySXrp0aOH+P&#x2F;XTz+rPPfHLHjs0y97Bi7eVI16pi8hZ+felf0H            VM686ovJr7304uQtttiCPubeCg7N5T0L579vIiKamE033ZTmINLELEo1ll12Wdt3WEBDqaSG9BcJ            gliGtI&#x2F;y7NDIdXRkpV1++eWE3H777Xw09nf8opQVi37TTTfJIx0DCXQVyzNdb7vt7rvvjk+3Zfb6            elzHSMr3dSR0kWq05r5OGausskrdXCfBKpzp53XkOpdcckltrsOHIqSZrSVKP1fQCOI8W7+df&#x2F;nS            kSQMapFw4vfy71aiy0iC&#x2F;laD3xKc5Z9mIlkwCIFliEZ1vxGRYHTp8zqNUJXrfE1fpmEjw3NWhF69            elGC7UCi+sQTT1gQIJWO&#x2F;bKR66BYjmPGjAn+hPHjx8dJnkATs9lmm1mdOtp7772d1dHLrsNGnTp1            GjFiRNG4CZxP22LDLqGR6zgNCWN6Mfdy7ZSDW7I&#x2F;bfH3dchZcskl11tvPUrKtOZr+hC+xSO+5hb6            5WqrrZaYV1555RtuuKHQsgk2kQMPPFAYjrZ1XUftsGHDhF78o0aN6tmzJ1V1Ku4KFSGnDCOKqO86            cuTIzp070wS&#x2F;hlYU4f8e1+EWjriswxYbbbRR3E2OqlpUuY5p0AqE7vi8jnBljmsloPCVBfJvJYMI            zBz4zd+11177ve99D5FB0zciwtuIIrCMsnCuw9U0NB+mvPwjKQJDCNxqq62YNdra7BZddFEjnXfe            eYX35Dq9e&#x2F;fmTJlajRHjDQSFcJOXch0Kh7YcxX4R7gXcxeIxUkm9slba6o5D6Bq&#x2F;RNueFS5V98k5            JOHsX36GZeJqP9buKsHKBtxkrkLgbHcd6YvAI1cHBf3Vqp5Q5TpSmYlN34rdeeedl8th&#x2F;Pfff3+V            95CpI4bGDJYOu2MWn2UqUmZECogurIzfBDiGxDdhy+jYsaPEK2QS+Oabb4bA1157jW5B15abkmYa            +GUSYoa4F2arZfr06aGhq70ABb+q8jXBJrXhhhvGkFdaaSVxBREPc9EhOnU2tPD0wmstpDgbgv1o            mWWWkf3Yu52eqKSt8W699dbGDksvvXSyZ13XMSPikyyQcMPfb7&#x2F;9wuYUSM+tyq4DFMhHvNwvfvEL            bUkIQV9HrtMIVa5T976OBVH7DKsKcr2W7+uwRbqvU4aktc4JqwF4oTwxDjiQvhFRVLcOJkbAEL1C            iHjJz4q6Ehrd10lIJywC7TJ2HIYq6prQyHVq7yYXdU2ocp0EPjQHn2GVIauwqbdv317qUBeLLbbY            &#x2F;PPPn5aUyI+Czg&#x2F;s+lOmTJk6daqrVCOEOIBYslW2AL4iwDjEiRaXXnqpdYl5qaWW2nPPPYV3DBaT            nQtDAslRYKYQ0gh6tJGFwB133NG+pi2IQDIVdGt90KBB4a&#x2F;mcsCAAaJC0M1uZBVlML3IFEJSXKxC            I9cRU3mDhgIkzTluC65jqSyyyCI0AWmc2ElyW13H1YhCW3HRai9Wy2x3HXLZgr1g9OjRLT9mqoLB            CwOw0EILyXVEb6CrE0G416qlH0kpI3Vqc7nmmmu4ICEyHoEhcp1GIIopQ1sSeFhRUYJcxy6gd9mA            07UDVPDLQBdffHHWN8ajjz465Tp9+vQRRykgMAwePBgFXUfJLFDbEYay6caNG8fzcmPMU&#x2F;aJlCYX            zfKGXMcOaI4xc5daH4Kqr&#x2F;BJ8DE7&#x2F;0sSWnadry9Ntu7tNTIvOWz6IEgrQV2LyUhEmvSbB2CQwdDI            dZ555hnbsE5F1O7du9tH4gtHrFxE1wbgmscee6wutF1jjTWs9VrhyXWAJhwitOrWrZsUwd4aHUVD            06+MEgrw+6BTySZlrWsoejX6Cp8BhnDnMoMiRFg64YQT0t5R6zqgUwdY3YHQssMOO9Ruzcl1gGta            UcEvQ6j143+P69i50+d12orWPMMqu04YAqqeYcUJE4ItIYhlcB2dhnC7TPmmUTBA2XXKSLlOwdci            LImq+zpFRVN3XOfhhx+O77tA&#x2F;L4O4YJZ1ed1mKiFTvlE3c&#x2F;rlF0HotNGqHKdoUOHFs3KDefEhmU+            TB44+EQqI4SaWqeGoCdYVUJ6Ck7JdcpCUGo3LAwik33N8GCdddaxRi1HY7ZhzTfffAYsGnfp0iU2            LIvymGOOQQl+wBCFFN6T61iFciDrPhic3V588UXxgxCbVJpFDYOhlSgvJ1NLAVh33XUjTa5yHczR            yt535JFHCg9hDUm9mBRVjZBGZMt79tlno6EMydlQrTR&#x2F;++23b&#x2F;mWICOITLzWqBkw&#x2F;mRUW5noHPwy            DbtHgkJduc7CCy&#x2F;M1uZMRjlp0iREVQksYknZZfBQjus45RZ1TTBhNi8DxmNXir8i5zoic0qk0jMs            E5BuCUpNOnfuLDAQwlJOWHw0TKAqGoJZJBk490MPPcT&#x2F;OKsFalKzuf3ud2WgXCf8kuugFC0bgEBd            YHNNGwdXkBUhRl8JEvC4l1PlOgmkMQtDhTW4jqClYaZZi8DjAG9LjVAhkXC6JtDY0&#x2F;ewGoEluY7J            is1XBAplzNQcfIZlDaUPXQjRfJYeOksPIsowPDNqSqLtGWecEQ9uyiCq9R8wLbtOGZwmfcBUqEu&#x2F;            YGo60+E83U3Wo&#x2F;y39neTWwMzTaA51pALpt9Ntl7Lf4hUi0auU4W6uU5r0CbXKW9YZcxZ17GGHEOy            BfW972222WbJdZ577jkH9VgQaS3iOeyww957771YUlzHksIQzYOZMwmSLbvO6quvPmHCBFPlKH71            1VejR&#x2F;PUEddxflarFydMxwq16OZV2Ive7afrr7++hiKczUv+FH211XVOOeUU3kmgCMp1YvckYdSo            UaEAFNbPg3REYrPFtzp06IA5lE8WSKOAnj17Est7NOFttT4Ue03eSRb4Uwpc13Uw0ySYwXYRAilj            k3IgCAVSkJ6zrqPvKlTRDYyL1Ho0iMy2p4KvOUJIQpXrJLBySpN1dMcdd9TyNELkOiRHjxB9tcl1            yuD0J510UsxHbZocwjloBGNVHFfMjq4TJBx8kRvlImcg3RIMOQnlNLljx44tb1h0q&#x2F;uDcAmswaW+            pg9d0EZ6wQTw9ttv6yY0MJ1Tp05FlEZY6JYXkzmmsmNK61KazCIOpSGkLmwupnmllVYiBOKHhkgI            10l352b6eZ0y2rdvf8stt5BMvhycwvmAKuPHj99www31YjdZZJFFCu5WIFyHBxMi1NV1Hfs4OuHm            1aGSm8YAE6S34iUnyAc6A04MV1xxRbgO8zJ18D&#x2F;99NNSw4gTPF66GSMaM2bMEvlPpXIRPUoZEeVw            Q4YMSXfznTboE&#x2F;wBZcF4zz33DIY5nuu05ss0fJlLCbxSkNoTVqPDeQL5S9b89yf6V3GdBK7MyinX            yVZfDk7AcLUBoBFa4zqF6Fy4JL0217EknLAiv2kEXl73bvJsx5x1HfuIWbdNgMD48ccfh+twcIcs            ROHROTnWtOvZZ58tZgT&#x2F;0UcfHa7D4XbaaacgliELCeuH68THu&#x2F;Cn+zr8slu3btOmTVMlJ7jpppti            SamyRUo7CkH1wINDeJXrmFR7fxJo78+smKc1mpAZ2UwQy+Bkch1bg7Y2js0339zYdUTzkSNHhvAE            jv7444+vvPLKoYyRhivoRWosBhMCLMae+CUxlh+K9SNZFDCC35UyLY+UT8fabgFJiGtEdJizrmNg            RpUQU1tFj1CB6NoaeoJcOB2Cyq6THn&#x2F;GCJkvEG&#x2F;BHNslRaNCUD3YGkwAZg3LrvPoo4+KlyGwbHEr            RAZjyjnWySefXDd7wx8NHdnuu+++pIDRhfCEqiHbUCJIB5Icp4qIQDwmfegCCr78J8OuvPJKHlYI            qoGMQjCOZ1iNwFznnXeejniJxXzIIYcEnevMwcefehIDnCZmIyzcsLVcT+bv4Aa77767vsJ1bMk9            evTYtDFs&#x2F;zfffHMx5hKYUjiMXm688UYJJsnCw2677SZOBE9Kk80f22288cYh8&#x2F;jjj3eSogAT88u6            rpPQ6HDuzOVMrndJCWeNoAsyQsfA6KgMgdl5U9AyhUcddRRVKUwlm2B0ZINOnxIkjfIxOgVHEJIZ            QeQI1zGin&#x2F;70p3ZSQghfo+l&#x2F;yoQc7oJNRyNGjLBjRu877LCD0MhomYqz3XXKuc5sgT0o3ddhjipE            p8WbViD4EyxBCVZ05IQlwOioYG1iTq5Dk86dO4e&#x2F;JmD4Kq5TdcIqf9SrLs466yx7GX4uMnToUC5C            YTuXtjHrZdexKpav9wumyXXshlZLLAAOce+994bwMrhR+UFEIFNxjrpOu3bttt566+2bPp0ehUbX            8tstt9zSagjVy67TCHIjw7711ltvv&#x2F;12azeWhSbOHYLzbbfd5iqKFMulhCrXiQcRYDLMNIHa&#x2F;u53            v9tjjz0o1rVr1549e0p3EMH6sy9gbuQ6NJe8b5f&#x2F;D&#x2F;I+++zjoBBhT6c6CiEXXXRRCJei9e3bV04T            ihmRFY&#x2F;BiJ577rkUL9M3IlzJpAwlr7&#x2F;+eh2FzcuuIzencFj1gAMOcPJFLLsODTfYYAMbnI6cLk9o            +jFNdCc4oVpDSSf+6L0Z5qjrxAnLhGWz0RZISNMJqzWuk9LkRicsm3e6m1yGWZQ9REdVz7DSjxbG            swIKmA9GTOsyPf5s5Drl+zoBPbpa5Q4QwbPmmmvabaMWQitIn9eJExZXDnpynUZIrhP8hdwcQSm7            TiM4W6SfK0gNq&#x2F;E1uA7jmgynnssuu+yMM844M&#x2F;+ia0L57ZgxY2LMDudcPoZR13W8lSeee+650ZBb            9OnTp3cOh5ognn766RKgmNFGrsOOlrXAA4MHD546dSpL1XUddM3LnxLkrNKdIUOG6Mt61XXISZCL            iIUpYATIKbuOjcx5MxROYBMOHelLI9cxro022kjmpyP5Mjlhc&#x2F;wWj7FX2TlB1d577x1C7HFGcdBB            B4XCCVSyd9eaqxm+HtdhPlG3fGSoC0pHntga15nlZ1gzRStdJwHF7EaomymqXGemaOQ6ostMP2A6            UxBe91OCrcL&#x2F;LteRu1jlFpkt3JiNPHjqug4dLCkew8TQr18&#x2F;pwYQDGxM4UYUkysEfcCAAdzRTDRy            HXQMw4YNI03A23fffeOmUdl1CJQ3iBkhM0EsjGSLHH5gRKGVYCkjJIS2yyyzjDBGclQFbBzy9LQB            laMOdxEwCD&#x2F;wwAPr&#x2F;mZPGQsssED&#x2F;&#x2F;v0JJGG&#x2F;&#x2F;fazmSLyto4dOxpIKMmwUSjDWOwG0Xsz&#x2F;O9ynZl+            cbjsOvIeCZN9TUPn0ro&#x2F;V1A3TW7kOvjLsNPJ5Y207DrmmMDaO4StOWGtV&#x2F;qf80aYaa7TCHVPWK2B            sXC4ovsy&#x2F;ne5jvTZmr7wwgst&#x2F;QRvHVmtGIcI6+&#x2F;oo4+2UqNKyEFBt7s7MoRWHMuxwlIL&#x2F;hNPPDGY            HUGtMMT9999&#x2F;t912W2ihhUKB5DpG4ZRkIeKBzTbbLGaxra4jrT7vvPNCCGbeYAiOWsOHD48P4YOs            S6DCcPDBBxtybdRpBF3vtdde5JMJxhVXKyo2prLrsO3aa68tK8oNMOzQQw+NQM5Eu+yyi&#x2F;iHyJiO            fqGtGDlx4kRLK1Plf2muEzCdgXQ3udEJqxHmyT9eE0IsyrohrZW5TpxHIow1ch0egKfqhFU30lSd            sHhbpuK&#x2F;&#x2F;jVT15H&#x2F;XXXVVelYV4jLEZSy66RcB51DlH+uIE5YzG57tSxz2XP4bnJd1wFbRtw2rcLo            HFGePHlyqNWaNPndd991PLb0oXv37tdeey0JTjQCQyyL1rgOPZdffvlNN92UkJ122unyyy8PTSBp            NW7cOOZjXJ0Ke+wbdHlJHIJkDEsttZRRk7PJJpssueSSMfwIALwN8y233LLPPvvEzV8nI3OQ99&#x2F;Q            dYSfhx56SMMRI0YMHDiwc+fO+e3cTZ19TPzIkSOlaIbPOCEnAWWllVaiBmax1s5LcwLfeecdyuid            DuKHCGeAhAvYTB10GoZwBuevOkV3Pfnkk&#x2F;NZGv3ggw++&#x2F;&#x2F;77IXCOu0483I6q1qM1rlP3hFVU5wjX            STwzRcp1ivYzA+tHrlO0r0GjJ+dlNHKdBPHj1Ho&#x2F;QxnPsGoFljHLn9cpf0rw35PrGHD79u0laOD4            kApRToVa4hJLLOE4TQK0xnUMzyxa+iEkIOB369aNS9lugO2iMGHChB122CE+DEX4scceG7Vvvvlm            zArh1qgUO+R07do1rd0y2BddQ11YoyGwDNGIhqEVFxEnXn75ZX1J9rlR8NgyFl98cb1w3B133JEO            hfQmVLkOgaIafhv0GWecYZMlcNKkSXX&#x2F;oZ1KIRzYJ1wBmIuFEenmfJf8z1YYwl3na&#x2F;pr1a&#x2F;VdYRK            SlNotsCA67rOlClT7BcFUz0Ys5AeJ6wypBpyZK6Jx5TIHoqKJtjv+MQ666wTcpyBTU+t6yRwuNNP            P12MCf66sIREe4GQHArwy6KiCbTdcMMNdVQIbQLXie9WF3xNMOVy4RAoKdGWFxZ1sxUMJV8utClj            truO+CwYMj1k3zVt+n4ulN9GGcpvUzldA5FqhPyAt6xmjarNmzZrmwpSkyKnK4FnmLxoC4JHUdGE            EP7ee+8Fw7Rp02KGiuoaECg1CWbI1ZmhPHj79ttvR9aJn0oUS1UBZR2lk1SCJoSnkeaNsgIKzUOg            q7apKlB+m8rpmpDXN6MkpKpaE2WYPa6zc5&#x2F;KX&#x2F;5qBHNf&#x2F;4devLxXza+3pldrXWfbQyr79M9+unHu            6&#x2F;&#x2F;Oq0f&#x2F;GT8YXftqrevMfc19Vb3mus7c1yy+5rrO3Ncsvua6ztzXLL7Cdd5+&#x2F;&#x2F;8D7Ozc&#x2F;52g0EUA            AAAASUVORK5CYII&#x3D;        &lt;&#x2F;pkg:binaryData&gt;    &lt;&#x2F;pkg:part&gt;    &lt;pkg:part pkg:name&#x3D;&quot;&#x2F;word&#x2F;theme&#x2F;theme1.xml&quot;              pkg:contentType&#x3D;&quot;application&#x2F;vnd.openxmlformats-officedocument.theme+xml&quot;&gt;        &lt;pkg:xmlData&gt;            &lt;a:theme name&#x3D;&quot;Office 主题&quot; xmlns:a&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;drawingml&#x2F;2006&#x2F;main&quot;&gt;                &lt;a:themeElements&gt;                    &lt;a:clrScheme name&#x3D;&quot;Office&quot;&gt;                        &lt;a:dk1&gt;                            &lt;a:sysClr val&#x3D;&quot;windowText&quot; lastClr&#x3D;&quot;000000&quot;&#x2F;&gt;                        &lt;&#x2F;a:dk1&gt;                        &lt;a:lt1&gt;                            &lt;a:sysClr val&#x3D;&quot;window&quot; lastClr&#x3D;&quot;FFFFFF&quot;&#x2F;&gt;                        &lt;&#x2F;a:lt1&gt;                        &lt;a:dk2&gt;                            &lt;a:srgbClr val&#x3D;&quot;44546A&quot;&#x2F;&gt;                        &lt;&#x2F;a:dk2&gt;                        &lt;a:lt2&gt;                            &lt;a:srgbClr val&#x3D;&quot;E7E6E6&quot;&#x2F;&gt;                        &lt;&#x2F;a:lt2&gt;                        &lt;a:accent1&gt;                            &lt;a:srgbClr val&#x3D;&quot;5B9BD5&quot;&#x2F;&gt;                        &lt;&#x2F;a:accent1&gt;                        &lt;a:accent2&gt;                            &lt;a:srgbClr val&#x3D;&quot;ED7D31&quot;&#x2F;&gt;                        &lt;&#x2F;a:accent2&gt;                        &lt;a:accent3&gt;                            &lt;a:srgbClr val&#x3D;&quot;A5A5A5&quot;&#x2F;&gt;                        &lt;&#x2F;a:accent3&gt;                        &lt;a:accent4&gt;                            &lt;a:srgbClr val&#x3D;&quot;FFC000&quot;&#x2F;&gt;                        &lt;&#x2F;a:accent4&gt;                        &lt;a:accent5&gt;                            &lt;a:srgbClr val&#x3D;&quot;4472C4&quot;&#x2F;&gt;                        &lt;&#x2F;a:accent5&gt;                        &lt;a:accent6&gt;                            &lt;a:srgbClr val&#x3D;&quot;70AD47&quot;&#x2F;&gt;                        &lt;&#x2F;a:accent6&gt;                        &lt;a:hlink&gt;                            &lt;a:srgbClr val&#x3D;&quot;0563C1&quot;&#x2F;&gt;                        &lt;&#x2F;a:hlink&gt;                        &lt;a:folHlink&gt;                            &lt;a:srgbClr val&#x3D;&quot;954F72&quot;&#x2F;&gt;                        &lt;&#x2F;a:folHlink&gt;                    &lt;&#x2F;a:clrScheme&gt;                    &lt;a:fontScheme name&#x3D;&quot;Office&quot;&gt;                        &lt;a:majorFont&gt;                            &lt;a:latin typeface&#x3D;&quot;Calibri Light&quot; panose&#x3D;&quot;020F0302020204030204&quot;&#x2F;&gt;                            &lt;a:ea typeface&#x3D;&quot;&quot;&#x2F;&gt;                            &lt;a:cs typeface&#x3D;&quot;&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Jpan&quot; typeface&#x3D;&quot;ＭＳ ゴシック&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Hang&quot; typeface&#x3D;&quot;맑은 고딕&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Hans&quot; typeface&#x3D;&quot;宋体&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Hant&quot; typeface&#x3D;&quot;新細明體&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Arab&quot; typeface&#x3D;&quot;Times New Roman&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Hebr&quot; typeface&#x3D;&quot;Times New Roman&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Thai&quot; typeface&#x3D;&quot;Angsana New&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Ethi&quot; typeface&#x3D;&quot;Nyala&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Beng&quot; typeface&#x3D;&quot;Vrinda&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Gujr&quot; typeface&#x3D;&quot;Shruti&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Khmr&quot; typeface&#x3D;&quot;MoolBoran&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Knda&quot; typeface&#x3D;&quot;Tunga&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Guru&quot; typeface&#x3D;&quot;Raavi&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Cans&quot; typeface&#x3D;&quot;Euphemia&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Cher&quot; typeface&#x3D;&quot;Plantagenet Cherokee&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Yiii&quot; typeface&#x3D;&quot;Microsoft Yi Baiti&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Tibt&quot; typeface&#x3D;&quot;Microsoft Himalaya&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Thaa&quot; typeface&#x3D;&quot;MV Boli&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Deva&quot; typeface&#x3D;&quot;Mangal&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Telu&quot; typeface&#x3D;&quot;Gautami&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Taml&quot; typeface&#x3D;&quot;Latha&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Syrc&quot; typeface&#x3D;&quot;Estrangelo Edessa&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Orya&quot; typeface&#x3D;&quot;Kalinga&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Mlym&quot; typeface&#x3D;&quot;Kartika&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Laoo&quot; typeface&#x3D;&quot;DokChampa&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Sinh&quot; typeface&#x3D;&quot;Iskoola Pota&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Mong&quot; typeface&#x3D;&quot;Mongolian Baiti&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Viet&quot; typeface&#x3D;&quot;Times New Roman&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Uigh&quot; typeface&#x3D;&quot;Microsoft Uighur&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Geor&quot; typeface&#x3D;&quot;Sylfaen&quot;&#x2F;&gt;                        &lt;&#x2F;a:majorFont&gt;                        &lt;a:minorFont&gt;                            &lt;a:latin typeface&#x3D;&quot;Calibri&quot; panose&#x3D;&quot;020F0502020204030204&quot;&#x2F;&gt;                            &lt;a:ea typeface&#x3D;&quot;&quot;&#x2F;&gt;                            &lt;a:cs typeface&#x3D;&quot;&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Jpan&quot; typeface&#x3D;&quot;ＭＳ 明朝&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Hang&quot; typeface&#x3D;&quot;맑은 고딕&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Hans&quot; typeface&#x3D;&quot;宋体&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Hant&quot; typeface&#x3D;&quot;新細明體&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Arab&quot; typeface&#x3D;&quot;Arial&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Hebr&quot; typeface&#x3D;&quot;Arial&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Thai&quot; typeface&#x3D;&quot;Cordia New&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Ethi&quot; typeface&#x3D;&quot;Nyala&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Beng&quot; typeface&#x3D;&quot;Vrinda&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Gujr&quot; typeface&#x3D;&quot;Shruti&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Khmr&quot; typeface&#x3D;&quot;DaunPenh&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Knda&quot; typeface&#x3D;&quot;Tunga&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Guru&quot; typeface&#x3D;&quot;Raavi&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Cans&quot; typeface&#x3D;&quot;Euphemia&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Cher&quot; typeface&#x3D;&quot;Plantagenet Cherokee&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Yiii&quot; typeface&#x3D;&quot;Microsoft Yi Baiti&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Tibt&quot; typeface&#x3D;&quot;Microsoft Himalaya&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Thaa&quot; typeface&#x3D;&quot;MV Boli&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Deva&quot; typeface&#x3D;&quot;Mangal&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Telu&quot; typeface&#x3D;&quot;Gautami&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Taml&quot; typeface&#x3D;&quot;Latha&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Syrc&quot; typeface&#x3D;&quot;Estrangelo Edessa&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Orya&quot; typeface&#x3D;&quot;Kalinga&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Mlym&quot; typeface&#x3D;&quot;Kartika&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Laoo&quot; typeface&#x3D;&quot;DokChampa&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Sinh&quot; typeface&#x3D;&quot;Iskoola Pota&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Mong&quot; typeface&#x3D;&quot;Mongolian Baiti&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Viet&quot; typeface&#x3D;&quot;Arial&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Uigh&quot; typeface&#x3D;&quot;Microsoft Uighur&quot;&#x2F;&gt;                            &lt;a:font script&#x3D;&quot;Geor&quot; typeface&#x3D;&quot;Sylfaen&quot;&#x2F;&gt;                        &lt;&#x2F;a:minorFont&gt;                    &lt;&#x2F;a:fontScheme&gt;                    &lt;a:fmtScheme name&#x3D;&quot;Office&quot;&gt;                        &lt;a:fillStyleLst&gt;                            &lt;a:solidFill&gt;                                &lt;a:schemeClr val&#x3D;&quot;phClr&quot;&#x2F;&gt;                            &lt;&#x2F;a:solidFill&gt;                            &lt;a:gradFill rotWithShape&#x3D;&quot;1&quot;&gt;                                &lt;a:gsLst&gt;                                    &lt;a:gs pos&#x3D;&quot;0&quot;&gt;                                        &lt;a:schemeClr val&#x3D;&quot;phClr&quot;&gt;                                            &lt;a:lumMod val&#x3D;&quot;110000&quot;&#x2F;&gt;                                            &lt;a:satMod val&#x3D;&quot;105000&quot;&#x2F;&gt;                                            &lt;a:tint val&#x3D;&quot;67000&quot;&#x2F;&gt;                                        &lt;&#x2F;a:schemeClr&gt;                                    &lt;&#x2F;a:gs&gt;                                    &lt;a:gs pos&#x3D;&quot;50000&quot;&gt;                                        &lt;a:schemeClr val&#x3D;&quot;phClr&quot;&gt;                                            &lt;a:lumMod val&#x3D;&quot;105000&quot;&#x2F;&gt;                                            &lt;a:satMod val&#x3D;&quot;103000&quot;&#x2F;&gt;                                            &lt;a:tint val&#x3D;&quot;73000&quot;&#x2F;&gt;                                        &lt;&#x2F;a:schemeClr&gt;                                    &lt;&#x2F;a:gs&gt;                                    &lt;a:gs pos&#x3D;&quot;100000&quot;&gt;                                        &lt;a:schemeClr val&#x3D;&quot;phClr&quot;&gt;                                            &lt;a:lumMod val&#x3D;&quot;105000&quot;&#x2F;&gt;                                            &lt;a:satMod val&#x3D;&quot;109000&quot;&#x2F;&gt;                                            &lt;a:tint val&#x3D;&quot;81000&quot;&#x2F;&gt;                                        &lt;&#x2F;a:schemeClr&gt;                                    &lt;&#x2F;a:gs&gt;                                &lt;&#x2F;a:gsLst&gt;                                &lt;a:lin ang&#x3D;&quot;5400000&quot; scaled&#x3D;&quot;0&quot;&#x2F;&gt;                            &lt;&#x2F;a:gradFill&gt;                            &lt;a:gradFill rotWithShape&#x3D;&quot;1&quot;&gt;                                &lt;a:gsLst&gt;                                    &lt;a:gs pos&#x3D;&quot;0&quot;&gt;                                        &lt;a:schemeClr val&#x3D;&quot;phClr&quot;&gt;                                            &lt;a:satMod val&#x3D;&quot;103000&quot;&#x2F;&gt;                                            &lt;a:lumMod val&#x3D;&quot;102000&quot;&#x2F;&gt;                                            &lt;a:tint val&#x3D;&quot;94000&quot;&#x2F;&gt;                                        &lt;&#x2F;a:schemeClr&gt;                                    &lt;&#x2F;a:gs&gt;                                    &lt;a:gs pos&#x3D;&quot;50000&quot;&gt;                                        &lt;a:schemeClr val&#x3D;&quot;phClr&quot;&gt;                                            &lt;a:satMod val&#x3D;&quot;110000&quot;&#x2F;&gt;                                            &lt;a:lumMod val&#x3D;&quot;100000&quot;&#x2F;&gt;                                            &lt;a:shade val&#x3D;&quot;100000&quot;&#x2F;&gt;                                        &lt;&#x2F;a:schemeClr&gt;                                    &lt;&#x2F;a:gs&gt;                                    &lt;a:gs pos&#x3D;&quot;100000&quot;&gt;                                        &lt;a:schemeClr val&#x3D;&quot;phClr&quot;&gt;                                            &lt;a:lumMod val&#x3D;&quot;99000&quot;&#x2F;&gt;                                            &lt;a:satMod val&#x3D;&quot;120000&quot;&#x2F;&gt;                                            &lt;a:shade val&#x3D;&quot;78000&quot;&#x2F;&gt;                                        &lt;&#x2F;a:schemeClr&gt;                                    &lt;&#x2F;a:gs&gt;                                &lt;&#x2F;a:gsLst&gt;                                &lt;a:lin ang&#x3D;&quot;5400000&quot; scaled&#x3D;&quot;0&quot;&#x2F;&gt;                            &lt;&#x2F;a:gradFill&gt;                        &lt;&#x2F;a:fillStyleLst&gt;                        &lt;a:lnStyleLst&gt;                            &lt;a:ln w&#x3D;&quot;6350&quot; cap&#x3D;&quot;flat&quot; cmpd&#x3D;&quot;sng&quot; algn&#x3D;&quot;ctr&quot;&gt;                                &lt;a:solidFill&gt;                                    &lt;a:schemeClr val&#x3D;&quot;phClr&quot;&#x2F;&gt;                                &lt;&#x2F;a:solidFill&gt;                                &lt;a:prstDash val&#x3D;&quot;solid&quot;&#x2F;&gt;                                &lt;a:miter lim&#x3D;&quot;800000&quot;&#x2F;&gt;                            &lt;&#x2F;a:ln&gt;                            &lt;a:ln w&#x3D;&quot;12700&quot; cap&#x3D;&quot;flat&quot; cmpd&#x3D;&quot;sng&quot; algn&#x3D;&quot;ctr&quot;&gt;                                &lt;a:solidFill&gt;                                    &lt;a:schemeClr val&#x3D;&quot;phClr&quot;&#x2F;&gt;                                &lt;&#x2F;a:solidFill&gt;                                &lt;a:prstDash val&#x3D;&quot;solid&quot;&#x2F;&gt;                                &lt;a:miter lim&#x3D;&quot;800000&quot;&#x2F;&gt;                            &lt;&#x2F;a:ln&gt;                            &lt;a:ln w&#x3D;&quot;19050&quot; cap&#x3D;&quot;flat&quot; cmpd&#x3D;&quot;sng&quot; algn&#x3D;&quot;ctr&quot;&gt;                                &lt;a:solidFill&gt;                                    &lt;a:schemeClr val&#x3D;&quot;phClr&quot;&#x2F;&gt;                                &lt;&#x2F;a:solidFill&gt;                                &lt;a:prstDash val&#x3D;&quot;solid&quot;&#x2F;&gt;                                &lt;a:miter lim&#x3D;&quot;800000&quot;&#x2F;&gt;                            &lt;&#x2F;a:ln&gt;                        &lt;&#x2F;a:lnStyleLst&gt;                        &lt;a:effectStyleLst&gt;                            &lt;a:effectStyle&gt;                                &lt;a:effectLst&#x2F;&gt;                            &lt;&#x2F;a:effectStyle&gt;                            &lt;a:effectStyle&gt;                                &lt;a:effectLst&#x2F;&gt;                            &lt;&#x2F;a:effectStyle&gt;                            &lt;a:effectStyle&gt;                                &lt;a:effectLst&gt;                                    &lt;a:outerShdw blurRad&#x3D;&quot;57150&quot; dist&#x3D;&quot;19050&quot; dir&#x3D;&quot;5400000&quot; algn&#x3D;&quot;ctr&quot; rotWithShape&#x3D;&quot;0&quot;&gt;                                        &lt;a:srgbClr val&#x3D;&quot;000000&quot;&gt;                                            &lt;a:alpha val&#x3D;&quot;63000&quot;&#x2F;&gt;                                        &lt;&#x2F;a:srgbClr&gt;                                    &lt;&#x2F;a:outerShdw&gt;                                &lt;&#x2F;a:effectLst&gt;                            &lt;&#x2F;a:effectStyle&gt;                        &lt;&#x2F;a:effectStyleLst&gt;                        &lt;a:bgFillStyleLst&gt;                            &lt;a:solidFill&gt;                                &lt;a:schemeClr val&#x3D;&quot;phClr&quot;&#x2F;&gt;                            &lt;&#x2F;a:solidFill&gt;                            &lt;a:solidFill&gt;                                &lt;a:schemeClr val&#x3D;&quot;phClr&quot;&gt;                                    &lt;a:tint val&#x3D;&quot;95000&quot;&#x2F;&gt;                                    &lt;a:satMod val&#x3D;&quot;170000&quot;&#x2F;&gt;                                &lt;&#x2F;a:schemeClr&gt;                            &lt;&#x2F;a:solidFill&gt;                            &lt;a:gradFill rotWithShape&#x3D;&quot;1&quot;&gt;                                &lt;a:gsLst&gt;                                    &lt;a:gs pos&#x3D;&quot;0&quot;&gt;                                        &lt;a:schemeClr val&#x3D;&quot;phClr&quot;&gt;                                            &lt;a:tint val&#x3D;&quot;93000&quot;&#x2F;&gt;                                            &lt;a:satMod val&#x3D;&quot;150000&quot;&#x2F;&gt;                                            &lt;a:shade val&#x3D;&quot;98000&quot;&#x2F;&gt;                                            &lt;a:lumMod val&#x3D;&quot;102000&quot;&#x2F;&gt;                                        &lt;&#x2F;a:schemeClr&gt;                                    &lt;&#x2F;a:gs&gt;                                    &lt;a:gs pos&#x3D;&quot;50000&quot;&gt;                                        &lt;a:schemeClr val&#x3D;&quot;phClr&quot;&gt;                                            &lt;a:tint val&#x3D;&quot;98000&quot;&#x2F;&gt;                                            &lt;a:satMod val&#x3D;&quot;130000&quot;&#x2F;&gt;                                            &lt;a:shade val&#x3D;&quot;90000&quot;&#x2F;&gt;                                            &lt;a:lumMod val&#x3D;&quot;103000&quot;&#x2F;&gt;                                        &lt;&#x2F;a:schemeClr&gt;                                    &lt;&#x2F;a:gs&gt;                                    &lt;a:gs pos&#x3D;&quot;100000&quot;&gt;                                        &lt;a:schemeClr val&#x3D;&quot;phClr&quot;&gt;                                            &lt;a:shade val&#x3D;&quot;63000&quot;&#x2F;&gt;                                            &lt;a:satMod val&#x3D;&quot;120000&quot;&#x2F;&gt;                                        &lt;&#x2F;a:schemeClr&gt;                                    &lt;&#x2F;a:gs&gt;                                &lt;&#x2F;a:gsLst&gt;                                &lt;a:lin ang&#x3D;&quot;5400000&quot; scaled&#x3D;&quot;0&quot;&#x2F;&gt;                            &lt;&#x2F;a:gradFill&gt;                        &lt;&#x2F;a:bgFillStyleLst&gt;                    &lt;&#x2F;a:fmtScheme&gt;                &lt;&#x2F;a:themeElements&gt;                &lt;a:objectDefaults&#x2F;&gt;                &lt;a:extraClrSchemeLst&#x2F;&gt;                &lt;a:extLst&gt;                    &lt;a:ext uri&#x3D;&quot;&#123;05A4C25C-085E-4340-85A3-A5531E510DB2&#125;&quot;&gt;                        &lt;thm15:themeFamily name&#x3D;&quot;Office Theme&quot; id&#x3D;&quot;&#123;62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F&#125;&quot;                                           vid&#x3D;&quot;&#123;4A3C46E8-61CC-4603-A589-7422A47A8E4A&#125;&quot;                                           xmlns:thm15&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;thememl&#x2F;2012&#x2F;main&quot;&#x2F;&gt;                    &lt;&#x2F;a:ext&gt;                &lt;&#x2F;a:extLst&gt;            &lt;&#x2F;a:theme&gt;        &lt;&#x2F;pkg:xmlData&gt;    &lt;&#x2F;pkg:part&gt;    &lt;pkg:part pkg:name&#x3D;&quot;&#x2F;word&#x2F;media&#x2F;image1.png&quot; pkg:contentType&#x3D;&quot;image&#x2F;png&quot; pkg:compression&#x3D;&quot;store&quot;&gt;\t\t# 取值图片的base64位码。        &lt;pkg:binaryData&gt;$&#123;deptNameZhang&#125;&lt;&#x2F;pkg:binaryData&gt;    &lt;&#x2F;pkg:part&gt;    &lt;pkg:part pkg:name&#x3D;&quot;&#x2F;word&#x2F;settings.xml&quot;              pkg:contentType&#x3D;&quot;application&#x2F;vnd.openxmlformats-officedocument.wordprocessingml.settings+xml&quot;&gt;        &lt;pkg:xmlData&gt;            &lt;w:settings mc:Ignorable&#x3D;&quot;w14 w15&quot; xmlns:mc&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;markup-compatibility&#x2F;2006&quot;                        xmlns:o&#x3D;&quot;urn:schemas-microsoft-com:office:office&quot;                        xmlns:r&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;relationships&quot;                        xmlns:m&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;math&quot;                        xmlns:v&#x3D;&quot;urn:schemas-microsoft-com:vml&quot; xmlns:w10&#x3D;&quot;urn:schemas-microsoft-com:office:word&quot;                        xmlns:w&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;wordprocessingml&#x2F;2006&#x2F;main&quot;                        xmlns:w14&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordml&quot;                        xmlns:w15&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2012&#x2F;wordml&quot;                        xmlns:sl&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;schemaLibrary&#x2F;2006&#x2F;main&quot;&gt;                &lt;w:zoom w:percent&#x3D;&quot;100&quot;&#x2F;&gt;                &lt;w:bordersDoNotSurroundHeader&#x2F;&gt;                &lt;w:bordersDoNotSurroundFooter&#x2F;&gt;                &lt;w:defaultTabStop w:val&#x3D;&quot;420&quot;&#x2F;&gt;                &lt;w:drawingGridVerticalSpacing w:val&#x3D;&quot;156&quot;&#x2F;&gt;                &lt;w:displayHorizontalDrawingGridEvery w:val&#x3D;&quot;0&quot;&#x2F;&gt;                &lt;w:displayVerticalDrawingGridEvery w:val&#x3D;&quot;2&quot;&#x2F;&gt;                &lt;w:characterSpacingControl w:val&#x3D;&quot;compressPunctuation&quot;&#x2F;&gt;                &lt;w:hdrShapeDefaults&gt;                    &lt;o:shapedefaults v:ext&#x3D;&quot;edit&quot; spidmax&#x3D;&quot;2049&quot;&#x2F;&gt;                &lt;&#x2F;w:hdrShapeDefaults&gt;                &lt;w:footnotePr&gt;                    &lt;w:footnote w:id&#x3D;&quot;-1&quot;&#x2F;&gt;                    &lt;w:footnote w:id&#x3D;&quot;0&quot;&#x2F;&gt;                &lt;&#x2F;w:footnotePr&gt;                &lt;w:endnotePr&gt;                    &lt;w:endnote w:id&#x3D;&quot;-1&quot;&#x2F;&gt;                    &lt;w:endnote w:id&#x3D;&quot;0&quot;&#x2F;&gt;                &lt;&#x2F;w:endnotePr&gt;                &lt;w:compat&gt;                    &lt;w:spaceForUL&#x2F;&gt;                    &lt;w:balanceSingleByteDoubleByteWidth&#x2F;&gt;                    &lt;w:doNotLeaveBackslashAlone&#x2F;&gt;                    &lt;w:ulTrailSpace&#x2F;&gt;                    &lt;w:doNotExpandShiftReturn&#x2F;&gt;                    &lt;w:adjustLineHeightInTable&#x2F;&gt;                    &lt;w:useFELayout&#x2F;&gt;                    &lt;w:compatSetting w:name&#x3D;&quot;compatibilityMode&quot; w:uri&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&quot;                                     w:val&#x3D;&quot;15&quot;&#x2F;&gt;                    &lt;w:compatSetting w:name&#x3D;&quot;overrideTableStyleFontSizeAndJustification&quot;                                     w:uri&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&quot; w:val&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:compatSetting w:name&#x3D;&quot;enableOpenTypeFeatures&quot; w:uri&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&quot;                                     w:val&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:compatSetting w:name&#x3D;&quot;doNotFlipMirrorIndents&quot; w:uri&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&quot;                                     w:val&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:compatSetting w:name&#x3D;&quot;differentiateMultirowTableHeaders&quot;                                     w:uri&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&quot; w:val&#x3D;&quot;1&quot;&#x2F;&gt;                &lt;&#x2F;w:compat&gt;                &lt;w:rsids&gt;                    &lt;w:rsidRoot w:val&#x3D;&quot;00F17F42&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;000C4588&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;001F7785&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;00216D28&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;00323133&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;003D51A6&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;00544882&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;00682915&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;008D4E44&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;008E63A4&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;009300C4&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;00956EAA&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;00AE3DF6&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;00BD58CB&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;00CE11F9&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;00E03B56&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;00ED0E87&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;00ED0EF3&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;00F17F42&quot;&#x2F;&gt;                &lt;&#x2F;w:rsids&gt;                &lt;m:mathPr&gt;                    &lt;m:mathFont m:val&#x3D;&quot;Cambria Math&quot;&#x2F;&gt;                    &lt;m:brkBin m:val&#x3D;&quot;before&quot;&#x2F;&gt;                    &lt;m:brkBinSub m:val&#x3D;&quot;--&quot;&#x2F;&gt;                    &lt;m:smallFrac m:val&#x3D;&quot;0&quot;&#x2F;&gt;                    &lt;m:dispDef&#x2F;&gt;                    &lt;m:lMargin m:val&#x3D;&quot;0&quot;&#x2F;&gt;                    &lt;m:rMargin m:val&#x3D;&quot;0&quot;&#x2F;&gt;                    &lt;m:defJc m:val&#x3D;&quot;centerGroup&quot;&#x2F;&gt;                    &lt;m:wrapIndent m:val&#x3D;&quot;1440&quot;&#x2F;&gt;                    &lt;m:intLim m:val&#x3D;&quot;subSup&quot;&#x2F;&gt;                    &lt;m:naryLim m:val&#x3D;&quot;undOvr&quot;&#x2F;&gt;                &lt;&#x2F;m:mathPr&gt;                &lt;w:themeFontLang w:val&#x3D;&quot;en-US&quot; w:eastAsia&#x3D;&quot;zh-CN&quot;&#x2F;&gt;                &lt;w:clrSchemeMapping w:bg1&#x3D;&quot;light1&quot; w:t1&#x3D;&quot;dark1&quot; w:bg2&#x3D;&quot;light2&quot; w:t2&#x3D;&quot;dark2&quot; w:accent1&#x3D;&quot;accent1&quot;                                    w:accent2&#x3D;&quot;accent2&quot; w:accent3&#x3D;&quot;accent3&quot; w:accent4&#x3D;&quot;accent4&quot; w:accent5&#x3D;&quot;accent5&quot;                                    w:accent6&#x3D;&quot;accent6&quot; w:hyperlink&#x3D;&quot;hyperlink&quot;                                    w:followedHyperlink&#x3D;&quot;followedHyperlink&quot;&#x2F;&gt;                &lt;w:shapeDefaults&gt;                    &lt;o:shapedefaults v:ext&#x3D;&quot;edit&quot; spidmax&#x3D;&quot;2049&quot;&#x2F;&gt;                    &lt;o:shapelayout v:ext&#x3D;&quot;edit&quot;&gt;                        &lt;o:idmap v:ext&#x3D;&quot;edit&quot; data&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;&#x2F;o:shapelayout&gt;                &lt;&#x2F;w:shapeDefaults&gt;                &lt;w:decimalSymbol w:val&#x3D;&quot;.&quot;&#x2F;&gt;                &lt;w:listSeparator w:val&#x3D;&quot;,&quot;&#x2F;&gt;                &lt;w15:chartTrackingRefBased&#x2F;&gt;                &lt;w15:docId w15:val&#x3D;&quot;&#123;924A1B1D-0AED-4CD0-A5AF-59793AC176A0&#125;&quot;&#x2F;&gt;            &lt;&#x2F;w:settings&gt;        &lt;&#x2F;pkg:xmlData&gt;    &lt;&#x2F;pkg:part&gt;    &lt;pkg:part pkg:name&#x3D;&quot;&#x2F;word&#x2F;fontTable.xml&quot;              pkg:contentType&#x3D;&quot;application&#x2F;vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml&quot;&gt;        &lt;pkg:xmlData&gt;            &lt;w:fonts mc:Ignorable&#x3D;&quot;w14 w15&quot; xmlns:mc&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;markup-compatibility&#x2F;2006&quot;                     xmlns:r&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;relationships&quot;                     xmlns:w&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;wordprocessingml&#x2F;2006&#x2F;main&quot;                     xmlns:w14&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordml&quot;                     xmlns:w15&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2012&#x2F;wordml&quot;&gt;                &lt;w:font w:name&#x3D;&quot;Calibri&quot;&gt;                    &lt;w:panose1 w:val&#x3D;&quot;020F0502020204030204&quot;&#x2F;&gt;                    &lt;w:charset w:val&#x3D;&quot;00&quot;&#x2F;&gt;                    &lt;w:family w:val&#x3D;&quot;swiss&quot;&#x2F;&gt;                    &lt;w:pitch w:val&#x3D;&quot;variable&quot;&#x2F;&gt;                    &lt;w:sig w:usb0&#x3D;&quot;E0002AFF&quot; w:usb1&#x3D;&quot;C000247B&quot; w:usb2&#x3D;&quot;00000009&quot; w:usb3&#x3D;&quot;00000000&quot; w:csb0&#x3D;&quot;000001FF&quot;                           w:csb1&#x3D;&quot;00000000&quot;&#x2F;&gt;                &lt;&#x2F;w:font&gt;                &lt;w:font w:name&#x3D;&quot;宋体&quot;&gt;                    &lt;w:altName w:val&#x3D;&quot;SimSun&quot;&#x2F;&gt;                    &lt;w:panose1 w:val&#x3D;&quot;02010600030101010101&quot;&#x2F;&gt;                    &lt;w:charset w:val&#x3D;&quot;86&quot;&#x2F;&gt;                    &lt;w:family w:val&#x3D;&quot;auto&quot;&#x2F;&gt;                    &lt;w:pitch w:val&#x3D;&quot;variable&quot;&#x2F;&gt;                    &lt;w:sig w:usb0&#x3D;&quot;00000003&quot; w:usb1&#x3D;&quot;288F0000&quot; w:usb2&#x3D;&quot;00000016&quot; w:usb3&#x3D;&quot;00000000&quot; w:csb0&#x3D;&quot;00040001&quot;                           w:csb1&#x3D;&quot;00000000&quot;&#x2F;&gt;                &lt;&#x2F;w:font&gt;                &lt;w:font w:name&#x3D;&quot;Times New Roman&quot;&gt;                    &lt;w:panose1 w:val&#x3D;&quot;02020603050405020304&quot;&#x2F;&gt;                    &lt;w:charset w:val&#x3D;&quot;00&quot;&#x2F;&gt;                    &lt;w:family w:val&#x3D;&quot;roman&quot;&#x2F;&gt;                    &lt;w:pitch w:val&#x3D;&quot;variable&quot;&#x2F;&gt;                    &lt;w:sig w:usb0&#x3D;&quot;E0002EFF&quot; w:usb1&#x3D;&quot;C000785B&quot; w:usb2&#x3D;&quot;00000009&quot; w:usb3&#x3D;&quot;00000000&quot; w:csb0&#x3D;&quot;000001FF&quot;                           w:csb1&#x3D;&quot;00000000&quot;&#x2F;&gt;                &lt;&#x2F;w:font&gt;                &lt;w:font w:name&#x3D;&quot;黑体&quot;&gt;                    &lt;w:altName w:val&#x3D;&quot;SimHei&quot;&#x2F;&gt;                    &lt;w:panose1 w:val&#x3D;&quot;02010609060101010101&quot;&#x2F;&gt;                    &lt;w:charset w:val&#x3D;&quot;86&quot;&#x2F;&gt;                    &lt;w:family w:val&#x3D;&quot;modern&quot;&#x2F;&gt;                    &lt;w:pitch w:val&#x3D;&quot;fixed&quot;&#x2F;&gt;                    &lt;w:sig w:usb0&#x3D;&quot;800002BF&quot; w:usb1&#x3D;&quot;38CF7CFA&quot; w:usb2&#x3D;&quot;00000016&quot; w:usb3&#x3D;&quot;00000000&quot; w:csb0&#x3D;&quot;00040001&quot;                           w:csb1&#x3D;&quot;00000000&quot;&#x2F;&gt;                &lt;&#x2F;w:font&gt;                &lt;w:font w:name&#x3D;&quot;微软雅黑&quot;&gt;                    &lt;w:panose1 w:val&#x3D;&quot;020B0503020204020204&quot;&#x2F;&gt;                    &lt;w:charset w:val&#x3D;&quot;86&quot;&#x2F;&gt;                    &lt;w:family w:val&#x3D;&quot;swiss&quot;&#x2F;&gt;                    &lt;w:pitch w:val&#x3D;&quot;variable&quot;&#x2F;&gt;                    &lt;w:sig w:usb0&#x3D;&quot;80000287&quot; w:usb1&#x3D;&quot;28CF3C50&quot; w:usb2&#x3D;&quot;00000016&quot; w:usb3&#x3D;&quot;00000000&quot; w:csb0&#x3D;&quot;0004001F&quot;                           w:csb1&#x3D;&quot;00000000&quot;&#x2F;&gt;                &lt;&#x2F;w:font&gt;                &lt;w:font w:name&#x3D;&quot;Calibri Light&quot;&gt;                    &lt;w:panose1 w:val&#x3D;&quot;020F0302020204030204&quot;&#x2F;&gt;                    &lt;w:charset w:val&#x3D;&quot;00&quot;&#x2F;&gt;                    &lt;w:family w:val&#x3D;&quot;swiss&quot;&#x2F;&gt;                    &lt;w:pitch w:val&#x3D;&quot;variable&quot;&#x2F;&gt;                    &lt;w:sig w:usb0&#x3D;&quot;E0002AFF&quot; w:usb1&#x3D;&quot;C000247B&quot; w:usb2&#x3D;&quot;00000009&quot; w:usb3&#x3D;&quot;00000000&quot; w:csb0&#x3D;&quot;000001FF&quot;                           w:csb1&#x3D;&quot;00000000&quot;&#x2F;&gt;                &lt;&#x2F;w:font&gt;            &lt;&#x2F;w:fonts&gt;        &lt;&#x2F;pkg:xmlData&gt;    &lt;&#x2F;pkg:part&gt;    &lt;pkg:part pkg:name&#x3D;&quot;&#x2F;word&#x2F;webSettings.xml&quot;              pkg:contentType&#x3D;&quot;application&#x2F;vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml&quot;&gt;        &lt;pkg:xmlData&gt;            &lt;w:webSettings mc:Ignorable&#x3D;&quot;w14 w15&quot; xmlns:mc&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;markup-compatibility&#x2F;2006&quot;                           xmlns:r&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;relationships&quot;                           xmlns:w&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;wordprocessingml&#x2F;2006&#x2F;main&quot;                           xmlns:w14&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordml&quot;                           xmlns:w15&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2012&#x2F;wordml&quot;&gt;                &lt;w:optimizeForBrowser&#x2F;&gt;                &lt;w:allowPNG&#x2F;&gt;            &lt;&#x2F;w:webSettings&gt;        &lt;&#x2F;pkg:xmlData&gt;    &lt;&#x2F;pkg:part&gt;    &lt;pkg:part pkg:name&#x3D;&quot;&#x2F;docProps&#x2F;app.xml&quot;              pkg:contentType&#x3D;&quot;application&#x2F;vnd.openxmlformats-officedocument.extended-properties+xml&quot; pkg:padding&#x3D;&quot;256&quot;&gt;        &lt;pkg:xmlData&gt;            &lt;Properties xmlns&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;extended-properties&quot;                        xmlns:vt&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;docPropsVTypes&quot;&gt;                &lt;Template&gt;Normal.dotm&lt;&#x2F;Template&gt;                &lt;TotalTime&gt;1&lt;&#x2F;TotalTime&gt;                &lt;Pages&gt;1&lt;&#x2F;Pages&gt;                &lt;Words&gt;31&lt;&#x2F;Words&gt;                &lt;Characters&gt;180&lt;&#x2F;Characters&gt;                &lt;Application&gt;Microsoft Office Word&lt;&#x2F;Application&gt;                &lt;DocSecurity&gt;0&lt;&#x2F;DocSecurity&gt;                &lt;Lines&gt;1&lt;&#x2F;Lines&gt;                &lt;Paragraphs&gt;1&lt;&#x2F;Paragraphs&gt;                &lt;ScaleCrop&gt;false&lt;&#x2F;ScaleCrop&gt;                &lt;Company&#x2F;&gt;                &lt;LinksUpToDate&gt;false&lt;&#x2F;LinksUpToDate&gt;                &lt;CharactersWithSpaces&gt;210&lt;&#x2F;CharactersWithSpaces&gt;                &lt;SharedDoc&gt;false&lt;&#x2F;SharedDoc&gt;                &lt;HyperlinksChanged&gt;false&lt;&#x2F;HyperlinksChanged&gt;                &lt;AppVersion&gt;15.0000&lt;&#x2F;AppVersion&gt;            &lt;&#x2F;Properties&gt;        &lt;&#x2F;pkg:xmlData&gt;    &lt;&#x2F;pkg:part&gt;    &lt;pkg:part pkg:name&#x3D;&quot;&#x2F;word&#x2F;styles.xml&quot;              pkg:contentType&#x3D;&quot;application&#x2F;vnd.openxmlformats-officedocument.wordprocessingml.styles+xml&quot;&gt;        &lt;pkg:xmlData&gt;            &lt;w:styles mc:Ignorable&#x3D;&quot;w14 w15&quot; xmlns:mc&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;markup-compatibility&#x2F;2006&quot;                      xmlns:r&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;relationships&quot;                      xmlns:w&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;wordprocessingml&#x2F;2006&#x2F;main&quot;                      xmlns:w14&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2010&#x2F;wordml&quot;                      xmlns:w15&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;office&#x2F;word&#x2F;2012&#x2F;wordml&quot;&gt;                &lt;w:docDefaults&gt;                    &lt;w:rPrDefault&gt;                        &lt;w:rPr&gt;                            &lt;w:rFonts w:asciiTheme&#x3D;&quot;minorHAnsi&quot; w:eastAsiaTheme&#x3D;&quot;minorEastAsia&quot;                                      w:hAnsiTheme&#x3D;&quot;minorHAnsi&quot; w:cstheme&#x3D;&quot;minorBidi&quot;&#x2F;&gt;                            &lt;w:kern w:val&#x3D;&quot;2&quot;&#x2F;&gt;                            &lt;w:sz w:val&#x3D;&quot;21&quot;&#x2F;&gt;                            &lt;w:szCs w:val&#x3D;&quot;22&quot;&#x2F;&gt;                            &lt;w:lang w:val&#x3D;&quot;en-US&quot; w:eastAsia&#x3D;&quot;zh-CN&quot; w:bidi&#x3D;&quot;ar-SA&quot;&#x2F;&gt;                        &lt;&#x2F;w:rPr&gt;                    &lt;&#x2F;w:rPrDefault&gt;                    &lt;w:pPrDefault&#x2F;&gt;                &lt;&#x2F;w:docDefaults&gt;                &lt;w:latentStyles w:defLockedState&#x3D;&quot;0&quot; w:defUIPriority&#x3D;&quot;99&quot; w:defSemiHidden&#x3D;&quot;0&quot; w:defUnhideWhenUsed&#x3D;&quot;0&quot;                                w:defQFormat&#x3D;&quot;0&quot; w:count&#x3D;&quot;371&quot;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Normal&quot; w:uiPriority&#x3D;&quot;0&quot; w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;heading 1&quot; w:uiPriority&#x3D;&quot;9&quot; w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;heading 2&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;9&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;                                    w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;heading 3&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;9&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;                                    w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;heading 4&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;9&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;                                    w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;heading 5&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;9&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;                                    w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;heading 6&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;9&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;                                    w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;heading 7&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;9&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;                                    w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;heading 8&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;9&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;                                    w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;heading 9&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;9&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;                                    w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;index 1&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;index 2&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;index 3&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;index 4&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;index 5&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;index 6&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;index 7&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;index 8&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;index 9&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;toc 1&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;39&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;toc 2&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;39&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;toc 3&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;39&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;toc 4&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;39&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;toc 5&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;39&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;toc 6&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;39&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;toc 7&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;39&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;toc 8&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;39&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;toc 9&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;39&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Normal Indent&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;footnote text&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;annotation text&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;header&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;footer&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;index heading&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;caption&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;35&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;                                    w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;table of figures&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;envelope address&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;envelope return&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;footnote reference&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;annotation reference&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;line number&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;page number&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;endnote reference&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;endnote text&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;table of authorities&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;macro&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;toa heading&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Bullet&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Number&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List 2&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List 3&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List 4&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List 5&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Bullet 2&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Bullet 3&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Bullet 4&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Bullet 5&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Number 2&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Number 3&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Number 4&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Number 5&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Title&quot; w:uiPriority&#x3D;&quot;10&quot; w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Closing&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Signature&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Default Paragraph Font&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;1&quot;                                    w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Body Text&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Body Text Indent&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Continue&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Continue 2&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Continue 3&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Continue 4&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Continue 5&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Message Header&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Subtitle&quot; w:uiPriority&#x3D;&quot;11&quot; w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Salutation&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Date&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Body Text First Indent&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Body Text First Indent 2&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Note Heading&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Body Text 2&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Body Text 3&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Body Text Indent 2&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Body Text Indent 3&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Block Text&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Hyperlink&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;FollowedHyperlink&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Strong&quot; w:uiPriority&#x3D;&quot;22&quot; w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Emphasis&quot; w:uiPriority&#x3D;&quot;20&quot; w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Document Map&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Plain Text&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;E-mail Signature&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;HTML Top of Form&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;HTML Bottom of Form&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Normal (Web)&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;HTML Acronym&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;HTML Address&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;HTML Cite&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;HTML Code&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;HTML Definition&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;HTML Keyboard&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;HTML Preformatted&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;HTML Sample&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;HTML Typewriter&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;HTML Variable&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Normal Table&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;annotation subject&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;No List&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Outline List 1&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Outline List 2&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Outline List 3&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Simple 1&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Simple 2&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Simple 3&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Classic 1&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Classic 2&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Classic 3&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Classic 4&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Colorful 1&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Colorful 2&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Colorful 3&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Columns 1&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Columns 2&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Columns 3&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Columns 4&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Columns 5&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Grid 1&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Grid 2&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Grid 3&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Grid 4&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Grid 5&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Grid 6&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Grid 7&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Grid 8&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table List 1&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table List 2&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table List 3&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table List 4&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table List 5&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table List 6&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table List 7&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table List 8&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table 3D effects 1&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table 3D effects 2&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table 3D effects 3&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Contemporary&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Elegant&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Professional&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Subtle 1&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Subtle 2&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Web 1&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Web 2&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Web 3&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Balloon Text&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Grid&quot; w:uiPriority&#x3D;&quot;39&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Table Theme&quot; w:semiHidden&#x3D;&quot;1&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Placeholder Text&quot; w:semiHidden&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;No Spacing&quot; w:uiPriority&#x3D;&quot;1&quot; w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light Shading&quot; w:uiPriority&#x3D;&quot;60&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light List&quot; w:uiPriority&#x3D;&quot;61&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light Grid&quot; w:uiPriority&#x3D;&quot;62&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Shading 1&quot; w:uiPriority&#x3D;&quot;63&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Shading 2&quot; w:uiPriority&#x3D;&quot;64&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium List 1&quot; w:uiPriority&#x3D;&quot;65&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium List 2&quot; w:uiPriority&#x3D;&quot;66&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 1&quot; w:uiPriority&#x3D;&quot;67&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 2&quot; w:uiPriority&#x3D;&quot;68&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 3&quot; w:uiPriority&#x3D;&quot;69&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Dark List&quot; w:uiPriority&#x3D;&quot;70&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful Shading&quot; w:uiPriority&#x3D;&quot;71&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful List&quot; w:uiPriority&#x3D;&quot;72&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful Grid&quot; w:uiPriority&#x3D;&quot;73&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light Shading Accent 1&quot; w:uiPriority&#x3D;&quot;60&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light List Accent 1&quot; w:uiPriority&#x3D;&quot;61&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light Grid Accent 1&quot; w:uiPriority&#x3D;&quot;62&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Shading 1 Accent 1&quot; w:uiPriority&#x3D;&quot;63&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Shading 2 Accent 1&quot; w:uiPriority&#x3D;&quot;64&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium List 1 Accent 1&quot; w:uiPriority&#x3D;&quot;65&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Revision&quot; w:semiHidden&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Paragraph&quot; w:uiPriority&#x3D;&quot;34&quot; w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Quote&quot; w:uiPriority&#x3D;&quot;29&quot; w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Intense Quote&quot; w:uiPriority&#x3D;&quot;30&quot; w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium List 2 Accent 1&quot; w:uiPriority&#x3D;&quot;66&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 1 Accent 1&quot; w:uiPriority&#x3D;&quot;67&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 2 Accent 1&quot; w:uiPriority&#x3D;&quot;68&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 3 Accent 1&quot; w:uiPriority&#x3D;&quot;69&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Dark List Accent 1&quot; w:uiPriority&#x3D;&quot;70&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful Shading Accent 1&quot; w:uiPriority&#x3D;&quot;71&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful List Accent 1&quot; w:uiPriority&#x3D;&quot;72&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful Grid Accent 1&quot; w:uiPriority&#x3D;&quot;73&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light Shading Accent 2&quot; w:uiPriority&#x3D;&quot;60&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light List Accent 2&quot; w:uiPriority&#x3D;&quot;61&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light Grid Accent 2&quot; w:uiPriority&#x3D;&quot;62&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Shading 1 Accent 2&quot; w:uiPriority&#x3D;&quot;63&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Shading 2 Accent 2&quot; w:uiPriority&#x3D;&quot;64&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium List 1 Accent 2&quot; w:uiPriority&#x3D;&quot;65&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium List 2 Accent 2&quot; w:uiPriority&#x3D;&quot;66&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 1 Accent 2&quot; w:uiPriority&#x3D;&quot;67&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 2 Accent 2&quot; w:uiPriority&#x3D;&quot;68&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 3 Accent 2&quot; w:uiPriority&#x3D;&quot;69&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Dark List Accent 2&quot; w:uiPriority&#x3D;&quot;70&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful Shading Accent 2&quot; w:uiPriority&#x3D;&quot;71&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful List Accent 2&quot; w:uiPriority&#x3D;&quot;72&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful Grid Accent 2&quot; w:uiPriority&#x3D;&quot;73&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light Shading Accent 3&quot; w:uiPriority&#x3D;&quot;60&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light List Accent 3&quot; w:uiPriority&#x3D;&quot;61&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light Grid Accent 3&quot; w:uiPriority&#x3D;&quot;62&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Shading 1 Accent 3&quot; w:uiPriority&#x3D;&quot;63&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Shading 2 Accent 3&quot; w:uiPriority&#x3D;&quot;64&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium List 1 Accent 3&quot; w:uiPriority&#x3D;&quot;65&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium List 2 Accent 3&quot; w:uiPriority&#x3D;&quot;66&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 1 Accent 3&quot; w:uiPriority&#x3D;&quot;67&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 2 Accent 3&quot; w:uiPriority&#x3D;&quot;68&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 3 Accent 3&quot; w:uiPriority&#x3D;&quot;69&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Dark List Accent 3&quot; w:uiPriority&#x3D;&quot;70&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful Shading Accent 3&quot; w:uiPriority&#x3D;&quot;71&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful List Accent 3&quot; w:uiPriority&#x3D;&quot;72&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful Grid Accent 3&quot; w:uiPriority&#x3D;&quot;73&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light Shading Accent 4&quot; w:uiPriority&#x3D;&quot;60&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light List Accent 4&quot; w:uiPriority&#x3D;&quot;61&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light Grid Accent 4&quot; w:uiPriority&#x3D;&quot;62&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Shading 1 Accent 4&quot; w:uiPriority&#x3D;&quot;63&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Shading 2 Accent 4&quot; w:uiPriority&#x3D;&quot;64&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium List 1 Accent 4&quot; w:uiPriority&#x3D;&quot;65&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium List 2 Accent 4&quot; w:uiPriority&#x3D;&quot;66&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 1 Accent 4&quot; w:uiPriority&#x3D;&quot;67&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 2 Accent 4&quot; w:uiPriority&#x3D;&quot;68&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 3 Accent 4&quot; w:uiPriority&#x3D;&quot;69&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Dark List Accent 4&quot; w:uiPriority&#x3D;&quot;70&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful Shading Accent 4&quot; w:uiPriority&#x3D;&quot;71&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful List Accent 4&quot; w:uiPriority&#x3D;&quot;72&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful Grid Accent 4&quot; w:uiPriority&#x3D;&quot;73&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light Shading Accent 5&quot; w:uiPriority&#x3D;&quot;60&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light List Accent 5&quot; w:uiPriority&#x3D;&quot;61&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light Grid Accent 5&quot; w:uiPriority&#x3D;&quot;62&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Shading 1 Accent 5&quot; w:uiPriority&#x3D;&quot;63&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Shading 2 Accent 5&quot; w:uiPriority&#x3D;&quot;64&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium List 1 Accent 5&quot; w:uiPriority&#x3D;&quot;65&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium List 2 Accent 5&quot; w:uiPriority&#x3D;&quot;66&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 1 Accent 5&quot; w:uiPriority&#x3D;&quot;67&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 2 Accent 5&quot; w:uiPriority&#x3D;&quot;68&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 3 Accent 5&quot; w:uiPriority&#x3D;&quot;69&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Dark List Accent 5&quot; w:uiPriority&#x3D;&quot;70&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful Shading Accent 5&quot; w:uiPriority&#x3D;&quot;71&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful List Accent 5&quot; w:uiPriority&#x3D;&quot;72&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful Grid Accent 5&quot; w:uiPriority&#x3D;&quot;73&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light Shading Accent 6&quot; w:uiPriority&#x3D;&quot;60&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light List Accent 6&quot; w:uiPriority&#x3D;&quot;61&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Light Grid Accent 6&quot; w:uiPriority&#x3D;&quot;62&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Shading 1 Accent 6&quot; w:uiPriority&#x3D;&quot;63&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Shading 2 Accent 6&quot; w:uiPriority&#x3D;&quot;64&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium List 1 Accent 6&quot; w:uiPriority&#x3D;&quot;65&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium List 2 Accent 6&quot; w:uiPriority&#x3D;&quot;66&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 1 Accent 6&quot; w:uiPriority&#x3D;&quot;67&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 2 Accent 6&quot; w:uiPriority&#x3D;&quot;68&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Medium Grid 3 Accent 6&quot; w:uiPriority&#x3D;&quot;69&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Dark List Accent 6&quot; w:uiPriority&#x3D;&quot;70&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful Shading Accent 6&quot; w:uiPriority&#x3D;&quot;71&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful List Accent 6&quot; w:uiPriority&#x3D;&quot;72&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Colorful Grid Accent 6&quot; w:uiPriority&#x3D;&quot;73&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Subtle Emphasis&quot; w:uiPriority&#x3D;&quot;19&quot; w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Intense Emphasis&quot; w:uiPriority&#x3D;&quot;21&quot; w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Subtle Reference&quot; w:uiPriority&#x3D;&quot;31&quot; w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Intense Reference&quot; w:uiPriority&#x3D;&quot;32&quot; w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Book Title&quot; w:uiPriority&#x3D;&quot;33&quot; w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Bibliography&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;37&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;TOC Heading&quot; w:semiHidden&#x3D;&quot;1&quot; w:uiPriority&#x3D;&quot;39&quot; w:unhideWhenUsed&#x3D;&quot;1&quot;                                    w:qFormat&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Plain Table 1&quot; w:uiPriority&#x3D;&quot;41&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Plain Table 2&quot; w:uiPriority&#x3D;&quot;42&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Plain Table 3&quot; w:uiPriority&#x3D;&quot;43&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Plain Table 4&quot; w:uiPriority&#x3D;&quot;44&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Plain Table 5&quot; w:uiPriority&#x3D;&quot;45&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table Light&quot; w:uiPriority&#x3D;&quot;40&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 1 Light&quot; w:uiPriority&#x3D;&quot;46&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 2&quot; w:uiPriority&#x3D;&quot;47&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 3&quot; w:uiPriority&#x3D;&quot;48&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 4&quot; w:uiPriority&#x3D;&quot;49&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 5 Dark&quot; w:uiPriority&#x3D;&quot;50&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 6 Colorful&quot; w:uiPriority&#x3D;&quot;51&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 7 Colorful&quot; w:uiPriority&#x3D;&quot;52&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 1 Light Accent 1&quot; w:uiPriority&#x3D;&quot;46&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 2 Accent 1&quot; w:uiPriority&#x3D;&quot;47&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 3 Accent 1&quot; w:uiPriority&#x3D;&quot;48&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 4 Accent 1&quot; w:uiPriority&#x3D;&quot;49&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 5 Dark Accent 1&quot; w:uiPriority&#x3D;&quot;50&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 6 Colorful Accent 1&quot; w:uiPriority&#x3D;&quot;51&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 7 Colorful Accent 1&quot; w:uiPriority&#x3D;&quot;52&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 1 Light Accent 2&quot; w:uiPriority&#x3D;&quot;46&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 2 Accent 2&quot; w:uiPriority&#x3D;&quot;47&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 3 Accent 2&quot; w:uiPriority&#x3D;&quot;48&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 4 Accent 2&quot; w:uiPriority&#x3D;&quot;49&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 5 Dark Accent 2&quot; w:uiPriority&#x3D;&quot;50&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 6 Colorful Accent 2&quot; w:uiPriority&#x3D;&quot;51&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 7 Colorful Accent 2&quot; w:uiPriority&#x3D;&quot;52&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 1 Light Accent 3&quot; w:uiPriority&#x3D;&quot;46&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 2 Accent 3&quot; w:uiPriority&#x3D;&quot;47&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 3 Accent 3&quot; w:uiPriority&#x3D;&quot;48&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 4 Accent 3&quot; w:uiPriority&#x3D;&quot;49&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 5 Dark Accent 3&quot; w:uiPriority&#x3D;&quot;50&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 6 Colorful Accent 3&quot; w:uiPriority&#x3D;&quot;51&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 7 Colorful Accent 3&quot; w:uiPriority&#x3D;&quot;52&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 1 Light Accent 4&quot; w:uiPriority&#x3D;&quot;46&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 2 Accent 4&quot; w:uiPriority&#x3D;&quot;47&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 3 Accent 4&quot; w:uiPriority&#x3D;&quot;48&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 4 Accent 4&quot; w:uiPriority&#x3D;&quot;49&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 5 Dark Accent 4&quot; w:uiPriority&#x3D;&quot;50&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 6 Colorful Accent 4&quot; w:uiPriority&#x3D;&quot;51&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 7 Colorful Accent 4&quot; w:uiPriority&#x3D;&quot;52&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 1 Light Accent 5&quot; w:uiPriority&#x3D;&quot;46&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 2 Accent 5&quot; w:uiPriority&#x3D;&quot;47&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 3 Accent 5&quot; w:uiPriority&#x3D;&quot;48&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 4 Accent 5&quot; w:uiPriority&#x3D;&quot;49&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 5 Dark Accent 5&quot; w:uiPriority&#x3D;&quot;50&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 6 Colorful Accent 5&quot; w:uiPriority&#x3D;&quot;51&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 7 Colorful Accent 5&quot; w:uiPriority&#x3D;&quot;52&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 1 Light Accent 6&quot; w:uiPriority&#x3D;&quot;46&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 2 Accent 6&quot; w:uiPriority&#x3D;&quot;47&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 3 Accent 6&quot; w:uiPriority&#x3D;&quot;48&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 4 Accent 6&quot; w:uiPriority&#x3D;&quot;49&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 5 Dark Accent 6&quot; w:uiPriority&#x3D;&quot;50&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 6 Colorful Accent 6&quot; w:uiPriority&#x3D;&quot;51&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;Grid Table 7 Colorful Accent 6&quot; w:uiPriority&#x3D;&quot;52&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 1 Light&quot; w:uiPriority&#x3D;&quot;46&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 2&quot; w:uiPriority&#x3D;&quot;47&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 3&quot; w:uiPriority&#x3D;&quot;48&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 4&quot; w:uiPriority&#x3D;&quot;49&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 5 Dark&quot; w:uiPriority&#x3D;&quot;50&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 6 Colorful&quot; w:uiPriority&#x3D;&quot;51&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 7 Colorful&quot; w:uiPriority&#x3D;&quot;52&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 1 Light Accent 1&quot; w:uiPriority&#x3D;&quot;46&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 2 Accent 1&quot; w:uiPriority&#x3D;&quot;47&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 3 Accent 1&quot; w:uiPriority&#x3D;&quot;48&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 4 Accent 1&quot; w:uiPriority&#x3D;&quot;49&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 5 Dark Accent 1&quot; w:uiPriority&#x3D;&quot;50&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 6 Colorful Accent 1&quot; w:uiPriority&#x3D;&quot;51&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 7 Colorful Accent 1&quot; w:uiPriority&#x3D;&quot;52&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 1 Light Accent 2&quot; w:uiPriority&#x3D;&quot;46&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 2 Accent 2&quot; w:uiPriority&#x3D;&quot;47&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 3 Accent 2&quot; w:uiPriority&#x3D;&quot;48&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 4 Accent 2&quot; w:uiPriority&#x3D;&quot;49&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 5 Dark Accent 2&quot; w:uiPriority&#x3D;&quot;50&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 6 Colorful Accent 2&quot; w:uiPriority&#x3D;&quot;51&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 7 Colorful Accent 2&quot; w:uiPriority&#x3D;&quot;52&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 1 Light Accent 3&quot; w:uiPriority&#x3D;&quot;46&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 2 Accent 3&quot; w:uiPriority&#x3D;&quot;47&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 3 Accent 3&quot; w:uiPriority&#x3D;&quot;48&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 4 Accent 3&quot; w:uiPriority&#x3D;&quot;49&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 5 Dark Accent 3&quot; w:uiPriority&#x3D;&quot;50&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 6 Colorful Accent 3&quot; w:uiPriority&#x3D;&quot;51&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 7 Colorful Accent 3&quot; w:uiPriority&#x3D;&quot;52&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 1 Light Accent 4&quot; w:uiPriority&#x3D;&quot;46&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 2 Accent 4&quot; w:uiPriority&#x3D;&quot;47&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 3 Accent 4&quot; w:uiPriority&#x3D;&quot;48&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 4 Accent 4&quot; w:uiPriority&#x3D;&quot;49&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 5 Dark Accent 4&quot; w:uiPriority&#x3D;&quot;50&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 6 Colorful Accent 4&quot; w:uiPriority&#x3D;&quot;51&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 7 Colorful Accent 4&quot; w:uiPriority&#x3D;&quot;52&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 1 Light Accent 5&quot; w:uiPriority&#x3D;&quot;46&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 2 Accent 5&quot; w:uiPriority&#x3D;&quot;47&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 3 Accent 5&quot; w:uiPriority&#x3D;&quot;48&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 4 Accent 5&quot; w:uiPriority&#x3D;&quot;49&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 5 Dark Accent 5&quot; w:uiPriority&#x3D;&quot;50&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 6 Colorful Accent 5&quot; w:uiPriority&#x3D;&quot;51&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 7 Colorful Accent 5&quot; w:uiPriority&#x3D;&quot;52&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 1 Light Accent 6&quot; w:uiPriority&#x3D;&quot;46&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 2 Accent 6&quot; w:uiPriority&#x3D;&quot;47&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 3 Accent 6&quot; w:uiPriority&#x3D;&quot;48&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 4 Accent 6&quot; w:uiPriority&#x3D;&quot;49&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 5 Dark Accent 6&quot; w:uiPriority&#x3D;&quot;50&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 6 Colorful Accent 6&quot; w:uiPriority&#x3D;&quot;51&quot;&#x2F;&gt;                    &lt;w:lsdException w:name&#x3D;&quot;List Table 7 Colorful Accent 6&quot; w:uiPriority&#x3D;&quot;52&quot;&#x2F;&gt;                &lt;&#x2F;w:latentStyles&gt;                &lt;w:style w:type&#x3D;&quot;paragraph&quot; w:default&#x3D;&quot;1&quot; w:styleId&#x3D;&quot;a&quot;&gt;                    &lt;w:name w:val&#x3D;&quot;Normal&quot;&#x2F;&gt;                    &lt;w:qFormat&#x2F;&gt;                    &lt;w:pPr&gt;                        &lt;w:widowControl w:val&#x3D;&quot;0&quot;&#x2F;&gt;                        &lt;w:jc w:val&#x3D;&quot;both&quot;&#x2F;&gt;                    &lt;&#x2F;w:pPr&gt;                &lt;&#x2F;w:style&gt;                &lt;w:style w:type&#x3D;&quot;character&quot; w:default&#x3D;&quot;1&quot; w:styleId&#x3D;&quot;a0&quot;&gt;                    &lt;w:name w:val&#x3D;&quot;Default Paragraph Font&quot;&#x2F;&gt;                    &lt;w:uiPriority w:val&#x3D;&quot;1&quot;&#x2F;&gt;                    &lt;w:semiHidden&#x2F;&gt;                    &lt;w:unhideWhenUsed&#x2F;&gt;                &lt;&#x2F;w:style&gt;                &lt;w:style w:type&#x3D;&quot;table&quot; w:default&#x3D;&quot;1&quot; w:styleId&#x3D;&quot;a1&quot;&gt;                    &lt;w:name w:val&#x3D;&quot;Normal Table&quot;&#x2F;&gt;                    &lt;w:uiPriority w:val&#x3D;&quot;99&quot;&#x2F;&gt;                    &lt;w:semiHidden&#x2F;&gt;                    &lt;w:unhideWhenUsed&#x2F;&gt;                    &lt;w:tblPr&gt;                        &lt;w:tblInd w:w&#x3D;&quot;0&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                        &lt;w:tblCellMar&gt;                            &lt;w:top w:w&#x3D;&quot;0&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                            &lt;w:left w:w&#x3D;&quot;108&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                            &lt;w:bottom w:w&#x3D;&quot;0&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                            &lt;w:right w:w&#x3D;&quot;108&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                        &lt;&#x2F;w:tblCellMar&gt;                    &lt;&#x2F;w:tblPr&gt;                &lt;&#x2F;w:style&gt;                &lt;w:style w:type&#x3D;&quot;numbering&quot; w:default&#x3D;&quot;1&quot; w:styleId&#x3D;&quot;a2&quot;&gt;                    &lt;w:name w:val&#x3D;&quot;No List&quot;&#x2F;&gt;                    &lt;w:uiPriority w:val&#x3D;&quot;99&quot;&#x2F;&gt;                    &lt;w:semiHidden&#x2F;&gt;                    &lt;w:unhideWhenUsed&#x2F;&gt;                &lt;&#x2F;w:style&gt;                &lt;w:style w:type&#x3D;&quot;paragraph&quot; w:styleId&#x3D;&quot;a3&quot;&gt;                    &lt;w:name w:val&#x3D;&quot;header&quot;&#x2F;&gt;                    &lt;w:basedOn w:val&#x3D;&quot;a&quot;&#x2F;&gt;                    &lt;w:link w:val&#x3D;&quot;Char&quot;&#x2F;&gt;                    &lt;w:uiPriority w:val&#x3D;&quot;99&quot;&#x2F;&gt;                    &lt;w:unhideWhenUsed&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;00BD58CB&quot;&#x2F;&gt;                    &lt;w:pPr&gt;                        &lt;w:pBdr&gt;                            &lt;w:bottom w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;6&quot; w:space&#x3D;&quot;1&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                        &lt;&#x2F;w:pBdr&gt;                        &lt;w:tabs&gt;                            &lt;w:tab w:val&#x3D;&quot;center&quot; w:pos&#x3D;&quot;4153&quot;&#x2F;&gt;                            &lt;w:tab w:val&#x3D;&quot;right&quot; w:pos&#x3D;&quot;8306&quot;&#x2F;&gt;                        &lt;&#x2F;w:tabs&gt;                        &lt;w:snapToGrid w:val&#x3D;&quot;0&quot;&#x2F;&gt;                        &lt;w:jc w:val&#x3D;&quot;center&quot;&#x2F;&gt;                    &lt;&#x2F;w:pPr&gt;                    &lt;w:rPr&gt;                        &lt;w:sz w:val&#x3D;&quot;18&quot;&#x2F;&gt;                        &lt;w:szCs w:val&#x3D;&quot;18&quot;&#x2F;&gt;                    &lt;&#x2F;w:rPr&gt;                &lt;&#x2F;w:style&gt;                &lt;w:style w:type&#x3D;&quot;character&quot; w:customStyle&#x3D;&quot;1&quot; w:styleId&#x3D;&quot;Char&quot;&gt;                    &lt;w:name w:val&#x3D;&quot;页眉 Char&quot;&#x2F;&gt;                    &lt;w:basedOn w:val&#x3D;&quot;a0&quot;&#x2F;&gt;                    &lt;w:link w:val&#x3D;&quot;a3&quot;&#x2F;&gt;                    &lt;w:uiPriority w:val&#x3D;&quot;99&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;00BD58CB&quot;&#x2F;&gt;                    &lt;w:rPr&gt;                        &lt;w:sz w:val&#x3D;&quot;18&quot;&#x2F;&gt;                        &lt;w:szCs w:val&#x3D;&quot;18&quot;&#x2F;&gt;                    &lt;&#x2F;w:rPr&gt;                &lt;&#x2F;w:style&gt;                &lt;w:style w:type&#x3D;&quot;paragraph&quot; w:styleId&#x3D;&quot;a4&quot;&gt;                    &lt;w:name w:val&#x3D;&quot;footer&quot;&#x2F;&gt;                    &lt;w:basedOn w:val&#x3D;&quot;a&quot;&#x2F;&gt;                    &lt;w:link w:val&#x3D;&quot;Char0&quot;&#x2F;&gt;                    &lt;w:uiPriority w:val&#x3D;&quot;99&quot;&#x2F;&gt;                    &lt;w:unhideWhenUsed&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;00BD58CB&quot;&#x2F;&gt;                    &lt;w:pPr&gt;                        &lt;w:tabs&gt;                            &lt;w:tab w:val&#x3D;&quot;center&quot; w:pos&#x3D;&quot;4153&quot;&#x2F;&gt;                            &lt;w:tab w:val&#x3D;&quot;right&quot; w:pos&#x3D;&quot;8306&quot;&#x2F;&gt;                        &lt;&#x2F;w:tabs&gt;                        &lt;w:snapToGrid w:val&#x3D;&quot;0&quot;&#x2F;&gt;                        &lt;w:jc w:val&#x3D;&quot;left&quot;&#x2F;&gt;                    &lt;&#x2F;w:pPr&gt;                    &lt;w:rPr&gt;                        &lt;w:sz w:val&#x3D;&quot;18&quot;&#x2F;&gt;                        &lt;w:szCs w:val&#x3D;&quot;18&quot;&#x2F;&gt;                    &lt;&#x2F;w:rPr&gt;                &lt;&#x2F;w:style&gt;                &lt;w:style w:type&#x3D;&quot;character&quot; w:customStyle&#x3D;&quot;1&quot; w:styleId&#x3D;&quot;Char0&quot;&gt;                    &lt;w:name w:val&#x3D;&quot;页脚 Char&quot;&#x2F;&gt;                    &lt;w:basedOn w:val&#x3D;&quot;a0&quot;&#x2F;&gt;                    &lt;w:link w:val&#x3D;&quot;a4&quot;&#x2F;&gt;                    &lt;w:uiPriority w:val&#x3D;&quot;99&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;00BD58CB&quot;&#x2F;&gt;                    &lt;w:rPr&gt;                        &lt;w:sz w:val&#x3D;&quot;18&quot;&#x2F;&gt;                        &lt;w:szCs w:val&#x3D;&quot;18&quot;&#x2F;&gt;                    &lt;&#x2F;w:rPr&gt;                &lt;&#x2F;w:style&gt;                &lt;w:style w:type&#x3D;&quot;table&quot; w:styleId&#x3D;&quot;a5&quot;&gt;                    &lt;w:name w:val&#x3D;&quot;Table Grid&quot;&#x2F;&gt;                    &lt;w:basedOn w:val&#x3D;&quot;a1&quot;&#x2F;&gt;                    &lt;w:uiPriority w:val&#x3D;&quot;39&quot;&#x2F;&gt;                    &lt;w:rsid w:val&#x3D;&quot;00BD58CB&quot;&#x2F;&gt;                    &lt;w:rPr&gt;                        &lt;w:rFonts w:cs&#x3D;&quot;Times New Roman&quot;&#x2F;&gt;                    &lt;&#x2F;w:rPr&gt;                    &lt;w:tblPr&gt;                        &lt;w:tblInd w:w&#x3D;&quot;0&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                        &lt;w:tblBorders&gt;                            &lt;w:top w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                            &lt;w:left w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                            &lt;w:bottom w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                            &lt;w:right w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                            &lt;w:insideH w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                            &lt;w:insideV w:val&#x3D;&quot;single&quot; w:sz&#x3D;&quot;4&quot; w:space&#x3D;&quot;0&quot; w:color&#x3D;&quot;auto&quot;&#x2F;&gt;                        &lt;&#x2F;w:tblBorders&gt;                        &lt;w:tblCellMar&gt;                            &lt;w:top w:w&#x3D;&quot;0&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                            &lt;w:left w:w&#x3D;&quot;108&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                            &lt;w:bottom w:w&#x3D;&quot;0&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                            &lt;w:right w:w&#x3D;&quot;108&quot; w:type&#x3D;&quot;dxa&quot;&#x2F;&gt;                        &lt;&#x2F;w:tblCellMar&gt;                    &lt;&#x2F;w:tblPr&gt;                &lt;&#x2F;w:style&gt;            &lt;&#x2F;w:styles&gt;        &lt;&#x2F;pkg:xmlData&gt;    &lt;&#x2F;pkg:part&gt;    &lt;pkg:part pkg:name&#x3D;&quot;&#x2F;docProps&#x2F;core.xml&quot; pkg:contentType&#x3D;&quot;application&#x2F;vnd.openxmlformats-package.core-properties+xml&quot;              pkg:padding&#x3D;&quot;256&quot;&gt;        &lt;pkg:xmlData&gt;            &lt;cp:coreProperties xmlns:cp&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;package&#x2F;2006&#x2F;metadata&#x2F;core-properties&quot;                               xmlns:dc&#x3D;&quot;http:&#x2F;&#x2F;purl.org&#x2F;dc&#x2F;elements&#x2F;1.1&#x2F;&quot; xmlns:dcterms&#x3D;&quot;http:&#x2F;&#x2F;purl.org&#x2F;dc&#x2F;terms&#x2F;&quot;                               xmlns:dcmitype&#x3D;&quot;http:&#x2F;&#x2F;purl.org&#x2F;dc&#x2F;dcmitype&#x2F;&quot;                               xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;&gt;                &lt;dc:title&#x2F;&gt;                &lt;dc:subject&#x2F;&gt;                &lt;dc:creator&gt;adminUser&lt;&#x2F;dc:creator&gt;                &lt;cp:keywords&#x2F;&gt;                &lt;dc:description&#x2F;&gt;                &lt;cp:lastModifiedBy&gt;adminUser&lt;&#x2F;cp:lastModifiedBy&gt;                &lt;cp:revision&gt;2&lt;&#x2F;cp:revision&gt;                &lt;dcterms:created xsi:type&#x3D;&quot;dcterms:W3CDTF&quot;&gt;2020-12-22T09:30:00Z&lt;&#x2F;dcterms:created&gt;                &lt;dcterms:modified xsi:type&#x3D;&quot;dcterms:W3CDTF&quot;&gt;2020-12-22T09:30:00Z&lt;&#x2F;dcterms:modified&gt;            &lt;&#x2F;cp:coreProperties&gt;        &lt;&#x2F;pkg:xmlData&gt;    &lt;&#x2F;pkg:part&gt;&lt;&#x2F;pkg:package&gt;","categories":["工具类"],"tags":["工具类","springboot","导出","word","freemarker","模板"]},{"title":"分布式id生成策略--雪花算法","url":"https://www.mele.cool/2020/12/07/分布式id生成策略--雪花算法/","content":"1.概论UUID 能保证保证时空唯一，但是过长且是字符，雪花算法由Twitter发明，是一串数字。Snowflake是一种约定，它把时间戳、工作组 ID、工作机器 ID、自增序列号组合在一起，生成一个 64bits 的整数ID，能够使用 (2^41)/(1000606024365) = 69.7 年，每台机器每毫秒理论最多生成 2^12 个 ID\n1 bit：固定为0二进制里第一个bit如果是 1，表示负数，但是我们生成的 id都是正数，所以第一个 bit 统一都是 0。41 bit：时间戳，单位毫秒41 bit 可以表示的数字多达 2^41 - 1，也就是可以标识 2 ^ 41 - 1 个毫秒值。注意！这个时间不是绝对时间戳，而是相对值，所以需要定义一个系统开始上线的起始时间10 bit：哪台机器产生的代表的是这个服务最多可以部署在 2^10 台机器上，也就是 1024 台机器。官方定义，前5 个 bit 代表机房 id，后5 个 bit 代表机器 id。这10位是机器维度，可以根据公司的实际情况自由定制。12 bit：自增序列同1毫秒内，同一机器，可以产生2 ^ 12 - 1 = 4096个不同的 id。\n优缺点：\n\n不依赖第三方介质例如 Redis、数据库，本地程序生成分布式自增 ID\n只能保证在工作组中的机器生成的 ID 唯一，不同组下可能会重复\n时间回拨后，生成的 ID 就会重复，所以需要保持时间是网络同步的。\n\n##2. 实现\n###2.1自己用java代码实现\n工具类：\npackage com.itheima.sharding.config;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class Snowflake &#123;    /** 序列的掩码，12个1，也就是(0B111111111111=0xFFF=4095) */    private static final long SEQUENCE_MASK = 0xFFF;    /**系统起始时间，这里取2020-01-01 **/    private long startTimeStamp = 1577836800000L;    /** 上次生成 ID 的时间截 */    private long lastTimestamp = -1L;    /** 工作机器 ID(0~31) */    private long workerId;    /** 数据中心 ID(0~31) */    private long datacenterId;    /** 毫秒内序列(0~4095) */    private long sequence = 0L;    /**     * @param datacenterId 数据中心 ID (0~31)     * @param workerId     工作机器 ID (0~31)     */    public Snowflake(@Value(&quot;$&#123;snowflake.datacenterId&#125;&quot;) long datacenterId, @Value(&quot;$&#123;snowflake.workerId&#125;&quot;) long workerId) &#123;        if (workerId &gt; 31 || workerId &lt; 0) &#123;            throw new IllegalArgumentException(&quot;workId必须在0-31之间，当前=&quot;+workerId);        &#125;        if (datacenterId &gt; 31 || datacenterId &lt; 0) &#123;            throw new IllegalArgumentException(&quot;datacenterId必须在0-31之间，当前=&quot;+datacenterId);        &#125;        this.workerId = workerId;        this.datacenterId = datacenterId;    &#125;    /**     * 加锁，线程安全     * @return long 类型的 ID     */    public synchronized long nextId() &#123;        long timestamp = currentTime();        // 如果当前时间小于上一次 ID 生成的时间戳，说明系统时钟回退过这个时候应当抛出异常        if (timestamp &lt; lastTimestamp) &#123;            throw new RuntimeException(&quot;时钟回退！时间差=&quot;+(lastTimestamp - timestamp));        &#125;        // 同一毫秒内，序列增加        if (lastTimestamp == timestamp) &#123;            //超出阈值。思考下为什么这么运算？            sequence = (sequence + 1) &amp; SEQUENCE_MASK;            // 毫秒内序列溢出            if (sequence == 0) &#123;                //自旋等待下一毫秒                while ((timestamp= currentTime()) &lt;= lastTimestamp);            &#125;        &#125; else &#123;            //已经进入下一毫秒，从0开始计数            sequence = 0L;        &#125;        //赋值为新的时间戳        lastTimestamp = timestamp;        //移位拼接        long id = ((timestamp - startTimeStamp) &lt;&lt; 22)                | (datacenterId &lt;&lt; 17)                | (workerId &lt;&lt; 12)                | sequence;        System.out.println(&quot;new id = &quot;+id);        System.out.println(&quot;bit id = &quot;+toBit(id));        return id;    &#125;    /**     * 返回当前时间，以毫秒为单位     */    protected long currentTime() &#123;        return System.currentTimeMillis();    &#125;    /**     * 转成二进制展示     */    public static String toBit(long id)&#123;        String bit = StringUtils.leftPad(Long.toBinaryString(id), 64, &quot;0&quot;);        return bit.substring(0,1) +                &quot; - &quot; +                bit.substring(1,42) +                &quot; - &quot; +                bit.substring(42,52)+                &quot; - &quot; +                bit.substring(52,64);    &#125;    public static void main(String[] args) &#123;        Snowflake idWorker = new Snowflake(1, 1);        for (int i = 0; i &lt; 10; i++) &#123;            long id = idWorker.nextId();            System.out.println(id);            System.out.println(toBit(id));        &#125;    &#125;&#125;\n\n\nspringboot启动参数，指定机器编号：\nsnowflake.datacenterId=1snowflake.workerId=1\n\n\n业务部分：\n/** * 自定义雪花算法 */@GetMapping(&quot;/myflake&quot;)public Strorder myflake(int userid)&#123;    Strorder order = new Strorder();    order.setId(String.valueOf(snowflake.nextId()));    order.setUserid(userid);    strorderMapper.save(order);    return order;&#125;\n\n\n\n代码启动生成，分析位数\n更改机器id，分析位数\n\n2.2借助sharding配置配置信息，非常简单\nspring.shardingsphere.sharding.tables.strorder.key-generator.column=idspring.shardingsphere.sharding.tables.strorder.key-generator.type=SNOWFLAKEspring.shardingsphere.sharding.tables.strorder.key-generator.props.worker.id=3\n\n\nMapper代码\n\n注意：before=false\n\n@Insert(&#123;        &quot;insert into strorder (userid)&quot;,        &quot;values (#&#123;userid,jdbcType=INTEGER&#125;)&quot;&#125;)@SelectKey(statement=&quot;SELECT max(id) from strorder where userid=#&#123;userid,jdbcType=INTEGER&#125;&quot;, keyProperty=&quot;id&quot;, before=false, resultType=String.class)int shardingIdSave(Strorder record);\n\n\n业务代码\n/** * sharding的雪花算法 */@GetMapping(&quot;/shardingFlake&quot;)public Strorder shardingFlake(int userid)&#123;    Strorder order = new Strorder();    order.setUserid(userid);    strorderMapper.shardingIdSave(order);    System.out.println(Snowflake.toBit(Long.valueOf(order.getId())));    return order;&#125;\n结果分析\n\n生成的id号由sharding-jdbc自动添加到maper的sql中\n机器编号为3，所以打印的bit中机器为 00011，修改为其他机器，测试结果\n\nsharding源码分析：\npackage org.apache.shardingsphere.core.strategy.keygen;import com.google.common.base.Preconditions;import java.util.Calendar;import java.util.Properties;import lombok.Generated;import org.apache.shardingsphere.spi.keygen.ShardingKeyGenerator;public final class SnowflakeShardingKeyGenerator implements ShardingKeyGenerator &#123;    public static final long EPOCH;    private static final long SEQUENCE_BITS = 12L;    private static final long WORKER_ID_BITS = 10L;    private static final long SEQUENCE_MASK = 4095L;    private static final long WORKER_ID_LEFT_SHIFT_BITS = 12L;    private static final long TIMESTAMP_LEFT_SHIFT_BITS = 22L;    private static final long WORKER_ID_MAX_VALUE = 1024L;    private static final long WORKER_ID = 0L;    private static final int DEFAULT_VIBRATION_VALUE = 1;    private static final int MAX_TOLERATE_TIME_DIFFERENCE_MILLISECONDS = 10;    private static TimeService timeService = new TimeService();    private Properties properties = new Properties();    private int sequenceOffset = -1;    private long sequence;    private long lastMilliseconds;    public SnowflakeShardingKeyGenerator() &#123;    &#125;    public String getType() &#123;        return &quot;SNOWFLAKE&quot;;    &#125;    public synchronized Comparable&lt;?&gt; generateKey() &#123;        long currentMilliseconds = timeService.getCurrentMillis();        if (this.waitTolerateTimeDifferenceIfNeed(currentMilliseconds)) &#123;            currentMilliseconds = timeService.getCurrentMillis();        &#125;        if (this.lastMilliseconds == currentMilliseconds) &#123;            if (0L == (this.sequence = this.sequence + 1L &amp; 4095L)) &#123;                currentMilliseconds = this.waitUntilNextTime(currentMilliseconds);            &#125;        &#125; else &#123;            this.vibrateSequenceOffset();            this.sequence = (long)this.sequenceOffset;        &#125;        this.lastMilliseconds = currentMilliseconds;        return currentMilliseconds - EPOCH &lt;&lt; 22 | this.getWorkerId() &lt;&lt; 12 | this.sequence;    &#125;    //...\t//获取机器编号    private long getWorkerId() &#123;        long result = Long.valueOf(this.properties.getProperty(&quot;worker.id&quot;, String.valueOf(0L)));        Preconditions.checkArgument(result &gt;= 0L &amp;&amp; result &lt; 1024L);        return result;    &#125;\t//...        //序列上限，等候下一毫秒    private long waitUntilNextTime(long lastTime) &#123;        long result;        for(result = timeService.getCurrentMillis();             result &lt;= lastTime;             result = timeService.getCurrentMillis()) &#123;            ;        &#125;        return result;    &#125;    static &#123;        Calendar calendar = Calendar.getInstance();        calendar.set(2016, 10, 1);        calendar.set(11, 0);        calendar.set(12, 0);        calendar.set(13, 0);        calendar.set(14, 0);        EPOCH = calendar.getTimeInMillis();    &#125;&#125;\n2.3 时钟回退问题关于snowflake算法的缺陷（时钟回拨问题），sharding-jdbc没有给出解决方案\n3.第三方实现###3.1 百度UidGeneratorhttps://github.com/baidu/uid-generator/blob/master/README.zh_cn.md\n\n位数不太一样，1-28-22-13\n\n需要mysql数据库建表，来自动配置工作节点\n\n支持spring配置与集成\n\n支持bit位自定义，及bit分配相关建议###3.2 美团Leaf-snowflakehttps://tech.meituan.com/2017/04/21/mt-leaf.html\n\n位数沿用snowflake方案的bit位设计\n\n使用Zookeeper持久顺序节点的特性自动对snowflake节点配置wokerID\n\n解决了时钟回退问题\n\n线上可靠性验证，美团的金融、支付交易、餐饮、外卖、酒店旅游、猫眼电影等众多业务\n\n\n","categories":["java"],"tags":["工具类","java","雪花算法","分布式"]},{"title":"AES-128-ECB加密工具类","url":"https://www.mele.cool/2020/12/04/AES-128-ECB加密工具类/","content":"依赖&lt;!-- https://mvnrepository.com/artifact/commons-codec/commons-codec --&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-codec&lt;/groupId&gt;    &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;    &lt;version&gt;1.10&lt;/version&gt;&lt;/dependency&gt;\n代码工具类package com.blydd.util;import javax.crypto.Cipher;import javax.crypto.spec.SecretKeySpec;import org.apache.commons.codec.binary.Base64;public class AesUtil &#123;    // 加密    public static String encrypt(String sSrc, String sKey) throws Exception &#123;        if (sKey == null) &#123;            System.err.println(&quot;Key为空null&quot;);            return null;        &#125;        // 判断Key是否为16位        if (sKey.length() != 16) &#123;            System.err.println(&quot;Key长度不是16位&quot;);            return null;        &#125;        byte[] raw = sKey.getBytes(&quot;utf-8&quot;);        SecretKeySpec skeySpec = new SecretKeySpec(raw, &quot;AES&quot;);        Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);//&quot;算法/模式/补码方式&quot;        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);        byte[] encrypted = cipher.doFinal(sSrc.getBytes(&quot;utf-8&quot;));        return new Base64().encodeToString(encrypted);//此处使用BASE64做转码功能，同时能起到2次加密的作用    &#125;    // 解密    public static String decrypt(String sSrc, String sKey) throws Exception &#123;        try &#123;            // 判断Key是否正确            if (sKey == null) &#123;                System.err.println(&quot;Key为空null&quot;);                return null;            &#125;            // 判断Key是否为16位            if (sKey.length() != 16) &#123;                System.err.println(&quot;Key长度不是16位&quot;);                return null;            &#125;            byte[] raw = sKey.getBytes(&quot;utf-8&quot;);            SecretKeySpec skeySpec = new SecretKeySpec(raw, &quot;AES&quot;);            Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);            cipher.init(Cipher.DECRYPT_MODE, skeySpec);            byte[] encrypted1 = new Base64().decode(sSrc);//先用base64解密            try &#123;                byte[] original = cipher.doFinal(encrypted1);                String originalString = new String(original, &quot;utf-8&quot;);                return originalString;            &#125; catch (Exception e) &#123;                System.err.println(e.toString());                return null;            &#125;        &#125; catch (Exception ex) &#123;            System.err.println(ex.toString());            return null;        &#125;    &#125;    public static void main(String[] args) throws Exception &#123;        /*         * 此处使用AES-128-ECB加密模式，key需要为16位         */        String cKey = &quot;KeLy8g7qjmnbgWP0&quot;;        // 需要加密的字串        String cSrc = &quot;123456&quot;;        System.err.println(&quot;加密前的字串是：&quot; + cSrc);        // 加密        String enString = AesUtil.encrypt(cSrc, cKey);        System.err.println(&quot;加密后的字串是：&quot; + enString);        // 解密pVAODDo8l3wEp3h8DhJ2bO7EJGTshjUN0ODz1QvPeFNblJuFz4aNMVLFTHK6sojo        String deString = AesUtil.decrypt(enString, cKey);        System.err.println(&quot;解密后的字串是：&quot; + deString);    &#125;&#125;","categories":["工具类"],"tags":["工具类"]},{"title":"http请求工具类","url":"https://www.mele.cool/2020/12/04/HTTP请求工具类/","content":"package com.haier.otcwms.util;import java.io.*;import org.apache.http.HttpEntity;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;/** * 请求工具类 */public class RequestUtil &#123;    //日志    private static Logger LOGGER = LoggerFactory.getLogger(RequestUtil.class);    /**     * post请求     *     * @param url 请求地址     * @param json 请求参数     * @param     * @return 响应信息     * @throws UnsupportedEncodingException     */    public static JSONObject postRequest(String url, String json) throws UnsupportedEncodingException &#123;        JSONObject obj = new JSONObject();        // 创建http请求.        CloseableHttpClient httpclient = HttpClients.createDefault();        HttpPost httpPost = new HttpPost(url);        httpPost.setHeader(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;);        //设置超时时间两分钟        RequestConfig requestConfig = RequestConfig.custom()                .setConnectTimeout(120000).setConnectionRequestTimeout(100000)                .setSocketTimeout(120000).build();        httpPost.setConfig(requestConfig);        StringEntity stringEntity = new StringEntity(json, &quot;utf-8&quot;);        // 设置发送数据        httpPost.setEntity(stringEntity);        // 创建响应        CloseableHttpResponse response = null;        String str=&quot;&quot;;        try &#123;            // 执行请求            response = httpclient.execute(httpPost);            // 获取响应实体            HttpEntity entity = response.getEntity();            if (entity != null) &#123;//                System.out.println(&quot;--------------------------------------&quot;);                str = EntityUtils.toString(entity);//                System.err.println(&quot;响应内容    : &quot; + str);                JSONArray resultArray=JSONArray.parseArray(str);//                System.err.println(&quot;url:&quot; + url);//                System.err.println(&quot;stringEntity:&quot; + stringEntity);//                System.err.println(&quot;响应状态&quot; + response.getStatusLine());//                System.err.println(&quot;响应内容长度  : &quot; + entity.getContentLength());//                System.out.println(&quot;--------------------------------------&quot;);                JSONObject resultone = (JSONObject) resultArray.get(0);                if (resultone.getInteger(&quot;ResultCode&quot;) == 0) &#123;                    obj.put(&quot;flag&quot;, true);                    obj.put(&quot;msg&quot;, resultArray);                &#125;else&#123;                    obj.put(&quot;flag&quot;, false);                    obj.put(&quot;msg&quot;, str);                &#125;            &#125;        &#125; catch (Exception e) &#123;            LOGGER.error(&quot;call url:&#123;&#125; failed.&quot;, url);            LOGGER.error(e.getMessage(),e);            obj.put(&quot;flag&quot;, false);            obj.put(&quot;msg&quot;, e.getMessage()+&quot;,interface return:&quot;+str);        &#125; finally &#123;            try &#123;                if (null != response) &#123;                    response.close();                &#125;            &#125; catch (IOException e) &#123;                LOGGER.error(e.getMessage());            &#125;            try &#123;                if (null != httpclient) &#123;                    httpclient.close();                &#125;            &#125; catch (IOException e) &#123;                LOGGER.error(e.getMessage());            &#125;        &#125;        return obj;    &#125;    /**     * get请求     *     * @param url          请求地址     * @param     * @return 响应信息     */    public static JSONObject getRequest(String url) &#123;        JSONObject obj = new JSONObject();        CloseableHttpClient httpclient = null;        HttpGet httpGet = null;        try &#123;            //创建http请求.            httpclient = HttpClients.createDefault();            httpGet = new HttpGet(url);            httpGet.setHeader(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;);        &#125;catch (Exception exx)&#123;            obj.put(&quot;flag&quot;, false);            obj.put(&quot;msg&quot;, exx.getMessage());            LOGGER.error(exx.getMessage(),exx);            return obj;        &#125;        //创建响应        CloseableHttpResponse response = null;        try &#123;            //执行请求            response = httpclient.execute(httpGet);            //获取响应实体            HttpEntity entity = response.getEntity();            if (entity != null) &#123;                String str = EntityUtils.toString(entity);                obj = JSONObject.parseObject(str);//                System.out.println(&quot;--------------------------------------&quot;);//                System.err.println(&quot;url:&quot; + url);//                System.err.println(&quot;响应状态&quot; + response.getStatusLine());//                System.err.println(&quot;响应内容长度  : &quot; + entity.getContentLength());//                System.err.println(&quot;响应内容    : &quot; + str);//                System.out.println(&quot;--------------------------------------&quot;);            &#125;        &#125; catch (Exception e) &#123;            LOGGER.error(&quot;call url:&#123;&#125; failed.&quot;, url);            LOGGER.error(e.getMessage());            obj.put(&quot;flag&quot;, false);            obj.put(&quot;msg&quot;, e.getMessage());        &#125; finally &#123;            try &#123;                if (null != response) &#123;                    response.close();                &#125;            &#125; catch (IOException e) &#123;                LOGGER.error(e.getMessage());            &#125;            try &#123;                if (null != httpclient) &#123;                    httpclient.close();                &#125;            &#125; catch (IOException e) &#123;                LOGGER.error(e.getMessage());            &#125;        &#125;        return obj;    &#125;&#125;\n\n\n\n\n\npackage com.haier.otcwms.util;import com.alibaba.fastjson.JSONObject;import org.apache.http.HttpEntity;import org.apache.http.NameValuePair;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.client.utils.URIBuilder;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicHeader;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.ArrayList;import java.util.List;/** * HttpClient发送GET、POST请求 * @Author libin * @CreateDate 2018.5.28 16:56 */public class HttpClientService &#123;    private static final Logger LOGGER = LoggerFactory.getLogger(HttpClientService.class);    /**     * 返回成功状态码     */    private static final int SUCCESS_CODE = 200;    /**     * 发送GET请求     * @param url   请求url     * @param nameValuePairList    请求参数     * @return JSON或者字符串     * @throws Exception     */    public static Object sendGet(String url, List&lt;NameValuePair&gt; nameValuePairList) throws Exception&#123;        JSONObject jsonObject = null;        CloseableHttpClient client = null;        CloseableHttpResponse response = null;        try&#123;            /**             * 创建HttpClient对象             */            client = HttpClients.createDefault();            /**             * 创建URIBuilder             */            URIBuilder uriBuilder = new URIBuilder(url);            /**             * 设置参数             */            uriBuilder.addParameters(nameValuePairList);            /**             * 创建HttpGet             */            HttpGet httpGet = new HttpGet(uriBuilder.build());            /**             * 设置请求头部编码             */            httpGet.setHeader(new BasicHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded; charset=utf-8&quot;));            /**             * 设置返回编码             */            httpGet.setHeader(new BasicHeader(&quot;Accept&quot;, &quot;text/plain;charset=utf-8&quot;));            /**             * 请求服务             */            response = client.execute(httpGet);            /**             * 获取响应吗             */            int statusCode = response.getStatusLine().getStatusCode();            if (SUCCESS_CODE == statusCode)&#123;                /**                 * 获取返回对象                 */                HttpEntity entity = response.getEntity();                /**                 * 通过EntityUitls获取返回内容                 */                String result = EntityUtils.toString(entity,&quot;UTF-8&quot;);                /**                 * 转换成json,根据合法性返回json或者字符串                 */                try&#123;                    jsonObject = JSONObject.parseObject(result);                    return jsonObject;                &#125;catch (Exception e)&#123;                    return result;                &#125;            &#125;else&#123;                LOGGER.error(&quot;HttpClientService-line: &#123;&#125;, errorMsg&#123;&#125;&quot;, 97, &quot;GET请求失败！&quot;);            &#125;        &#125;catch (Exception e)&#123;            LOGGER.error(&quot;HttpClientService-line: &#123;&#125;, Exception: &#123;&#125;&quot;, 100, e);        &#125; finally &#123;            response.close();            client.close();        &#125;        return null;    &#125;    /**     * 发送POST请求     * @param url     * @param nameValuePairList     * @return JSON或者字符串     * @throws Exception     */    public static Object sendPost(String url, List&lt;NameValuePair&gt; nameValuePairList) throws Exception&#123;        JSONObject jsonObject = null;        CloseableHttpClient client = null;        CloseableHttpResponse response = null;        try&#123;            /**             *  创建一个httpclient对象             */            client = HttpClients.createDefault();            /**             * 创建一个post对象             */            HttpPost post = new HttpPost(url);            /**             * 包装成一个Entity对象             */            StringEntity entity = new UrlEncodedFormEntity(nameValuePairList, &quot;UTF-8&quot;);            /**             * 设置请求的内容             */            post.setEntity(entity);            /**             * 设置请求的报文头部的编码             */            post.setHeader(new BasicHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded; charset=utf-8&quot;));            /**             * 设置请求的报文头部的编码             */            post.setHeader(new BasicHeader(&quot;Accept&quot;, &quot;text/plain;charset=utf-8&quot;));            /**             * 执行post请求             */            response = client.execute(post);            /**             * 获取响应码             */            int statusCode = response.getStatusLine().getStatusCode();            if (SUCCESS_CODE == statusCode)&#123;                /**                 * 通过EntityUitls获取返回内容                 */                String result = EntityUtils.toString(response.getEntity(),&quot;UTF-8&quot;);                /**                 * 转换成json,根据合法性返回json或者字符串                 */                try&#123;                    jsonObject = JSONObject.parseObject(result);                    return jsonObject;                &#125;catch (Exception e)&#123;                    return result;                &#125;            &#125;else&#123;                LOGGER.error(&quot;HttpClientService-line: &#123;&#125;, errorMsg：&#123;&#125;&quot;, 146, &quot;POST请求失败！&quot;);            &#125;        &#125;catch (Exception e)&#123;            LOGGER.error(&quot;HttpClientService-line: &#123;&#125;, Exception：&#123;&#125;&quot;, 149, e);        &#125;finally &#123;            response.close();            client.close();        &#125;        return null;    &#125;    /**     * 组织请求参数&#123;参数名和参数值下标保持一致&#125;     * @param params    参数名数组     * @param values    参数值数组     * @return 参数对象     */    public static List&lt;NameValuePair&gt; getParams(Object[] params, Object[] values)&#123;        /**         * 校验参数合法性         */        boolean flag = params.length&gt;0 &amp;&amp; values.length&gt;0 &amp;&amp;  params.length == values.length;        if (flag)&#123;            List&lt;NameValuePair&gt; nameValuePairList = new ArrayList&lt;NameValuePair&gt;();            for(int i =0; i&lt;params.length; i++)&#123;                nameValuePairList.add(new BasicNameValuePair(params[i].toString(),values[i].toString()));            &#125;            return nameValuePairList;        &#125;else&#123;            LOGGER.error(&quot;HttpClientService-line: &#123;&#125;, errorMsg：&#123;&#125;&quot;, 197, &quot;请求参数为空且参数长度不一致&quot;);        &#125;        return null;    &#125;&#125;","categories":["工具类"],"tags":["httpclient"]},{"title":"linux常用命令","url":"https://www.mele.cool/2020/12/04/Linux常用命令/","content":"展示# 友好展示信息ll -h# 展示指定目录的文件ll -h /etc#切换到上次访问目录,只能最后两个目录间切换cd -\n新建文件夹#创建多层目录mkdir /t1/t2# t3目录不存在的话则先创建t3mkdir -p t3/t4\n\n\n端口\nnetstat -an          #查看本机启用的端口\n\n\nnetstat -tuln    #查看本机开了哪些端口和正在被远程调用的调用方ipnetstat -tuln    查看本机开了哪些端口和正在被远程调用的调用方ip\n\n\ntelnet [域名或ip] [端口]    #远程管理与端口探测命令 eg:telnet 192.168.0.252 80    #探测服务器80端口,成功的话没有提示,进入空白页,退出摁ctrl+],退回到telnet界面,输入quit命令退出\n\n#1、开放端口firewall-cmd --zone=public --add-port=5672/tcp --permanent   # 开放5672端口firewall-cmd --zone=public --remove-port=5672/tcp --permanent  #关闭5672端口firewall-cmd --reload   # 配置立即生效#2、查看防火墙所有开放的端口firewall-cmd --zone=public --list-ports#3.、关闭防火墙#如果要开放的端口太多，嫌麻烦，可以关闭防火墙，安全性自行评估systemctl stop firewalld.service#4、查看防火墙状态 firewall-cmd --state#5、查看监听的端口netstat -lnpt#PS:centos7默认没有 netstat 命令，需要安装 net-tools 工具，yum install -y net-tools#6、检查端口被哪个进程占用netstat -lnpt |grep 5672# 7 查看进程的详细信息ps 6832\n\n\nJDKjava -verbose #查看jdk安装路径.最后两行为jdk安装路径\n\n\n配置ip,修改网卡信息文件\nvi /etc/sysconfig/network-scripts/ifcfg-etho    \n\n后台启动jar并把日志输出到指定文件中(启动springboot项目)nohup java -jar my-blog.jar &gt; mylog.txt  &amp; nohup java -jar my-blog.jar &gt; catalina.out 2&gt;&amp;1 &amp;\n\n\n\n查看系统是32位或64位\ngetconf LONG_BIT  \n\n复制解压压缩包格式:\n\n*.tar     打包,不压缩.\n*.tar.gz 打包并压缩\n\ncp -r 源文件夹 目的地  #Linux复制文件夹,-r表示递归cp 文件 新目录/新文件名 #复制并改名#压缩 -zcvf参数顺序不能变.eg压缩当前目录下全部文件:tar -zcvf hehe.tar.gz *tar -zcvf 压缩包名字.tar.gz 需压缩的文件#解压缩到当前目录tar -zxvf 压缩包名#解压缩到指定目录tar -zxvf 压缩包名 -C 指定目录地址\n查看服务器DNS信息:\n   1.cat /etc/resolv.conf\n   2.nslookup 127.0.0.1 | grep Server\n修改DNS服务器非常简单，只需要修改/etc/resolv.conf配置文件即可。那么修改DNS是否需要重启某些服务，答案是不需要。修改后会立即生效，不需做任何额外处理。\n\nping：测试网络命令\n  -c count：ping的次数\n-W timeout：超时时间，配合-c使用\n-I ipaddress：指定用自己主机的IP去ping对方主机\n-s size：每次ping发出的数据包大小，最大值65507\n-f：竭尽自己主机的能力发出数据包\n\n\n[root@centos7 ~]# ping -c1 -W1 192.168.0.6 #脚本中常用的ping测试，ping一次，超时时间1s[root@centos7 ~]# ping -s 65507 -f 192.168.0.6 #竭尽自己所能，向192.168.0.6发出大数据包，ddos攻击\nlinux查找文件:find / -name httpd.conf　　#在根目录下查找文件httpd.conf，表示在整个硬盘查找find /etc -name httpd.conf　　#在/etc目录下文件httpd.conffind /etc -name &#x27;*srm*&#x27;　　#使用通配符*(0或者任意多个)。表示在/etc目录下查找文件名中含有字符串‘srm’的文件find . -name &#x27;srm*&#x27; 　　#表示当前目录下查找文件名开头是字符串‘srm’的文件sudo find / -type d -name *tomcat*  #查找文件夹位置,文件夹名字不确定的用*补上\n\n\nLinux显示主机名:hostname        #显示完整名字hostname -s \t  #显示短格式名字hostname -a\t    #显示主机别名hostname -i\t    #显示主机ip\n\n\n查看DNS服务器地址:\ncat /etc/resolv.conf\n\n命令行登陆linux服务器:\nssh -p22 用户名@ip如果不输用户名,则以当前用户名登陆linux服务器,第一次连接会下载服务器公钥,选yes.\n\n上传下载:\nscp [r] 用户名@ip:文件路径 本地路径 #下载文件 -r表示下载文件夹\n\n\nscp [r] 本地文件 用户名@ip:上传路径 #上传文件 -r表示上传文件夹\n\n\nwget http://soft.vpser.net/Inmp/Inmp1.1-full.tar.gz   #下载命令\n\ncrl软件按:alt p\n浏览文件内容\ncat 文件名\n适合查看数据量小的文件,全部展示.\n\nmore 文件名\n分页显示文件内容\n空格:下一页    回车:下一行    ctrl+b:上一屏     q:退出\n\nless 文件名\n分页查看文件内容.操作同more.\n标注行号:less -mN 文件名\n\ntail -20 文件名\n快速查看文件最后20行内容.\n\nVim 文件名\n输入 : set nu,会显示行号.\n\n\ngrep和管道| 是管道符号,可连接不同命令\ngrep是正则表达式,用于字符串搜索.格式:grep 字符串 搜索的文件,eg:ll | grep aaa\n系统相关#查看系统进程ps -ef#重启reboot#关机halt#网络设置setup#开启某端口防火墙firewall-cmd --permanent --zone=public --add-port=7006/tcp --permanent\n文件权限- RWX RW- R--1  2   3   4# 1:类型,d目录,-普通文件,l链接文件# 2:所属用户权限,用u(user)表示# 3:所属组权限,用g(group)表示# 4:其他用户权限,用o(other)表示# 所有权限,用a(all)表示#修改权限chmod u=rwx demo.javachmod g=rw- demo.javachmod a=rwx demo.java#更改文件夹权限chmod -R 权限 文件夹名#增加执行权限chmod +X demo.java\n安装与卸载\nrpm命令相当于windows下的添加/卸载程序.\nyum命令相当于带联网功能的rpm.\n\n#程序安装rpm -ivh 程序名#程序查看rpm -qa#程序卸载rpm -e --nodeps 程序名\n安装JDK\n安装依赖\n\nyum install glibc.i686yum -y install libaio.so.1 libgcc_s.so.1 libstdc++.so.6yum update libstdc++-4.4.7-4.e16.x86-64yum install gcc-c++\n\n安装jdk\n\n# 1 查看已安装老版本rpm -qa | grep java# 2 卸载老版本rpm -e --nodeps 上面查到的# 3 上传jdk包,解压到指定目录tar -zxvf -C /usr/local/java# 4 配置环境变量 vim /etc/profileJAVA_HOME=/usr/local/java/jdk...CLASS_PATH=.:$JAVA_HOME/lib.tools.jarPATH=$JAVA_HOME/bin:$PATHexport JAVA_HONE CLASSPATH PATH# 5 重新加载配置文件source /etc/profile\n","categories":["linux"],"tags":["linux"]},{"title":"mac常用命令","url":"https://www.mele.cool/2020/12/04/MAC电脑常用命令/","content":"\n显示隐藏文件、文件夹：Command+Shift+.      \n\n最小化全部应用: Command+Option+H+M\n\n显示、隐藏程序坞： command+option+d  \n\n设置启动台图标大小： defaults write com.apple.dock springboard-columns -int 10  10代表一行显示10个图标 设置完重启dock：killall Dock\n\n调出”强制退出应用”窗口: command+option+esc\n\n全屏: command+ctrl+d\n\n查看本机ip: ifconfig | grep &quot;inet&quot;\n\n\n","categories":["mac"],"tags":["mac"]},{"title":"mybatis","url":"https://www.mele.cool/2020/12/04/Mybatis/","content":"1.Mybatis简介1.1原始jdbc操作（查询数据）![image-20200912201734197](/Users/boguotong/Library/Application Support/typora-user-images/image-20200912201734197.png)\n1.2原始jdbc操作（插⼊数据）![image-20200912201752789](/Users/boguotong/Library/Application Support/typora-user-images/image-20200912201752789.png)\n1.3 原始jdbc操作的分析原始jdbc开发存在的问题如下：\n\n\n数据库连接创建、释放频繁造成系统资源浪费从⽽影响系统性能\nsql 语句在代码中硬编码，造成代码不易维护，实际应⽤ sql 变化的可能较⼤，sql 变动需要改变java代码。\n查询操作时，需要⼿动将结果集中的数据⼿动封装到实体中。插⼊操作时，需要⼿动将实体的数据设置到sql语句的占位符位置\n\n\n应对上述问题给出的解决⽅案：\n\n\n使⽤数据库连接池初始化连接资源\n将sql语句抽取到xml配置⽂件中\n使⽤反射、内省等底层技术，⾃动将实体与表进⾏属性与字段的⾃动映射\n\n\n1.4 什么是Mybatis\nmybatis 是⼀个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，⽽不需要花费精⼒去处理加载驱动、创建连接、创建statement等繁杂的过程。\nmybatis通过xml或注解的⽅式将要执⾏的各种 statement配置起来，并通过java对象和statement中sql的动态参数进⾏映射⽣成最终执⾏的sql语句。\n最后mybatis框架执⾏sql并将结果映射为java对象并返回。采⽤ORM思想解决了实体和数据库映射的问题，对jdbc 进⾏封装，屏蔽了jdbc api 底层访问细节，使我们不⽤与jdbc api 打交道，就可以完成对数据库的持久化操作。\n\n2.Mybatis的快速⼊⻔2.1 MyBatis开发步骤\nMyBatis官⽹地址：http://www.mybatis.org/mybatis-3/\n\n\n添加MyBatis的依赖坐标\n创建user数据表\n编写User实体类\n编写映射⽂件UserMapper.xml\n编写核⼼⽂件SqlMapConfifig.xml\n编写测试类\n\n2.2 环境搭建1)导⼊MyBatis的坐标和其他相关坐标&lt;!--mybatis坐标--&gt;&lt;dependency&gt;     &lt;groupId&gt;org.mybatis&lt;/groupId&gt;     &lt;artifactId&gt;mybatis&lt;/artifactId&gt;     &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql驱动坐标--&gt;&lt;dependency&gt;     &lt;groupId&gt;mysql&lt;/groupId&gt;     &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;     &lt;version&gt;5.1.6&lt;/version&gt;     &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--单元测试坐标--&gt;&lt;dependency&gt;     &lt;groupId&gt;junit&lt;/groupId&gt;     &lt;artifactId&gt;junit&lt;/artifactId&gt;     &lt;version&gt;4.12&lt;/version&gt;     &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--⽇志坐标--&gt;&lt;dependency&gt;     &lt;groupId&gt;log4j&lt;/groupId&gt;     &lt;artifactId&gt;log4j&lt;/artifactId&gt;     &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt;\n\n\n2) 创建user数据表![image-20200912202818749](/Users/boguotong/Library/Application Support/typora-user-images/image-20200912202818749.png)\n3) 编写User实体public class User &#123;       private int id;       private String username;       private String password;      //省略get个set⽅法&#125;\n\n\n4)编写UserMapper映射⽂件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;userMapper&quot;&gt;     &lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt;        select * from User     &lt;/select&gt;&lt;/mapper&gt;\n\n\n5) 编写MyBatis核⼼⽂件&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN“&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;     &lt;environments default=&quot;development&quot;&gt;         &lt;environment id=&quot;development&quot;&gt;         \t\t&lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                 &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///test&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;     &lt;mappers&gt;    \t\t &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n\n2.3 编写测试代码//加载核⼼配置⽂件InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);//获得sqlSession⼯⼚对象SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);//获得sqlSession对象SqlSession sqlSession = sqlSessionFactory.openSession();//执⾏sql语句List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);//打印结果System.out.println(userList);//释放资源sqlSession.close();\n3. MyBatis的映射⽂件概述![image-20200912203231052](/Users/boguotong/Library/Application Support/typora-user-images/image-20200912203231052.png)\n4. MyBatis的增删改查操作4.1 MyBatis的插⼊数据操作1)**编写UserMapper**映射⽂件&lt;mapper namespace=&quot;userMapper&quot;&gt;     &lt;insert id=&quot;add&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt;    \t\tinsert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)     &lt;/insert&gt;&lt;/mapper&gt;\n2)**编写插⼊实体User**的代码InputStream resourceAsStream =Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = newSqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int insert = sqlSession.insert(&quot;userMapper.add&quot;, user);System.out.println(insert);//提交事务sqlSession.commit();sqlSession.close();\n\n\n**3)**插⼊操作注意问题\n插⼊语句使⽤insert标签\n在映射⽂件中使⽤parameterType属性指定要插⼊的数据类型\nSql语句中使⽤#{实体属性名}⽅式引⽤实体中的属性值\n插⼊操作使⽤的API是sqlSession.insert(“命名空间.id”,实体对象);\n插⼊操作涉及数据库数据变化，所以要使⽤sqlSession对象显示的提交事务，即sqlSession.commit()\n\n4.2 MyBatis的修改数据操作1)**编写UserMapper**映射⽂件&lt;mapper namespace=&quot;userMapper&quot;&gt;     &lt;update id=&quot;update&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt;     \t\tupdate user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;    &lt;/update&gt;&lt;/mapper&gt;\n\n\n2)**编写修改实体User**的代码InputStream resourceAsStream =Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = newSqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int update = sqlSession.update(&quot;userMapper.update&quot;, user);System.out.println(update);sqlSession.commit();sqlSession.close();\n\n\n**3)**修改操作注意问题\n• 修改语句使⽤update标签\n• 修改操作使⽤的API是sqlSession.update(“命名空间.id”,实体对象);\n\n4.3 MyBatis的删除数据操作1)**编写UserMapper**映射⽂件&lt;mapper namespace=&quot;userMapper&quot;&gt;     &lt;delete id=&quot;delete&quot; parameterType=&quot;java.lang.Integer&quot;&gt;     \t\tdelete from user where id=#&#123;id&#125;    &lt;/delete&gt;&lt;/mapper&gt;\n\n\n**2)**编写删除数据的代码InputStream resourceAsStream =Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = newSqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int delete = sqlSession.delete(&quot;userMapper.delete&quot;,3);System.out.println(delete);sqlSession.commit();sqlSession.close();\n\n\n**3)**删除操作注意问题\n删除语句使⽤delete标签\nSql语句中使⽤#{任意字符串}⽅式引⽤传递的单个参数\n删除操作使⽤的API是sqlSession.delete(“命名空间.id”,Object);\n\n4.4 知识⼩结增删改查映射配置与API：查询数据： List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);&lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt;\t\tselect * from User&lt;/select&gt;添加数据： sqlSession.insert(&quot;userMapper.add&quot;, user);&lt;insert id=&quot;add&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt;\t\tinsert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)&lt;/insert&gt;修改数据： sqlSession.update(&quot;userMapper.update&quot;, user);&lt;update id=&quot;update&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt;\t\tupdate user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=# &#123;id&#125;&lt;/update&gt;删除数据：sqlSession.delete(&quot;userMapper.delete&quot;,3);&lt;delete id=&quot;delete&quot; parameterType=&quot;java.lang.Integer&quot;&gt;\t\tdelete from user where id=#&#123;id&#125;&lt;/delete&gt;\n\n\n5. MyBatis核⼼配置⽂件概述5.1 MyBatis核⼼配置⽂件层级关系![image-20200912203616928](/Users/boguotong/Library/Application Support/typora-user-images/image-20200912203616928.png)\n5.2 MyBatis常⽤配置解析1)environments标签数据库环境的配置，⽀持多环境配置![image-20200912203646992](/Users/boguotong/Library/Application Support/typora-user-images/image-20200912203646992.png)其中，事务管理器（transactionManager）类型有两种：\n\nJDBC：这个配置就是直接使⽤了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作⽤域。\nMANAGED：这个配置⼏乎没做什么。它从来不提交或回滚⼀个连接，⽽是让容器来管理事务的整个⽣命周期（⽐如 JEE 应⽤服务器的上下⽂）。 默认情况下它会关闭连接，然⽽⼀些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻⽌它默认的关闭⾏为。\n\n其中，数据源（dataSource）类型有三种：\n\nUNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。\nPOOLED：这种数据源的实现利⽤“池”的概念将 JDBC 连接对象组织起来。\nJNDI：这个数据源的实现是为了能在如 EJB 或应⽤服务器这类容器中使⽤，容器可以集中或在外部配置数据源，然后放置⼀个 JNDI 上下⽂的引⽤。\n\n2)mapper标签该标签的作⽤是加载映射的，加载⽅式有如下⼏种：\n•使⽤相对于类路径的资源引⽤，例如：\n•使⽤完全限定资源定位符（URL），例如：\n•使⽤映射器接⼝实现类的完全限定类名，例如：\n•将包内的映射器接⼝实现全部注册为映射器，例如：\n3)Properties标签实际开发中，习惯将数据源的配置信息单独抽取成⼀个properties⽂件，该标签可以加载额外配置的\nproperties⽂件![image-20200912203835849](/Users/boguotong/Library/Application Support/typora-user-images/image-20200912203835849.png)\n4)typeAliases标签类型别名是为Java 类型设置⼀个短的名字。原来的类型名称配置如下\n![image-20200912203935416](/Users/boguotong/Library/Application Support/typora-user-images/image-20200912203935416.png)\n配置typeAliases，为com.itheima.domain.User定义别名为user\n![image-20200912203947722](/Users/boguotong/Library/Application Support/typora-user-images/image-20200912203947722.png)\n上⾯我们是⾃定义的别名，mybatis框架已经为我们设置好的⼀些常⽤的类型的别名\n![image-20200912204004237](/Users/boguotong/Library/Application Support/typora-user-images/image-20200912204004237.png)\n6.MyBatis相应API6.1 SqlSession⼯⼚构建器SqlSessionFactoryBuilder常⽤API：SqlSessionFactory build(InputStream inputStream)\n通过加载mybatis的核⼼⽂件的输⼊流的形式构建⼀个SqlSessionFactory对象\nString resource = &quot;org/mybatis/builder/mybatis-config.xml&quot;;InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();SqlSessionFactory factory = builder.build(inputStream);\n其中， Resources ⼯具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、⽂\n件系统或⼀个 web URL 中加载资源⽂件。\n6.2 SqlSession⼯⼚对象SqlSessionFactorySqlSessionFactory 有多个个⽅法创建SqlSession 实例。常⽤的有如下两个：\n![image-20200912204118454](/Users/boguotong/Library/Application Support/typora-user-images/image-20200912204118454.png)\n6.3 SqlSession会话对象SqlSession 实例在 MyBatis 中是⾮常强⼤的⼀个类。在这⾥你会看到所有执⾏语句、提交或回滚事务\n和获取映射器实例的⽅法。执⾏语句的⽅法主要有：\n&lt;T&gt; T selectOne(String statement, Object parameter) &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter)int insert(String statement, Object parameter)int update(String statement, Object parameter)int delete(String statement, Object parameter)\n操作事务的⽅法主要有：\nvoid commit() void rollback()\n####\n","categories":["java"],"tags":["mybatis"]},{"title":"Spring Boot 中的异步调用","url":"https://www.mele.cool/2020/12/04/Spring Boot 中的异步调用/","content":"通常我们开发的程序都是同步调用的，即程序按照代码的顺序一行一行的逐步往下执行，每一行代码都必须等待上一行代码执行完毕才能开始执行。而异步编程则没有这个限制，代码的调用不再是阻塞的。所以在一些情景下，通过异步编程可以提高效率，提升接口的吞吐量。这节将介绍如何在Spring Boot中进行异步编程。\n开启异步新建一个Spring Boot项目，版本为2.1.0.RELEASE，并引入spring-boot-starter-web依赖，项目结构如下所示：\n\n要开启异步支持，首先得在Spring Boot入口类上加上@EnableAsync注解：\n@SpringBootApplication@EnableAsyncpublic class DemoApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DemoApplication.class, args);    &#125;&#125;\n\n\n接下来开始编写异步方法。\n在com.example.demo路径下新建service包，并创建TestService：\n@Servicepublic class TestService &#123;    private Logger logger = LoggerFactory.getLogger(this.getClass());    @Async    public void asyncMethod() &#123;        sleep();        logger.info(&quot;异步方法内部线程名称：&#123;&#125;&quot;, Thread.currentThread().getName());    &#125;    public void syncMethod() &#123;        sleep();    &#125;    private void sleep() &#123;        try &#123;            TimeUnit.SECONDS.sleep(2);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n\n上面的Service中包含一个异步方法asyncMethod（开启异步支持后，只需要在方法上加上@Async注解便是异步方法了）和同步方法syncMethod。sleep方法用于让当前线程阻塞2秒钟。\n接着在com.example.demo路径下新建controller包，然后创建TestController：\n@RestControllerpublic class TestController &#123;    private Logger logger = LoggerFactory.getLogger(this.getClass());    @Autowired    private TestService testService;    @GetMapping(&quot;async&quot;)    public void testAsync() &#123;        long start = System.currentTimeMillis();        logger.info(&quot;异步方法开始&quot;);        testService.asyncMethod();        logger.info(&quot;异步方法结束&quot;);        long end = System.currentTimeMillis();        logger.info(&quot;总耗时：&#123;&#125; ms&quot;, end - start);    &#125;    @GetMapping(&quot;sync&quot;)    public void testSync() &#123;        long start = System.currentTimeMillis();        logger.info(&quot;同步方法开始&quot;);        testService.syncMethod();        logger.info(&quot;同步方法结束&quot;);        long end = System.currentTimeMillis();        logger.info(&quot;总耗时：&#123;&#125; ms&quot;, end - start);    &#125;&#125;\n\n\n启动项目，访问 http://localhost:8080/sync 请求，控制台输出如下：\n\n可看到默认程序是同步的，由于sleep方法阻塞的原因，testSync方法执行了2秒钟以上。\n访问 http://localhost:8080/async ，控制台输出如下：\n\n可看到testAsync方法耗时极少，因为异步的原因，程序并没有被sleep方法阻塞，这就是异步调用的好处。同时异步方法内部会新启一个线程来执行，这里线程名称为task - 1。\n默认情况下的异步线程池配置使得线程不能被重用，每次调用异步方法都会新建一个线程，我们可以自己定义异步线程池来优化。\n自定义异步线程池在com.example.demo下新建config包，然后创建AsyncPoolConfig配置类：\n@Configurationpublic class AsyncPoolConfig &#123;    @Bean    public ThreadPoolTaskExecutor asyncThreadPoolTaskExecutor()&#123;        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();        executor.setCorePoolSize(20);        executor.setMaxPoolSize(200);        executor.setQueueCapacity(25);        executor.setKeepAliveSeconds(200);        executor.setThreadNamePrefix(&quot;asyncThread&quot;);        executor.setWaitForTasksToCompleteOnShutdown(true);        executor.setAwaitTerminationSeconds(60);        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());        executor.initialize();        return executor;    &#125;&#125;\n上面我们通过ThreadPoolTaskExecutor的一些方法自定义了一个线程池，这些方法的含义如下所示：\n\ncorePoolSize：线程池核心线程的数量，默认值为1（这就是默认情况下的异步线程池配置使得线程不能被重用的原因）。\n\nmaxPoolSize：线程池维护的线程的最大数量，只有当核心线程都被用完并且缓冲队列满后，才会开始申超过请核心线程数的线程，默认值为Integer.MAX_VALUE。\n\nqueueCapacity：缓冲队列。\n\nkeepAliveSeconds：超出核心线程数外的线程在空闲时候的最大存活时间，默认为60秒。\n\nthreadNamePrefix：线程名前缀。\n\nwaitForTasksToCompleteOnShutdown：是否等待所有线程执行完毕才关闭线程池，默认值为false。\n\nawaitTerminationSeconds：waitForTasksToCompleteOnShutdown的等待的时长，默认值为0，即不等待。\n\nrejectedExecutionHandler：当没有线程可以被使用时的处理策略（拒绝任务），默认策略为abortPolicy，包含下面四种策略：\n\n\ncallerRunsPolicy：用于被拒绝任务的处理程序，它直接在 execute 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务。\nabortPolicy：直接抛出java.util.concurrent.RejectedExecutionException异常。\ndiscardOldestPolicy：当线程池中的数量等于最大线程数时、抛弃线程池中最后一个要执行的任务，并执行新传入的任务。\ndiscardPolicy：当线程池中的数量等于最大线程数时，不做任何动作。\n\n\n\n要使用该线程池，只需要在@Async注解上指定线程池Bean名称即可：\n@Servicepublic class TestService &#123;    ......    @Async(&quot;asyncThreadPoolTaskExecutor&quot;)    public void asyncMethod() &#123;       ......    &#125;    ......&#125;\n重启项目，再次访问 http://localhost:8080/async ，控制台输出入下：\n\n处理异步回调如果异步方法具有返回值的话，需要使用Future来接收回调值。我们修改TestService的asyncMethod方法，给其添加返回值：\n@Async(&quot;asyncThreadPoolTaskExecutor&quot;)public Future&lt;String&gt; asyncMethod() &#123;    sleep();    logger.info(&quot;异步方法内部线程名称：&#123;&#125;&quot;, Thread.currentThread().getName());    return new AsyncResult&lt;&gt;(&quot;hello async&quot;);&#125;\n\n\n泛型指定返回值的类型，AsyncResult为Spring实现的Future实现类：\n\n接着改造TestController的testAsync方法：\n@GetMapping(&quot;async&quot;)public String testAsync() throws Exception &#123;    long start = System.currentTimeMillis();    logger.info(&quot;异步方法开始&quot;);    Future&lt;String&gt; stringFuture = testService.asyncMethod();    String result = stringFuture.get();    logger.info(&quot;异步方法返回值：&#123;&#125;&quot;, result);        logger.info(&quot;异步方法结束&quot;);    long end = System.currentTimeMillis();    logger.info(&quot;总耗时：&#123;&#125; ms&quot;, end - start);    return stringFuture.get();&#125;\n\n\nFuture接口的get方法用于获取异步调用的返回值。\n重启项目，访问 http://localhost:8080/async 控制台输出如下所示:\n\n通过返回结果我们可以看出Future的get方法为阻塞方法，只有当异步方法返回内容了，程序才会继续往下执行。get还有一个get(long timeout, TimeUnit unit)重载方法，我们可以通过这个重载方法设置超时时间，即异步方法在设定时间内没有返回值的话，直接抛出java.util.concurrent.TimeoutException异常。\n比如设置超时时间为60秒：\nString result = stringFuture.get(60, TimeUnit.SECONDS);\n\n源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/49.Spring-Boot-Async\nFROM:https://mrbird.cc/Spring-Boot-Async.html\n\n","categories":["springboot"],"tags":["springboot","异步调用"]},{"title":"Spring Boot中使用MyBatis","url":"https://www.mele.cool/2020/12/04/Spring Boot中使用MyBatis/","content":"引入依赖:mybatis-spring-boot-starter在pom中引入：\n&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;\n\n\n不同版本的Spring Boot和MyBatis版本对应不一样，具体可查看官方文档：http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/。\n通过dependency:tree命令查看mybatis-spring-boot-starter都有哪些隐性依赖：\n+- org.mybatis.spring.boot:mybatis-spring-boot-starter:jar:1.3.1:compile|  +- org.springframework.boot:spring-boot-starter-jdbc:jar:1.5.9.RELEASE:compile|  |  +- org.apache.tomcat:tomcat-jdbc:jar:8.5.23:compile|  |  |  \\- org.apache.tomcat:tomcat-juli:jar:8.5.23:compile|  |  \\- org.springframework:spring-jdbc:jar:4.3.13.RELEASE:compile|  |     \\- org.springframework:spring-tx:jar:4.3.13.RELEASE:compile|  +- org.mybatis.spring.boot:mybatis-spring-boot-autoconfigure:jar:1.3.1:compile|  +- org.mybatis:mybatis:jar:3.4.5:compile|  \\- org.mybatis:mybatis-spring:jar:1.3.1:compile\n\n\n可发现其包含了spring-boot-starter-jdbc依赖，默认使用tomcat-jdbc数据源。\n引入ojdbc6由于版权的原因，我们需要将ojdbc6.jar依赖安装到本地的maven仓库，然后才可以在pom中进行配置。\n下载ojdbc6.jar文件后，将其放到比较好找的目录下，比如D盘根目录。然后运行以下命令：\nC:\\Users\\Administrator&gt;mvn install:install-file -Dfile&#x3D;D:&#x2F;ojdbc6.jar -DgroupId&#x3D;com.oracle -DartifactId&#x3D;ojdbc6 -Dversion&#x3D;6.0 -Dpackaging&#x3D;jar -DgeneratePom&#x3D;true...[INFO] --- maven-install-plugin:2.4:install-file (default-cli) @ standalone-pom ---[INFO] Installing D:\\ojdbc6.jar to D:\\m2\\repository\\com\\oracle\\ojdbc6\\6.0\\ojdbc6-6.0.jar[INFO] Installing C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\mvninstall9103688544010617483.pom to D:\\m2\\repository\\com\\oracle\\ojdbc6\\6.0\\ojdbc6-6.0.pom[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 0.940 s[INFO] Finished at: 2017-08-13T15:06:38+08:00[INFO] Final Memory: 6M&#x2F;145M[INFO] ------------------------------------------------------------------------\n\n\n接着在pom中引入：\n&lt;dependency&gt;    &lt;groupId&gt;com.oracle&lt;/groupId&gt;    &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt;    &lt;version&gt;6.0&lt;/version&gt;&lt;/dependency&gt;\n\n\n这里的groupid就是你之前安装时指定的-Dgroupid的值，artifactid就是你安装时指定的-Dartifactid的值，version也一样。\nDruid数据源Druid是一个关系型数据库连接池，是阿里巴巴的一个开源项目，地址：https://github.com/alibaba/druid。Druid不但提供连接池的功能，还提供监控功能，可以实时查看数据库连接池和SQL查询的工作情况。\n配置Druid依赖Druid为Spring Boot项目提供了对应的starter：\n&lt;dependency&gt;   &lt;groupId&gt;com.alibaba&lt;/groupId&gt;   &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;   &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;\n\n\nDruid数据源配置上面通过查看mybatis starter的隐性依赖发现，Spring Boot的数据源配置的默认类型是org.apache.tomcat.jdbc.pool.Datasource，为了使用Druid连接池，需要在application.yml下配置：\nserver:  context-path: /webspring:  datasource:    druid:      # 数据库访问配置, 使用druid数据源      type: com.alibaba.druid.pool.DruidDataSource      driver-class-name: oracle.jdbc.driver.OracleDriver      url: jdbc:oracle:thin:@localhost:1521:ORCL      username: scott      password: 123456      # 连接池配置      initial-size: 5      min-idle: 5      max-active: 20      # 连接等待超时时间      max-wait: 30000      # 配置检测可以关闭的空闲连接间隔时间      time-between-eviction-runs-millis: 60000      # 配置连接在池中的最小生存时间      min-evictable-idle-time-millis: 300000      validation-query: select &#x27;1&#x27; from dual      test-while-idle: true      test-on-borrow: false      test-on-return: false      # 打开PSCache，并且指定每个连接上PSCache的大小      pool-prepared-statements: true      max-open-prepared-statements: 20      max-pool-prepared-statement-per-connection-size: 20      # 配置监控统计拦截的filters, 去掉后监控界面sql无法统计, &#x27;wall&#x27;用于防火墙      filters: stat,wall      # Spring监控AOP切入点，如x.y.z.service.*,配置多个英文逗号分隔      aop-patterns: com.springboot.servie.*                # WebStatFilter配置      web-stat-filter:        enabled: true        # 添加过滤规则        url-pattern: /*        # 忽略过滤的格式        exclusions: &#x27;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&#x27;            # StatViewServlet配置       stat-view-servlet:        enabled: true        # 访问路径为/druid时，跳转到StatViewServlet        url-pattern: /druid/*        # 是否能够重置数据        reset-enable: false        # 需要账号密码才能访问控制台        login-username: druid        login-password: druid123        # IP白名单        # allow: 127.0.0.1        #　IP黑名单（共同存在时，deny优先于allow）        # deny: 192.168.1.218            # 配置StatFilter      filter:         stat:           log-slow-sql: true\n\n\n上述配置不但配置了Druid作为连接池，而且还开启了Druid的监控功能。 其他配置可参考官方wiki——https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter\n此时，运行项目，访问http://localhost:8080/web/druid：\n\n输入账号密码即可看到Druid监控后台：\n\n关于Druid的更多说明，可查看官方wiki——https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98\n使用MyBatis使用的库表：\nCREATE TABLE &quot;SCOTT&quot;.&quot;STUDENT&quot; (    &quot;SNO&quot; VARCHAR2(3 BYTE) NOT NULL ,    &quot;SNAME&quot; VARCHAR2(9 BYTE) NOT NULL ,    &quot;SSEX&quot; CHAR(2 BYTE) NOT NULL );INSERT INTO &quot;SCOTT&quot;.&quot;STUDENT&quot; VALUES (&#x27;001&#x27;, &#x27;KangKang&#x27;, &#x27;M &#x27;);INSERT INTO &quot;SCOTT&quot;.&quot;STUDENT&quot; VALUES (&#x27;002&#x27;, &#x27;Mike&#x27;, &#x27;M &#x27;);INSERT INTO &quot;SCOTT&quot;.&quot;STUDENT&quot; VALUES (&#x27;003&#x27;, &#x27;Jane&#x27;, &#x27;F &#x27;);\n\n\n创建对应实体：\npublic class Student implements Serializable&#123;    private static final long serialVersionUID = -339516038496531943L;    private String sno;    private String name;    private String sex;    // get,set略&#125;\n\n\n创建一个包含基本CRUD的StudentMapper：\npublic interface StudentMapper &#123;    int add(Student student);    int update(Student student);    int deleteByIds(String sno);    Student queryStudentById(Long id);&#125;\n\n\nStudentMapper的实现可以基于xml也可以基于注解。\n使用注解方式继续编辑StudentMapper：\n@Component@Mapperpublic interface StudentMapper &#123;    @Insert(&quot;insert into student(sno,sname,ssex) values(#&#123;sno&#125;,#&#123;name&#125;,#&#123;sex&#125;)&quot;)    int add(Student student);        @Update(&quot;update student set sname=#&#123;name&#125;,ssex=#&#123;sex&#125; where sno=#&#123;sno&#125;&quot;)    int update(Student student);        @Delete(&quot;delete from student where sno=#&#123;sno&#125;&quot;)    int deleteBysno(String sno);        @Select(&quot;select * from student where sno=#&#123;sno&#125;&quot;)    @Results(id = &quot;student&quot;,value= &#123;        @Result(property = &quot;sno&quot;, column = &quot;sno&quot;, javaType = String.class),        @Result(property = &quot;name&quot;, column = &quot;sname&quot;, javaType = String.class),        @Result(property = &quot;sex&quot;, column = &quot;ssex&quot;, javaType = String.class)    &#125;)    Student queryStudentBySno(String sno);\n\n\n简单的语句只需要使用@Insert、@Update、@Delete、@Select这4个注解即可，动态SQL语句需要使用@InsertProvider、@UpdateProvider、@DeleteProvider、@SelectProvider等注解。具体可参考MyBatis官方文档：http://www.mybatis.org/mybatis-3/zh/java-api.html。\n使用xml方式使用xml方式需要在application.yml中进行一些额外的配置：\nmybatis:  # type-aliases扫描路径  # type-aliases-package:  # mapper xml实现扫描路径  mapper-locations: classpath:mapper/*.xml  property:    order: BEFORE\n在resources目录下创建文件夹mapper,下面创建xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mmile.studysb.mapper.StudentMapper&quot;&gt;    &lt;select id=&quot;queryStudentBySno&quot; parameterType=&quot;String&quot; resultType=&quot;com.mmile.studysb.model.Student&quot;&gt;        select * from student where sno = #&#123;sno&#125;    &lt;/select&gt;&lt;/mapper&gt;\n测试接下来编写Service：\npublic interface StudentService &#123;    int add(Student student);    int update(Student student);    int deleteBysno(String sno);    Student queryStudentBySno(String sno);&#125;\n\n\n实现类：\n@Service(&quot;studentService&quot;)public class StudentServiceImp implements StudentService&#123;    @Autowired    private StudentMapper studentMapper;        @Override    public int add(Student student) &#123;        return this.studentMapper.add(student);    &#125;        @Override    public int update(Student student) &#123;        return this.studentMapper.update(student);    &#125;        @Override    public int deleteBysno(String sno) &#123;        return this.studentMapper.deleteBysno(sno);    &#125;        @Override    public Student queryStudentBySno(String sno) &#123;        return this.studentMapper.queryStudentBySno(sno);    &#125;&#125;\n\n\n编写controller：\n@RestControllerpublic class TestController &#123;    @Autowired    private StudentService studentService;        @RequestMapping( value = &quot;/querystudent&quot;, method = RequestMethod.GET)    public Student queryStudentBySno(String sno) &#123;        return this.studentService.queryStudentBySno(sno);    &#125;&#125;\n\n\n完整的项目目录如下图所示：\n\n启动项目访问：http://localhost:8080/web/querystudent?sno=001：\n\n查看SQL监控情况：\n\n可看到其记录的就是刚刚访问/querystudent得到的SQL。\n转自:https://mrbird.cc/Spring-Boot%20Mybatis.html\n","categories":["springboot"],"tags":["mybatis","springboot"]},{"title":"Spring Boot中使用thymeleaf","url":"https://www.mele.cool/2020/12/04/Spring Boot中使用thymeleaf/","content":"Spring Boot支持FreeMarker、Groovy、Thymeleaf和Mustache四种模板解析引擎，官方推荐使用Thymeleaf。\nspring-boot-starter-thymeleaf在Spring Boot中使用Thymeleaf只需在pom中加入Thymeleaf的starter即可：\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n在Spring Boot 1.5.9.RELEASE版本中，默认的Thymeleaf版本为2.1.6.RELEASE版本，这里推荐使用3.0以上版本。在pom中将Thymeleaf的版本修改为3.0.2.RELEASE：\n&lt;properties&gt;    &lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt;    &lt;thymeleaf-layout-dialect.version&gt;2.0.1&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt;\n\n\n\n在Spring Boot中，默认的html页面地址为src/main/resources/templates，默认的静态资源地址为src/main/resources/static。\n\nThymeleaf默认配置在Spring Boot配置文件中可对Thymeleaf的默认配置进行修改：\n#开启模板缓存（默认值：true）spring.thymeleaf.cache=true #Check that the template exists before rendering it.spring.thymeleaf.check-template=true #检查模板位置是否正确（默认值:true）spring.thymeleaf.check-template-location=true#Content-Type的值（默认值：text/html）spring.thymeleaf.content-type=text/html#开启MVC Thymeleaf视图解析（默认值：true）spring.thymeleaf.enabled=true#模板编码spring.thymeleaf.encoding=UTF-8#要被排除在解析之外的视图名称列表，用逗号分隔spring.thymeleaf.excluded-view-names=#要运用于模板之上的模板模式。另见StandardTemplate-ModeHandlers(默认值：HTML5)spring.thymeleaf.mode=HTML5#在构建URL时添加到视图名称前的前缀（默认值：classpath:/templates/）spring.thymeleaf.prefix=classpath:/templates/#在构建URL时添加到视图名称后的后缀（默认值：.html）spring.thymeleaf.suffix=.html#Thymeleaf模板解析器在解析器链中的顺序。默认情况下，它排第一位。顺序从1开始，只有在定义了额外的TemplateResolver Bean时才需要设置这个属性。spring.thymeleaf.template-resolver-order=#可解析的视图名称列表，用逗号分隔spring.thymeleaf.view-names=\n\n\n\n一般开发中将spring.thymeleaf.cache设置为false，其他保持默认值即可。\n\n简单示例编写一个简单的Controller：\n@Controllerpublic class IndexController &#123;\t    @RequestMapping(&quot;/account&quot;)    public String index(Model m) &#123;        List&lt;Account&gt; list = new ArrayList&lt;Account&gt;();        list.add(new Account(&quot;KangKang&quot;, &quot;康康&quot;, &quot;e10adc3949ba59abbe56e&quot;, &quot;超级管理员&quot;, &quot;17777777777&quot;));        list.add(new Account(&quot;Mike&quot;, &quot;麦克&quot;, &quot;e10adc3949ba59abbe56e&quot;, &quot;管理员&quot;, &quot;13444444444&quot;));        list.add(new Account(&quot;Jane&quot;,&quot;简&quot;,&quot;e10adc3949ba59abbe56e&quot;,&quot;运维人员&quot;,&quot;18666666666&quot;));        list.add(new Account(&quot;Maria&quot;, &quot;玛利亚&quot;, &quot;e10adc3949ba59abbe56e&quot;, &quot;清算人员&quot;, &quot;19999999999&quot;));        m.addAttribute(&quot;accountList&quot;,list);        return &quot;account&quot;;    &#125;&#125;\n\n\n编写account.html页面：\n&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;title&gt;account&lt;/title&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;    &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/style.css&#125;&quot; type=&quot;text/css&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;table&gt;        &lt;tr&gt;            &lt;th&gt;no&lt;/th&gt;            &lt;th&gt;account&lt;/th&gt;            &lt;th&gt;name&lt;/th&gt;            &lt;th&gt;password&lt;/th&gt;            &lt;th&gt;accountType&lt;/th&gt;            &lt;th&gt;tel&lt;/th&gt;        &lt;/tr&gt;        &lt;tr th:each=&quot;list,stat : $&#123;accountList&#125;&quot;&gt;            &lt;td th:text=&quot;$&#123;stat.count&#125;&quot;&gt;&lt;/td&gt;            &lt;td th:text=&quot;$&#123;list.account&#125;&quot;&gt;&lt;/td&gt;            &lt;td th:text=&quot;$&#123;list.name&#125;&quot;&gt;&lt;/td&gt;            &lt;td th:text=&quot;$&#123;list.password&#125;&quot;&gt;&lt;/td&gt;            &lt;td th:text=&quot;$&#123;list.accountType&#125;&quot;&gt;&lt;/td&gt;            &lt;td th:text=&quot;$&#123;list.tel&#125;&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n最终项目目录如下所示：\n\n启动项目，访问http://localhost:8080/web/account：\n\n\nFrom: https://mrbird.cc/Spring-Boot%E4%BD%BF%E7%94%A8thymeleaf.html\n","categories":["springboot"],"tags":["springboot","thymeleaf"]},{"title":"md转html","url":"https://www.mele.cool/2020/12/04/Util.md文件转html/","content":"参考:https://guozh.net/commonmark-course-convert-markdown-to-html/\n1.引入依赖\n&lt;!-- commonmark core --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.atlassian.commonmark&lt;/groupId&gt;    &lt;artifactId&gt;commonmark&lt;/artifactId&gt;    &lt;version&gt;0.8.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- commonmark table --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.atlassian.commonmark&lt;/groupId&gt;    &lt;artifactId&gt;commonmark-ext-gfm-tables&lt;/artifactId&gt;    &lt;version&gt;0.8.0&lt;/version&gt;&lt;/dependency&gt;\n2.代码使用\npackage com.site.blog.my.core.util;import org.commonmark.Extension;import org.commonmark.ext.gfm.tables.TablesExtension;import org.commonmark.node.Node;import org.commonmark.parser.Parser;import org.commonmark.renderer.html.HtmlRenderer;import org.springframework.util.StringUtils;import java.util.Arrays;public class MarkDownUtil &#123;    /**     * 转换md格式为html     *     * @param markdownString     * @return     */    public static String mdToHtml(String markdownString) &#123;        if (StringUtils.isEmpty(markdownString)) &#123;            return &quot;&quot;;        &#125;        java.util.List&lt;Extension&gt; extensions = Arrays.asList(TablesExtension.create());        Parser parser = Parser.builder().extensions(extensions).build();        Node document = parser.parse(markdownString);        HtmlRenderer renderer = HtmlRenderer.builder().extensions(extensions).build();        String content = renderer.render(document);        return content;    &#125;&#125;","categories":["工具类"],"tags":["md","markdown","html"]},{"title":"maven","url":"https://www.mele.cool/2020/12/04/maven/","content":"1.作用域:\npom.xml中provided表示此依赖只在代码编译时起作用,运行代码时不起作用,依赖servlet-api/jsp-api可用此标签.\ntest表示只在测试时起作用,junit依赖可加此标签.\n\nscope范围如下:默认是compile:\n\n\n依赖范围\n对于编译classpath有效\n对于测试classpath有效\n对于运行时classpath有效\n例子\n\n\n\ncompile\nY\nY\nY\nspring-core\n\n\ntest\n-\nY\n-\njunit\n\n\nprovided\nY\nY\n-\nservlet-api\n\n\nruntime\n-\nY\nY\njdbc驱动\n\n\nsystem\nY\nY\n-\n本地的maven仓库之外的类库\n\n\n\nIDEA—settings—maven—Runnner—VM Options输入参数:-DarchetypeCatalog=internal,表示无法联网时也可自动加载本地插件功能.推荐加上.2.如何解决依赖冲突1.使用maven提供的依赖调解原则!\n第一声明者优先原则\n\n路径近者优先原则\n\n在pom文件定义依赖,以路径近者为准。例如, spring-aop和spring-webmvc都会传递过来spring-beans,那如果直接把spring-beans的依赖直接写到pom文件中,那么项目就不会再使R其他依赖传递来的spring-beans,因为自己直接在pom中定义spring-beans要比其他依赖传递过来的路径要近。\n\n\n\n2.排除依赖\n3,锁定版本采用直接锁定版本的方法确定依赖jar包的版本,版本锁定后则不考虑依赖的声明顺序或依赖的路径,以锁定的版本为准添加到工程中，此方法在企业开发中经常使用。\n版本锁定的使用方式:第一步：在dependencyManagement标签中锁定依赖的版本\n第二步:在dependencies标签中声明需要导入的maven坐标\n3.分模块构建maven工程**继承和聚合没有关系 :继承是为了消除重复代码,聚合是为了统一操作(打包) \n即使不继承也可以聚合 **\n4.搭建私服1.安装Nexus软件:\n2.将项目发布到maven私服maven私服是搭建在公司局域网内的maven仓库,公司内的所有开发团队都可以使用。例如技术研发团队开发了一个基础组件,就可以将这个基础组件打成jar包发布到私服,其他团队成员就可以从私服下载这个jar包到本地仓库并在项目中使用。将项目发布到maven私服操作步骤下:\n\n配置maven的settings.xml文件\n配置项目的pom.xml文件\n执行mvn deploy 命令\n\n第一步:\n第二步:\n第三步:如果版本是1.0-REALEASE则会上传到release仓库\n3.从私服下载jar到本地仓库.具体操作步骤如下:\n\n在maven的settings.xml文件中配置下载模板\n在maven的settings.xml文件中配置激活下载模板\n\n第一步:配置下载模板\n第二步:激活下载模板\n4.安装第三方jar到本地仓库及私服:1.安装到本地仓库\n2.安装到私服\n","categories":["java"],"tags":["maven"]},{"title":"oracle序列","url":"https://www.mele.cool/2020/12/04/oracle序列/","content":"定义序列(SEQUENCE)是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。不占用磁盘空间，占用内存。\n其主要用途是生成表的主键值，可以在插入语句中引用，也可以通过查询检查当前值，或使序列增至下一个值。\n使用场景:  seq.nextval主要有以下两种使用场景：\n  (1). 如果一个事务中只是INSERT时需要序列，其他地方不会需要这个序列，那么只需要在INSERT … VALUES (seq.nextval …)语句中使用即可。\nINSERT INTO cd_mat_info          (row_id,           mat_code,           plant,           created_by,           last_upd_by)        VALUES          (seq_cd_mat_info.nextval,           #&#123;material_code&#125;,           #&#123;plant_code&#125;,           &#x27;SYS&#x27;,           &#x27;SYS&#x27;);\n  (2). 如果一个事务中INSERT一张表后，还需要插入时的主键ID值，作为外键插入其他表，那么就需要在INSERT第一张表前使用select seq.nextval from dual提前获取可用的ID保存到一个变量中，为后面使用。\n语法:创建序列需要CREATE SEQUENCE系统权限。序列的创建语法如下：\n　　CREATE SEQUENCE 序列名\n　　[INCREMENT BY n]\n　　[START WITH n]\n　　[{MAXVALUE/ MINVALUE n| NOMAXVALUE}]\n　　[{CYCLE|NOCYCLE}]\n　　[{CACHE n| NOCACHE}];\n  其中：\n\nINCREMENT BY用于定义序列的步长，如果省略，则默认为1，如果出现负值，则代表Oracle序列的值是按照此步长递减的。\n\n START WITH 定义序列的初始值(即产生的第一个值)，默认为1。\n\nMAXVALUE 定义序列生成器能产生的最大值。选项NOMAXVALUE是默认选项，代表没有最大值定义，这时对于递增Oracle序列，系统能够产生的最大值是10的27次方;对于递减序列，最大值是-1。\n\nMINVALUE定义序列生成器能产生的最小值。选项NOMAXVALUE是默认选项，代表没有最小值定义，这时对于递减序列，系统能够产生的最小值是?10的26次方;对于递增序列，最小值是1。\n\nCYCLE和NOCYCLE 表示当序列生成器的值达到限制值后是否循环。CYCLE代表循环，NOCYCLE代表不循环。如果循环，则当递增序列达到最大值时，循环到最小值;对于递减序列达到最小值时，循环到最大值。如果不循环，达到限制值后，继续产生新值就会发生错误。\n\nCACHE(缓冲)定义存放序列的内存块的大小，默认为20。NOCACHE表示不对序列进行内存缓冲。对序列进行内存缓冲，可以改善序列的性能。\n\n\n\n大量语句发生请求，申请序列时，为了避免序列在运用层实现序列而引起的性能瓶颈。Oracle序列允许将序列提前生成 cache x个先存入内存，在发生大量申请序列语句时，可直接到运行最快的内存中去得到序列。但cache个数也不能设置太大，因为在数据库重启时，会清空内存信息，预存在内存中的序列会丢失，当数据库再次启动后，序列从上次内存中最大的序列号+1 开始存入cache x个。这种情况也能会在数据库关闭时也会导致序号不连续。\n\n7 . NEXTVAL 返回序列中下一个有效的值，任何用户都可以引用。\n8 . CURRVAL 中存放序列的当前值,NEXTVAL 应在 CURRVAL 之前指定 ，二者应同时有效。\n使用:调用NEXTVAL将生成序列中的下一个序列号，调用时要指出序列名，即用以下方式调用: 序列名.NEXTVAL\nCURRVAL用于产生序列的当前值，无论调用多少次都不会产生序列的下一个值。如果序列还没有通过调用NEXTVAL产生过序列的下一个值，先引用CURRVAL没有意义。\n调用CURRVAL的方法同上，要指出序列名，即用以下方式调用:序列名.CURRVAL\n创建:​    – 创建序列,从1开始,步长为1,最大15.\n​    –超过15会报错:ORA-08004: sequence MYTESTSEQ.NEXTVAL exceeds MAXVALUE and cannot be instantiated\n​    create SEQUENCE mytestseq INCREMENT by 1 start with 10 maxvalue 15;\n删除:​    drop sequence t1_seq;\n修改:​    修改序列的注意事项：\n​    1 必须是序列的拥有者或对序列有 ALTER any sequence权限\n​    2 只有将来的序列值会被改变\n​    3 改变序列的初始值只能通过删除序列之后重建序列的方法实现\n​    Alter sequence示例：\n​    ALTER SEQUENCE emp_sequence INCREMENT BY 10 MAXVALUE 10000 CYCLE – 到10000后从头开始 NOCACHE ;\n查询:​    1 通过数据字典USER_OBJECTS可以查看用户拥有的序列。\n​    2 通过数据字典USER_SEQUENCES可以查看序列的设置。\n​    　　例：查看用户的序列：\n​      SELECT SEQUENCE_NAME,MIN_VALUE,MAX_VALUE,INCREMENT_BY,LAST_NUMBER FROM USER_SEQUENCES;\n​    　　执行结果：\n​      SEQUENCE_NAME MIN_VALUE MAX_VALUE INCREMENT_BY LAST_NUMBER\n","categories":["db"],"tags":["oracle"]},{"title":"oracle表空间扩容及锁表","url":"https://www.mele.cool/2020/12/04/oracle表空间扩容及锁表/","content":"oracle在使用中会发现，表空间不足的情况；以下介绍了如何1、查询表空间使用率、剩余量；2、如何扩展表空间容量；1、表空间容量指标查询SELECT TABLESPACE_NAME &quot;表空间&quot;,       To_char(Round(BYTES / 1024, 2), &#x27;99990.00&#x27;)       || &#x27;&#x27;           &quot;实有&quot;,       To_char(Round(FREE / 1024, 2), &#x27;99990.00&#x27;)       || &#x27;G&#x27;          &quot;现有&quot;,       To_char(Round(( BYTES - FREE ) / 1024, 2), &#x27;99990.00&#x27;)       || &#x27;G&#x27;          &quot;使用&quot;,       To_char(Round(10000 * USED / BYTES) / 100, &#x27;99990.00&#x27;)       || &#x27;%&#x27;          &quot;比例&quot;FROM   (SELECT A.TABLESPACE_NAME                             TABLESPACE_NAME,               Floor(A.BYTES / ( 1024 * 1024 ))              BYTES,               Floor(B.FREE / ( 1024 * 1024 ))               FREE,               Floor(( A.BYTES - B.FREE ) / ( 1024 * 1024 )) USED        FROM   (SELECT TABLESPACE_NAME TABLESPACE_NAME,                       Sum(BYTES)      BYTES                FROM   DBA_DATA_FILES                GROUP  BY TABLESPACE_NAME) A,               (SELECT TABLESPACE_NAME TABLESPACE_NAME,                       Sum(BYTES)      FREE                FROM   DBA_FREE_SPACE                GROUP  BY TABLESPACE_NAME) B        WHERE  A.TABLESPACE_NAME = B.TABLESPACE_NAME)--WHERE TABLESPACE_NAME LIKE &#x27;CDR%&#x27; --这一句用于指定表空间名称ORDER  BY Floor(10000 * USED / BYTES) DESC;\n\n查找数据文件指标及路径select b.file_id　　文件ID,　　b.tablespace_name　　表空间,　　b.file_name　　　　　物理文件名,　　b.bytes　　　　　　　总字节数,　　(b.bytes-sum(nvl(a.bytes,0)))　　　已使用,　　sum(nvl(a.bytes,0))　　　　　　　　剩余,　　sum(nvl(a.bytes,0))/(b.bytes)*100　剩余百分比　　from dba_free_space a,dba_data_files b　　where a.file_id=b.file_id　　group by b.tablespace_name,b.file_name,b.file_id,b.bytes　　order by b.tablespace_name\n2.表空间扩容1)增加数据文件# 给指定表空间名增加一个数据文件,指定数据文件大小.数据文件自定义起名即可.ALTER TABLESPACE 表空间名 ADD DATAFILE  &#x27;/opt/oracle/oradata/WMS_DATA02.dbf&#x27; SIZE 2048M;  \n2)手工修改已存在数据文件大小#此命令只需修改数据文件路径及大小(2048M) alter database datafile &#x27;/opt/oracle/oradata/WMS_DATA02.dbf&#x27; resize 2048M;\n其他命令#查询全部数据文件select file#, name from v$datafile;-- 1.查询引起了锁表的原因select l.session_id sid,       s.serial#,       l.locked_mode,       l.oracle_username,       s.user#,       l.os_user_name,       s.machine,       s.terminal,       a.sql_text,       a.action  from v$sqlarea a, v$session s, v$locked_object l  where l.session_id = s.sid  and s.prev_sql_addr = a.address  order by sid, s.serial#;-- 2.查询被锁的表select b.owner,b.object_name,a.session_id,a.locked_mode from v$locked_object a,dba_objects b where b.object_id = a.object_id-- 3.查看是哪个session引起的select b.username,b.sid,b.serial#,logon_time from  v$locked_object a,v$session b where a.session_id = b.sid order by b.logon_time--4.杀掉对应进程即解锁alter system kill session &#x27;43,61847&#x27;-- 剩余容量select sum(bytes) FREE from DBA_FREE_SPACE where tablespace_name =&#x27;xxx&#x27;;-- 19322503168-- 总容量select sum(bytes) TOTAL from DBA_DATA_FILES where tablespace_name =&#x27;xxx&#x27;;--88346722304--查询整个数据库剩余和使用的表空间大小使用情况：select df.tablespace_name &quot;表空间名&quot;,totalspace &quot;总空间M&quot;,freespace &quot;剩余空间M&quot;,round((1-freespace/totalspace)*100,2) &quot;使用率%&quot; from (select tablespace_name,round(sum(bytes)/1024/1024) totalspace from dba_data_files group by tablespace_name) df, (select tablespace_name,round(sum(bytes)/1024/1024) freespace from dba_free_space group by tablespace_name) fs where df.tablespace_name=fs.tablespace_name;--在表空间中，查询占用存储空间最大的表SELECT * FROM (SELECT SEGMENT_NAME, SUM(BYTES) / 1024 / 1024 MB FROM DBA_SEGMENTS WHERE TABLESPACE_NAME = &#x27;WMS_DATA&#x27; GROUP BY SEGMENT_NAME ORDER BY 2 DESC) WHERE ROWNUM &lt; 10;","categories":["db"],"tags":["oracle"]},{"title":"spring-aop","url":"https://www.mele.cool/2020/12/04/spring-aop/","content":"1.AOP释义AOP（Aspect Oriented Programming）意为面向切面编程，我们所熟悉的是面向对象编程（OOP），将程序中所有参与模块都抽象成对象，然后通过对象之间的相互调用关系来完成需求。\nAOP 是对 OOP 的一个补充，是在另外一个维度上抽象出对象，具体是指程序运行时动态地将非业务代码切入到业务代码中，从而实现代码的解耦合，将非业务代码抽象成一个对象，对该对象进行编程这就是面向切面编程思想，如下图所示。\n\n2.AOP 的优点：\n可大大降低模块之间的耦合性\n提高代码的维护性\n提高代码的复用性\n集中管理非业务代码，便于维护\n业务代码不受非业务代码的影响，逻辑更加清晰\n\n3.代码说明–JDK动态代理实现AOP（1）创建一个计算器接口 Cal，定义四个方法：加、减、乘、除。\npublic interface Cal &#123;    public int add(int num1,int num2);    public int sub(int num1,int num2);    public int mul(int num1,int num2);    public int div(int num1,int num2);&#125;\n（2）创建接口实现类 CalImpl，实现四个方法。\npublic class CalImpl implements Cal&#123;    @Override    public int add(int num1, int num2) &#123;        // TODO Auto-generated method stub        int result = num1+num2;        return result;    &#125;    @Override    public int sub(int num1, int num2) &#123;        // TODO Auto-generated method stub        int result = num1-num2;        return result;    &#125;    @Override    public int mul(int num1, int num2) &#123;        // TODO Auto-generated method stub        int result = num1*num2;        return result;    &#125;    @Override    public int div(int num1, int num2) &#123;        // TODO Auto-generated method stub        int result = num1/num2;        return result;    &#125;&#125;\n（3）在测试方法中创建 CalImpl 对象，调用方法。\npublic class Test &#123;    public static void main(String[] args) &#123;        Cal cal = new CalImpl();        cal.add(10, 3);        cal.sub(10, 3);        cal.mul(10, 3);        cal.div(10, 3);    &#125;&#125;\n以上这段代码很简单，现添加功能，在每一个方法执行的同时，打印日志信息：该方法的参数列表和该方法的计算结果。这个需求很简单，我们只需要在每一个方法体中，运算执行之前打印参数列表，运算结束之后打印计算结果即可，对代码做出如下修改。\npublic class CalImpl implements Cal&#123;    @Override    public int add(int num1, int num2) &#123;        // TODO Auto-generated method stub        System.out.println(&quot;add方法的参数是[&quot;+num1+&quot;,&quot;+num2+&quot;]&quot;);        int result = num1+num2;        System.out.println(&quot;add方法的结果是&quot;+result);        return result;    &#125;    @Override    public int sub(int num1, int num2) &#123;        // TODO Auto-generated method stub        System.out.println(&quot;sub方法的参数是[&quot;+num1+&quot;,&quot;+num2+&quot;]&quot;);        int result = num1-num2;        System.out.println(&quot;sub方法的结果是&quot;+result);        return result;    &#125;    @Override    public int mul(int num1, int num2) &#123;        // TODO Auto-generated method stub        System.out.println(&quot;mul方法的参数是[&quot;+num1+&quot;,&quot;+num2+&quot;]&quot;);        int result = num1*num2;        System.out.println(&quot;mul方法的结果是&quot;+result);        return result;    &#125;    @Override    public int div(int num1, int num2) &#123;        // TODO Auto-generated method stub        System.out.println(&quot;div方法的参数是[&quot;+num1+&quot;,&quot;+num2+&quot;]&quot;);        int result = num1/num2;        System.out.println(&quot;div方法的结果是&quot;+result);        return result;    &#125;&#125;\n再次运行代码，成功打印日志信息。\n\n功能已经实现了，但是我们会发现这种方式业务代码和打印日志代码的耦合性非常高，不利于代码的后期维护。\n如果需求改变，需要对打印的日志内容作出修改，那么我们就必须修改 4 个方法中的所有相关代码，如果是 100 个方法呢？每次就得需要手动去改 100 个方法中的代码。\n换个角度去分析，会发现 4 个方法中打印日志信息的代码基本相同，那么有没有可能将这部分代码提取出来进行封装，统一维护呢？同时也可以将日志代码和业务代码完全分离开，实现解耦合。\n按照这思路继续向下走，我们希望做的事情是把这 4 个方法的相同位置（业务方法执行前后）提取出来，形成一个横切面，并且将这个横切面抽象成一个对象，将所有的打印日志代码写到这个对象中，以实现与业务代码的分离。\n这就是 AOP 的思想。\n如何实现？使用动态代理的方式来实现。\n我们希望 CalImpl 只进行业务运算，不进行打印日志的工作，那么就需要有一个对象来替代 CalImpl 进行打印日志的工作，这就是代理对象。\n代理对象首先应该具备 CalImpl 的所有功能，并在此基础上，扩展出打印日志的功能，具体代码实现如下所示。\n（1）删除 CalImpl 方法中所有打印日志的代码，只保留业务代码。\npublic class CalImpl implements Cal&#123;    @Override    public int add(int num1, int num2) &#123;        // TODO Auto-generated method stub        int result = num1+num2;        return result;    &#125;    @Override    public int sub(int num1, int num2) &#123;        // TODO Auto-generated method stub        int result = num1-num2;        return result;    &#125;    @Override    public int mul(int num1, int num2) &#123;        // TODO Auto-generated method stub        int result = num1*num2;        return result;    &#125;    @Override    public int div(int num1, int num2) &#123;        // TODO Auto-generated method stub        int result = num1/num2;        return result;    &#125;&#125;\n（2）创建 MyInvocationHandler 类，并实现 InvocationHandler 接口，成为一个动态代理类。\npublic class MyInvocationHandler implements InvocationHandler&#123;    //委托对象    private Object obj = null;    //返回代理对象    public Object bind(Object obj)&#123;        this.obj = obj;        return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), this);    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args)            throws Throwable &#123;        // TODO Auto-generated method stub        System.out.println(method.getName()+&quot;的参数是:&quot;+Arrays.toString(args));        Object result = method.invoke(this.obj, args);        System.out.println(method.getName()+&quot;的结果是:&quot;+result);        return result;    &#125;&#125;\nbind 方法是 MyInvocationHandler 类提供给外部调用的方法，传入委托对象，bind 方法会返回一个代理对象，bind 方法完成了两项工作：\n（1）将外部传进来的委托对象保存到成员变量中，因为业务方法调用时需要用到委托对象。\n（2）通过 Proxy.newProxyInstance 方法创建一个代理对象，解释一下 Proxy.newProxyInstance 方法的参数：\n\n我们知道对象是 JVM 根据运行时类来创建的，此时需要动态创建一个代理对象的运行时类，同时需要将这个动态创建的运行时类加载到 JVM 中，这一步需要获取到类加载器才能实现，我们可以通过委托对象的运行时类来反向获取类加载器，obj.getClass().getClassLoader() 就是通过委托对象的运行时类来获取类加载器的具体实现；\n同时代理对象需要具备委托对象的所有功能，即需要拥有委托对象的所有接口，因此传入obj.getClass().getInterfaces()；\nthis 指当前 MyInvocationHandler 对象。\n\n以上全部是反射的知识点。\n\ninvoke 方法：method 是描述委托对象所有方法的对象，agrs 是描述委托对象方法参数列表的对象。\nmethod.invoke(this.obj,args) 是通过反射机制来调用委托对象的方法，即业务方法。\n\n因此在 method.invoke(this.obj, args) 前后添加打印日志信息，就等同于在委托对象的业务方法前后添加打印日志信息，并且已经做到了分类，业务方法在委托对象中，打印日志信息在代理对象中。\n测试方法中执行如下代码。\npublic class Test &#123;    public static void main(String[] args) &#123;        //委托对象        Cal cal = new CalImpl();        MyInvocationHandler mh = new MyInvocationHandler();        //代理对象        Cal cal2 = (Cal) mh.bind(cal);        cal2.add(10, 3);        cal2.sub(10, 3);        cal2.mul(10, 3);        cal2.div(10, 3);    &#125;&#125;\n运行结果如下图所示。\n\n成功，并且现在已经做到了代码分离，CalImpl 类中只有业务代码，打印日志的代码写在 MyInvocationHandler 类中。\n以上就是通过动态代理实现 AOP 的过程，我们在使用 Spring 框架的 AOP 时，并不需要这么复杂，Spring 已经对这个过程进行了封装，让开发者可以更加便捷地使用 AOP 进行开发。\n4.代码说明—spring框架实现AOP接下来学习 Spring 框架的 AOP 如何使用。\n在 Spring 框架中，我们不需要创建 MyInvocationHandler 类，只需要创建一个切面类，Spring 底层会自动根据切面类以及目标类生成一个代理对象。\n（1）创建切面类 LoggerAspect。@Aspect@Componentpublic class LoggerAspect &#123;    @Before(&quot;execution(public int com.southwind.aspect.CalImpl.*(..))&quot;)    public void before(JoinPoint joinPoint)&#123;        //获取方法名        String name = joinPoint.getSignature().getName();        //获取参数列表        String args = Arrays.toString(joinPoint.getArgs());        System.out.println(name+&quot;的参数是:&quot;+args);    &#125;    @After(&quot;execution(public int com.southwind.aspect.CalImpl.*(..))&quot;)    public void after(JoinPoint joinPoint)&#123;        //获取方法名        String name = joinPoint.getSignature().getName();        System.out.println(name+&quot;方法结束&quot;);    &#125;    @AfterReturning(value=&quot;execution(public int com.southwind.aspect.CalImpl.*(..))&quot;,returning=&quot;result&quot;)    public void afterReturn(JoinPoint joinPoint,Object result)&#123;        //获取方法名        String name = joinPoint.getSignature().getName();        System.out.println(name+&quot;方法的结果是&quot;+result);    &#125;    @AfterThrowing(value=&quot;execution(public int com.southwind.aspect.CalImpl.*(..))&quot;,throwing=&quot;ex&quot;)    public void afterThrowing(JoinPoint joinPoint,Exception ex)&#123;        //获取方法名        String name = joinPoint.getSignature().getName();        System.out.println(name+&quot;方法抛出异常：&quot;+ex);    &#125;&#125;\nLoggerAspect 类名处添加两个注解：\n\n@Aspect，表示该类是切面类；\n@Component，将该类注入到 IOC 容器中。\n\n分别来说明类中的 4 个方法注解的含义。\n@Before(&quot;execution(public int com.southwind.aspect.CalImpl.*(..))&quot;)public void before(JoinPoint joinPoint)&#123;  //获取方法名  String name = joinPoint.getSignature().getName();  //获取参数列表  String args = Arrays.toString(joinPoint.getArgs());  System.out.println(name+&quot;的参数是:&quot;+args);&#125;\n\n@Before：表示 before 方法执行的时机。execution(public int com.southwind.aspect.CalImpl.*(..))：表示切入点是 com.southwind.aspect 包下 CalImpl 类中的所有方法。即 CalImpl 所有方法在执行之前会首先执行 LoggerAspect 类中的 before 方法。\nafter 方法同理，表示 CalImpl 所有方法执行之后会执行 LoggerAspect 类中的 after 方法。\nafterReturn 方法表示 CalImpl 所有方法在 return 之后会执行 LoggerAspect 类中的 afterReturn 方法。\nafterThrowing 方法表示 CalImpl 所有方法在抛出异常时会执行 LoggerAspect 类中的 afterThrowing 方法。\n\n因此我们就可以根据具体需求，选择在 before、after、afterReturn、afterThrowing 方法中添加相应代码。\n（2）目标类也需要添加 @Component 注解，如下所示。@Componentpublic class CalImpl implements Cal&#123;    @Override    public int add(int num1, int num2) &#123;        // TODO Auto-generated method stub        return num1+num2;    &#125;    @Override    public int sub(int num1, int num2) &#123;        // TODO Auto-generated method stub        return num1-num2;    &#125;    @Override    public int mul(int num1, int num2) &#123;        // TODO Auto-generated method stub        return num1*num2;    &#125;    @Override    public int div(int num1, int num2) &#123;        // TODO Auto-generated method stub        return num1/num2;    &#125;&#125;\n（3）在 spring.xml 中进行配置。&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;    &lt;!-- 自动扫描 --&gt;    &lt;context:component-scan base-package=&quot;com.southwind.aspect&quot;&gt;&lt;/context:component-scan&gt;    &lt;!-- 使 Aspect 注解生效，为目标类自动生成代理对象 --&gt;    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt;\n\n将 com.southwind.aspect 包中的类扫描到 IoC 容器中。\n添加 aop:aspectj-autoproxy 注解，Spring 容器会结合切面类和目标类自动生成动态代理对象，Spring 框架的 AOP 底层就是通过动态代理的方式完成 AOP。\n\n（4）测试方法执行如下代码，从 IoC 容器中获取代理对象，执行方法。public class Test &#123;    public static void main(String[] args) &#123;        //加载 spring.xml        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);        //获取代理对象        Cal cal = (Cal) applicationContext.getBean(&quot;calImpl&quot;);        //执行方法        cal.add(10, 3);        cal.sub(10, 3);        cal.mul(10, 3);        cal.div(10, 3);    &#125;&#125;\n运行结果如下图所示。\n\n5.总结成功，结合代码，回过头来说几个概念更好理解。\n\n切面对象：根据切面抽象出来的对象，即 CalImpl 所有方法中需要加入日志的部分，抽象成一个切面对象 LoggerAspect。\n通知：切面对象的具体代码，即非业务代码，LoggerAspect 对象打印日志的操作。\n目标：被横切的对象，即 CalImpl 实例化对象，将通知加入其中。\n代理：切面对象、通知、目标混合之后的内容，即我们用 JDK 动态代理机制创建的对象。\n连接点：需要被横切的位置，即通知要插入业务代码的具体位置。\n\n本章节源码：https://github.com/southwind9801/gcspringaop\n","categories":["java"],"tags":["spring","aop"]},{"title":"spring ioc","url":"https://www.mele.cool/2020/12/04/spring-ioc/","content":"IoC 也叫控制反转:在传统的程序开发中，需要获取对象时，通常由开发者来手动创建实例化对象，但是在 Spring 框架中创建对象的工作不再由开发者完成，而是交给 IoC 容器来创建，我们直接获取即可，整个流程完成反转，因此是控制反转。\nIoC 容器实现步骤\n在 pom.xml 中添加 Spring 依赖\n创建配置文件，可以自定义文件名 spring.xml\n在 spring.xml 中配置 bean 标签，IoC 容器通过加载 bean 标签来创建对象\n调用 API 获取 IoC 创建的对象\n\n一:IoC 容器创建对象之无参构造  1.配置bean标签:\n&lt;!-- 配置 student 对象--&gt;&lt;bean id=&quot;stu&quot; class=&quot;com.southwind.entity.Student&quot;&lt;/bean&gt;\n  2.通过id获取对象:\n//1.加载 spring.xml 配置文件 生成 ApplicationContext 对象ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);//2.通过 id 值获取对象//参数为配置文件中的 id 值。程序在加载 spring.xml 时创建 stu 对象，通过反射机制调用无参构造函数，所有要求交给 IoC 容器管理的类必须有无参构造函数。Student stu = (Student) applicationContext.getBean(&quot;stu&quot;);System.out.println(stu); //运行结果Student [id-0, name-null, age=0]\n可以看到，此时 stu 对象的属性全部为空，因为调用无参构造只会创建对象而不会进行赋值，如何赋值呢？只需要在 spring.xml 中进行相关配置即可，如下所示。\n&lt;!-- 配置 student 对象 --&gt;&lt;bean id=&quot;stu&quot; class=&quot;com.southwind.entity.Student&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;&lt;/bean&gt;\n若包含特殊字符，比如 name=”&lt;张三&gt;”，使用 ]]&gt; 进行配置:\n&lt;property name=&quot;name&quot;&gt;       &lt;value&gt;&lt;![CDATA[&lt;张三&gt;]]&gt;&lt;/value&gt;&lt;/property&gt;\nSpring 通过调用每个属性的 setter 方法来完成属性的赋值，因此实体类必须有 setter 方法，否则加载时报错，getter 方法可省略。\n还可以通过运行时类获取对象:\n//1.加载 spring.xml 配置文件ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);//2.通过运行时类获取对象Student stu = applicationContext.getBean(Student.class);System.out.println(stu);\n此方法有一个弊端，当 spring.xml 中配置两个 Student 的 bean 时程序会抛出异常，因为此时两个 bean 都是由 Student 类生成的，IoC 容器无法将两个 bean 都返回，必须指定一个唯一的 bean。\n二:IoC 容器创建对象之有参构造1.在实体类中创建有参构造\npublic Student(int id, String name, int age) &#123;        super();        this.id = id;        this.name = name;        this.age = age;&#125;\n2.spring.xml 中进行配置\n&lt;!-- 通过有参构造函数创建对象 --&gt;&lt;bean id=&quot;stu3&quot; class=&quot;com.hzit.entity.Student&quot;&gt;   &lt;constructor-arg name=&quot;id&quot; value=&quot;3&quot;&gt;&lt;/constructor-arg&gt;   &lt;constructor-arg name=&quot;name&quot; value=&quot;小明&quot;&gt;&lt;/constructor-arg&gt;   &lt;constructor-arg name=&quot;age&quot; value=&quot;22&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;\n（3）此时 IoC 容器会根据 constructor-arg 标签去加载对应的有参构造函数，创建对象并完成属性赋值。name 的值需要与有参构造的形参名对应，value 是对应的值。除了使用 name 对应参数外，还可以通过下标 index 对应，如下所示。\n获取对象的方式同样包括ID获取和运行时类获取.\n&lt;!-- 通过有参构造函数创建对象 --&gt;&lt;bean id=&quot;stu3&quot; class=&quot;com.hzit.entity.Student&quot;&gt;   &lt;constructor-arg index=&quot;0&quot; value=&quot;3&quot;&gt;&lt;/constructor-arg&gt;   &lt;constructor-arg index=&quot;1&quot; value=&quot;小明&quot;&gt;&lt;/constructor-arg&gt;   &lt;constructor-arg index=&quot;2&quot; value=&quot;22&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;\nIOC容器管理有级联关系的多个对象:&lt;!-- 创建 classes 对象 --&gt;&lt;bean id=&quot;classes&quot; class=&quot;com.hzit.entity.Classes&quot;&gt;   &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;name&quot; value=&quot;Java班&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 创建 stu 对象 --&gt;&lt;bean id=&quot;stu&quot; class=&quot;com.hzit.entity.Student&quot;&gt;   &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;name&quot;&gt;       &lt;value&gt;&lt;![CDATA[&lt;张三&gt;]]&gt;&lt;/value&gt;   &lt;/property&gt;   &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;   &lt;!-- 将 classes 对象赋给 stu 对象 --&gt;   &lt;property name=&quot;classes&quot; ref=&quot;classes&quot;&gt;&lt;/property&gt;&lt;/bean&gt;\n\\在 spring.xml 中，通过 ref 属性将其他 bean 赋给当前 bean 对象，这种方式叫做依赖注入（DI），是 Spring 非常重要的机制，DI 是将不同对象进行关联的一种方式，是 IoC 的具体实现方式，通常 DI 和 IoC 是紧密结合在一起的，因此一般说的 IoC 包括 DI。**集合属性通过 list 标签和 ref 标签完成注入:&lt;!-- 配置 classes 对象 --&gt;&lt;bean id=&quot;classes&quot; class=&quot;com.hzit.entity.Classes&quot;&gt;   &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;name&quot; value=&quot;Java班&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;students&quot;&gt;       &lt;!-- 注入 student 对象 --&gt;       &lt;list&gt;           &lt;ref bean=&quot;stu&quot;/&gt;           &lt;ref bean=&quot;stu2&quot;/&gt;       &lt;/list&gt;   &lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;stu&quot; class=&quot;com.hzit.entity.Student&quot;&gt;   &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;name&quot;&gt;        &lt;value&gt;&lt;![CDATA[&lt;张三&gt;]]&gt;&lt;/value&gt;   &lt;/property&gt;   &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;stu2&quot; class=&quot;com.hzit.entity.Student&quot;&gt;   &lt;property name=&quot;id&quot; value=&quot;2&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;name&quot; value=&quot;李四&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;&lt;/bean&gt;\n\n\n\n\nSpring 中的 beanbean 是根据 scope 来生成的，表示 bean 的作用域，scope 有 4 种类型：\n\nsingleton，单例，表示通过 Spring 容器获取的该对象是唯一的；\nprototype，原型，表示通过 Spring 容器获取的对象都是不同的；\nrequest，请求，表示在一次 HTTP 请求内有效；\nsession，会话，表示在一个用户会话内有效。\n\n后两种只适用于 Web 项目，大多数情况下，我们只会使用 singleton 和 prototype 两种 scope，并且 scope 的默认值是 singleton。\nSpring 的继承Spring 的继承与 Java 的继承不一样，但思想很相似，子 bean 可以继承父 bean 中的属性。看到这里，你可能会有这样的疑问：子 bean 可以继承父 bean 中的方法吗？\n其实这里不存在方法的继承，Spring 的继承是在对象层面进行操作的，即两个 bean 来自同一个类，因此方法是一样的，不存在继承关系.\n（1）在 spring.xml 中配置两个 User bean，并建立继承关系。\n&lt;bean id=&quot;user&quot; class=&quot;com.southwind.entity.User&quot;&gt;   &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;user2&quot; class=&quot;com.southwind.entity.User&quot; parent=&quot;user&quot;&gt;   &lt;!-- 覆盖 name 属性 --&gt;   &lt;property name=&quot;name&quot; value=&quot;李四&quot;&gt;&lt;/property&gt;&lt;/bean&gt;\n（2）运行代码，结果如下。\nUser user2 = (User) applicationContext.getBean(&quot;user2&quot;);System.out.println(user2); //打印如下创建了User对象创建了User对象User [id=1, name=张三, age=23]\n可以看到，创建了两个 User 对象 user1 和 user2，并且 user2 继承了 user1 的所有属性。user2 在继承 user1 所有属性的基础之上，还可以对属性进行覆盖，直接在 spring.xml 中添加 property 即可。\nSpring 中的 bean 能不能在不同类之间继承？\n答案是可以的，但是需要这两个类的属性列表完全一致，否则会报错，实际开发中并不会使用到这种方式。\nSpring 的依赖与继承类似，依赖也是 bean 和 bean 之间的一种关联方式，配置依赖关系后，被依赖的 bean 一定先创建，再创建依赖的 bean:\n1.设置依赖关系.\n&lt;bean id=&quot;user&quot; class=&quot;com.southwind.entity.User&quot; depends-on=&quot;car&quot;&gt;   &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;car&quot; class=&quot;com.southwind.entity.Car&quot;&gt;   &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;brand&quot; value=&quot;宝马&quot;&gt;&lt;/property&gt;&lt;/bean&gt;\n2.运行测试代码.\nApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);User user = (User) applicationContext.getBean(&quot;user&quot;);Car car = (Car) applicationContext.getBean(&quot;car&quot;); //输出结果创建了Car对象创建了User对象\nspring创建对象的顺序默认是由spring.xml 中 bean 的配置顺序来决定的，先到先得,但由于此处设置了依赖关系(depends-on属性),因为 User 依赖于 Car，所以必须先创建 Car 对象，User 对象才能完成依赖。\nSpring 读取外部资源读取properties文件中内容:\n&lt;!-- 导入外部的资源文件 --&gt;&lt;!-- 使用 context:property-placeholder 标签，需要导入 context 命名空间。 --&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt;&lt;!-- 创建 C3P0 数据源 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;   &lt;property name=&quot;user&quot; value=&quot;$&#123;user&#125;&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;password&quot; value=&quot;$&#123;pwd&#125;&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;driverName&#125;&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;url&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt;\n\n\np 命名空间p 命名空间可以简化 bean 的各种配置\nspring.xml 中创建 User bean 和 Car bean，并且通过 p 命名空间给属性赋值，同时完成依赖注入，注意需要引入 p 命名间:\n&lt;bean id=&quot;user&quot; class=&quot;com.southwind.entity.User&quot; p:id=&quot;1&quot; p:name=&quot;张三&quot; p:age=&quot;23&quot; p:car-ref=&quot;car&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;car&quot; class=&quot;com.southwind.entity.Car&quot; p:id=&quot;1&quot; p:brand=&quot;宝马&quot;&gt;&lt;/bean&gt;\nSpring IoC 基于注解的开发\n修改spring.xml,把包扫描到IOC容器.\nbase-package=”com.southwind” 表示将 “com.blydd” 下所有子包的类全部扫描到 IoC 容器中，一步可将所有参与项目的类完成扫描注入。注意：配置文件需要引入 context 命名空间。\n\n\n&lt;!-- 将类扫描到 IoC 容器中 --&gt;&lt;context:component-scan base-package&#x3D;&quot;com.blydd&quot;&gt;&lt;&#x2F;context:component-scan&gt;\n2.修改 Controller,Service,Dao，添加注解\n@Controllerpublic class UserController &#123;    @Autowired    private UserService userService;    public User getUserById(int id)&#123;        return userService.getUserById(id);    &#125;&#125;\n\n在类名处添加 @Controller 注解，表示该类作为一个控制器；\nuserService 属性处添加 @Autowired 注解，表示 IoC 容器自动完成装载，默认是 byType 的方式。\n\n3.运行测试代码:\nApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);UserController userController = (UserController) applicationContext.getBean(&quot;userController&quot;);User user = userController.getUserById(1);System.out.println(user);//输出User [id=1, name=张三]\nIoC 中可以给类添加的注解有 4 种：\n\n@Controller\n@Service\n@Repository\n@Component\n\n在实际开发中，我们使用 @Controller、@Service、@Repository 分别表示 Controller 层、Service 层、DAO 层。前面提到过，类中属性的自动装载默认是通过 byType 的方式实现的。自动装载除了 byType 的方式，还可以使用 byName，使用 byName 的方式，需要结合 @Qualifier 注解一起使用，具体操作如下所示。\n**controller:\n**\n@Controllerpublic class UserController &#123;    @Autowired()    @Qualifier(&quot;userService&quot;)    private UserService userService;    public User getUserById(int id)&#123;        return userService.getUserById(id);    &#125;&#125;\n我们知道 byName 的方式是通过属性名去匹配对应 bean 的 id 属性值，但是基于注解的方式我们并没有给 bean 设置 id，如何完成的呢？\n其实在类中添加注解时，已经设置了默认的 id，即类名首字母小写之后的值就是 id 的默认值。\nPS:\n如果手动赋值,即:\n@Service(&quot;myUserService&quot;)public class UserServiceImpl implements UserService&#123;&#125;\n则controller中@Qualifier() 中的值必须与 @Service() 中的值一致，才能完成自动装载:\n@Controllerpublic class UserController &#123;    @Autowired()    @Qualifier(&quot;myUserService&quot;)    private UserService userService;    public User getUserById(int id)&#123;        return userService.getUserById(id);    &#125;&#125;\n\n\n\n\n\n\n转载来源:https://gitbook.cn/gitchat/column/5d2daffbb81adb3aa8cab878/topic/5d2de41eb81adb3aa8cab957\n","categories":["java"],"tags":["spring","java","ioc","java基础"]},{"title":"springboot的异常处理","url":"https://www.mele.cool/2020/12/04/springboot的异常处理/","content":"Spring Boot对异常的处理有一套默认的机制：当应用中产生异常时，Spring Boot根据发送请求头中的accept是否包含text/html来分别返回不同的响应信息。当从浏览器地址栏中访问应用接口时，请求头中的accept便会包含text/html信息，产生异常时，Spring Boot通过org.springframework.web.servlet.ModelAndView对象来装载异常信息，并以HTML的格式返回；而当从客户端访问应用接口产生异常时（客户端访问时，请求头中的accept不包含text/html），Spring Boot则以JSON的格式返回异常信息。下面来验证一下。\n默认异常处理机制假设应用中有如下一个Controller：\n@RestController@RequestMapping(&quot;user&quot;)public class UserController &#123;    @GetMapping(&quot;&#x2F;&#123;id:\\\\d+&#125;&quot;)    public void get(@PathVariable String id) &#123;        throw new RuntimeException(&quot;user not exist&quot;);    &#125;&#125;\n\n\n在代码中我们主动的抛出了一个RuntimeException，使用浏览器访问http://localhost:8080/user/1：可看到页面返回了一些异常描述，并且请求头的accpet包含了text/html片段。\n接着使用模拟发送REST请求的Chrome插件Restlet Client发送http://localhost:8080/user/1：\n\n可以看到请求头的accept值为*/*，并且返回一段JSON格式的信息。\n查看Spring Boot的BasicErrorController类便可看到这一默认机制的具体实现：\n\n可看到errorHtml和error方法的请求地址和方法是一样的，唯一的区别就是errorHtml通过produces = &#123;&quot;text/html&quot;&#125;判断请求头的accpet属性中是否包含text/html，如果包含，便走该方法。\n自定义html异常页面我们可以通过在src/main/resources/resources/error路径下定义友好的异常页面，比如定义一个500.html页面：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;500&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    系统内部异常&lt;/body&gt;&lt;/html&gt;\n\n\n然后再次通过浏览器访问:http://localhost:8080/user/1：\n\n同样的，我们也可以定义404.html等常见的HTTP状态码对应的异常页面。\n通过自定义html异常页面并不会影响客户端发送请求异常返回的结果。\n自定义异常处理除了可以通过自定义html异常页面来改变浏览器访问接口时产生的异常信息，我们也可以自定义异常处理来改表默认的客户端访问接口产生的异常信息。\n我们手动定义一个UserNotExistException，继承RuntimeException。\npublic class UserNotExistException extends RuntimeException&#123;    private static final long serialVersionUID = -1574716826948451793L;    private String id;    public UserNotExistException(String id)&#123;        super(&quot;user not exist&quot;);        this.id = id;    &#125;    public String getId() &#123;        return id;    &#125;    public void setId(String id) &#123;        this.id = id;    &#125;&#125;\n\n\n然后定义一个Controller异常处理类ControllerExceptionHandler：\n@ControllerAdvicepublic class ControllerExceptionHandler &#123;    @ExceptionHandler(UserNotExistException.class)    @ResponseBody    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)    public Map&lt;String, Object&gt; handleUserNotExistsException(UserNotExistException e) &#123;        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;id&quot;, e.getId());        map.put(&quot;message&quot;, e.getMessage());        return map;    &#125;&#125;\n\n\n其中注解@ExceptionHandler指定了要处理的异常类型，注解@ResponseStatus指定异常处理方法返回的HTTP状态码为HttpStatus.INTERNAL_SERVER_ERROR，即500。HttpStatus是一个spring自带的枚举类型，封装了常见的HTTP状态码及描述：\npublic enum HttpStatus &#123;    CONTINUE(100, &quot;Continue&quot;),    SWITCHING_PROTOCOLS(101, &quot;Switching Protocols&quot;),    PROCESSING(102, &quot;Processing&quot;),    CHECKPOINT(103, &quot;Checkpoint&quot;),    OK(200, &quot;OK&quot;),    CREATED(201, &quot;Created&quot;),    ACCEPTED(202, &quot;Accepted&quot;),    NON_AUTHORITATIVE_INFORMATION(203, &quot;Non-Authoritative Information&quot;),    NO_CONTENT(204, &quot;No Content&quot;),    RESET_CONTENT(205, &quot;Reset Content&quot;),    PARTIAL_CONTENT(206, &quot;Partial Content&quot;),    MULTI_STATUS(207, &quot;Multi-Status&quot;),    ALREADY_REPORTED(208, &quot;Already Reported&quot;),    IM_USED(226, &quot;IM Used&quot;),    MULTIPLE_CHOICES(300, &quot;Multiple Choices&quot;),    MOVED_PERMANENTLY(301, &quot;Moved Permanently&quot;),    FOUND(302, &quot;Found&quot;),    /** @deprecated */    @Deprecated    MOVED_TEMPORARILY(302, &quot;Moved Temporarily&quot;),    SEE_OTHER(303, &quot;See Other&quot;),    NOT_MODIFIED(304, &quot;Not Modified&quot;),    /** @deprecated */    @Deprecated    USE_PROXY(305, &quot;Use Proxy&quot;),    TEMPORARY_REDIRECT(307, &quot;Temporary Redirect&quot;),    PERMANENT_REDIRECT(308, &quot;Permanent Redirect&quot;),    BAD_REQUEST(400, &quot;Bad Request&quot;),    UNAUTHORIZED(401, &quot;Unauthorized&quot;),    PAYMENT_REQUIRED(402, &quot;Payment Required&quot;),    FORBIDDEN(403, &quot;Forbidden&quot;),    NOT_FOUND(404, &quot;Not Found&quot;),    METHOD_NOT_ALLOWED(405, &quot;Method Not Allowed&quot;),    NOT_ACCEPTABLE(406, &quot;Not Acceptable&quot;),    PROXY_AUTHENTICATION_REQUIRED(407, &quot;Proxy Authentication Required&quot;),    REQUEST_TIMEOUT(408, &quot;Request Timeout&quot;),    CONFLICT(409, &quot;Conflict&quot;),    GONE(410, &quot;Gone&quot;),    LENGTH_REQUIRED(411, &quot;Length Required&quot;),    PRECONDITION_FAILED(412, &quot;Precondition Failed&quot;),    PAYLOAD_TOO_LARGE(413, &quot;Payload Too Large&quot;),    /** @deprecated */    @Deprecated    REQUEST_ENTITY_TOO_LARGE(413, &quot;Request Entity Too Large&quot;),    URI_TOO_LONG(414, &quot;URI Too Long&quot;),    /** @deprecated */    @Deprecated    REQUEST_URI_TOO_LONG(414, &quot;Request-URI Too Long&quot;),    UNSUPPORTED_MEDIA_TYPE(415, &quot;Unsupported Media Type&quot;),    REQUESTED_RANGE_NOT_SATISFIABLE(416, &quot;Requested range not satisfiable&quot;),    EXPECTATION_FAILED(417, &quot;Expectation Failed&quot;),    I_AM_A_TEAPOT(418, &quot;I&#x27;m a teapot&quot;),    /** @deprecated */    @Deprecated    INSUFFICIENT_SPACE_ON_RESOURCE(419, &quot;Insufficient Space On Resource&quot;),    /** @deprecated */    @Deprecated    METHOD_FAILURE(420, &quot;Method Failure&quot;),    /** @deprecated */    @Deprecated    DESTINATION_LOCKED(421, &quot;Destination Locked&quot;),    UNPROCESSABLE_ENTITY(422, &quot;Unprocessable Entity&quot;),    LOCKED(423, &quot;Locked&quot;),    FAILED_DEPENDENCY(424, &quot;Failed Dependency&quot;),    UPGRADE_REQUIRED(426, &quot;Upgrade Required&quot;),    PRECONDITION_REQUIRED(428, &quot;Precondition Required&quot;),    TOO_MANY_REQUESTS(429, &quot;Too Many Requests&quot;),    REQUEST_HEADER_FIELDS_TOO_LARGE(431, &quot;Request Header Fields Too Large&quot;),    UNAVAILABLE_FOR_LEGAL_REASONS(451, &quot;Unavailable For Legal Reasons&quot;),    INTERNAL_SERVER_ERROR(500, &quot;Internal Server Error&quot;),    NOT_IMPLEMENTED(501, &quot;Not Implemented&quot;),    BAD_GATEWAY(502, &quot;Bad Gateway&quot;),    SERVICE_UNAVAILABLE(503, &quot;Service Unavailable&quot;),    GATEWAY_TIMEOUT(504, &quot;Gateway Timeout&quot;),    HTTP_VERSION_NOT_SUPPORTED(505, &quot;HTTP Version not supported&quot;),    VARIANT_ALSO_NEGOTIATES(506, &quot;Variant Also Negotiates&quot;),    INSUFFICIENT_STORAGE(507, &quot;Insufficient Storage&quot;),    LOOP_DETECTED(508, &quot;Loop Detected&quot;),    BANDWIDTH_LIMIT_EXCEEDED(509, &quot;Bandwidth Limit Exceeded&quot;),    NOT_EXTENDED(510, &quot;Not Extended&quot;),    NETWORK_AUTHENTICATION_REQUIRED(511, &quot;Network Authentication Required&quot;);    ...&#125;\n\n\n编写完自定义异常处理逻辑后，我们将UserController中的方法抛出的异常改为UserNotExistException：\n @GetMapping(&quot;/&#123;id:\\\\d+&#125;&quot;)public void get(@PathVariable String id) &#123;    throw new UserNotExistException(id);&#125;\n\n\n重启项目，使用Restlet Client再次访问http://localhost:8080/user/1，响应如下：\n\n源码链接 https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/25.Spring-Boot-Exception\n\nFrom:https://mrbird.cc/Spring-Boot-Exception.html\n","categories":["springboot"],"tags":["springboot","异常"]},{"title":"Spring Boot中使用JdbcTemplate","url":"https://www.mele.cool/2020/12/04/Spring Boot中使用JdbcTemplate/","content":"个人觉得JdbcTemplate相较于MyBaits，Hibernate等数据库框架更容易上手，对SQL的操作也更为直观方便，所以在项目中也是一个不错的选择。在Spring Boot开启JdbcTemplate很简单，只需要引入spring-boot-starter-jdbc依赖即可。JdbcTemplate封装了许多SQL操作，具体可查阅官方文档https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html。\n引入依赖spring-boot-starter-jdbc：\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n数据库驱动为ojdbc6，数据源采用Druid。具体可参考http://59.110.212.214/blog/32\n代码编写数据准备：\nCREATE TABLE &quot;SCOTT&quot;.&quot;STUDENT&quot; (    &quot;SNO&quot; VARCHAR2(3 BYTE) NOT NULL ,    &quot;SNAME&quot; VARCHAR2(9 BYTE) NOT NULL ,    &quot;SSEX&quot; CHAR(2 BYTE) NOT NULL );INSERT INTO &quot;SCOTT&quot;.&quot;STUDENT&quot; VALUES (&#x27;001&#x27;, &#x27;KangKang&#x27;, &#x27;M &#x27;);INSERT INTO &quot;SCOTT&quot;.&quot;STUDENT&quot; VALUES (&#x27;002&#x27;, &#x27;Mike&#x27;, &#x27;M &#x27;);INSERT INTO &quot;SCOTT&quot;.&quot;STUDENT&quot; VALUES (&#x27;003&#x27;, &#x27;Jane&#x27;, &#x27;F &#x27;);\n\n\n这里主要演示在Dao的实现类里使用JdbcTemplate，所以其它模块代码的编写就不展示了\nStudentDaoImp类代码：\n@Repository(&quot;studentDao&quot;)public class StudentDaoImp implements StudentDao &#123;    @Autowired    private JdbcTemplate jdbcTemplate;        @Override    public int add(Student student) &#123;        // String sql = &quot;insert into student(sno,sname,ssex) values(?,?,?)&quot;;        // Object[] args = &#123; student.getSno(), student.getName(), student.getSex() &#125;;        // int[] argTypes = &#123; Types.VARCHAR, Types.VARCHAR, Types.VARCHAR &#125;;        // return this.jdbcTemplate.update(sql, args, argTypes);        String sql = &quot;insert into student(sno,sname,ssex) values(:sno,:name,:sex)&quot;;        NamedParameterJdbcTemplate npjt = new NamedParameterJdbcTemplate(this.jdbcTemplate.getDataSource());        return npjt.update(sql, new BeanPropertySqlParameterSource(student));    &#125;        @Override    public int update(Student student) &#123;        String sql = &quot;update student set sname = ?,ssex = ? where sno = ?&quot;;        Object[] args = &#123; student.getName(), student.getSex(), student.getSno() &#125;;        int[] argTypes = &#123; Types.VARCHAR, Types.VARCHAR, Types.VARCHAR &#125;;        return this.jdbcTemplate.update(sql, args, argTypes);    &#125;        @Override    public int deleteBysno(String sno) &#123;        String sql = &quot;delete from student where sno = ?&quot;;        Object[] args = &#123; sno &#125;;        int[] argTypes = &#123; Types.VARCHAR &#125;;        return this.jdbcTemplate.update(sql, args, argTypes);    &#125;        @Override    public List&lt;Map&lt;String, Object&gt;&gt; queryStudentsListMap() &#123;        String sql = &quot;select * from student&quot;;        return this.jdbcTemplate.queryForList(sql);    &#125;        @Override    public Student queryStudentBySno(String sno) &#123;        String sql = &quot;select * from student where sno = ?&quot;;        Object[] args = &#123; sno &#125;;        int[] argTypes = &#123; Types.VARCHAR &#125;;        List&lt;Student&gt; studentList = this.jdbcTemplate.query(sql, args, argTypes, new StudentMapper());        if (studentList != null &amp;&amp; studentList.size() &gt; 0) &#123;            return studentList.get(0);        &#125; else &#123;            return null;        &#125;    &#125;&#125;\n\n\n在引入spring-boot-starter-jdbc驱动后，可直接在类中注入JdbcTemplate。由上面代码可发现，对于保存操作有两种不同的方法，当插入的表字段较多的情况下，推荐使用NamedParameterJdbcTemplate。\n对于返回结果，可以直接使用List&gt;来接收，这也是个人比较推荐使用的方式，毕竟比较简单方便；也可以使用库表对应的实体对象来接收，不过这时候我们就需要手动创建一个实现了org.springframework.jdbc.core.RowMapper的对象，用于将实体对象属性和库表字段一一对应：\npublic class StudentMapper implements RowMapper&lt;Student&gt;&#123;    @Override    public Student mapRow(ResultSet rs, int rowNum) throws SQLException &#123;        Student student = new Student();        student.setSno(rs.getString(&quot;sno&quot;));        student.setName(rs.getString(&quot;sname&quot;));        student.setSex(rs.getString(&quot;ssex&quot;));        return student;    &#125;&#125;\n\n\n测试最终项目目录如下图所示：\n\n启动项目，测试插入数据http://localhost:8080/web/addstudent?sno=004&amp;name=Maria&amp;sex=F：\n\n查询所有学生数据http://localhost:8080/web/queryallstudent:\n\n测试删除http://localhost:8080/web/deletestudent?sno=004：\n\n\n转自:https://mrbird.cc/Spring-Boot%20JdbcTemplate.html\n","categories":["springboot"],"tags":["springboot","jdbcTemplate"]},{"title":"struts2实现返回json请求","url":"https://www.mele.cool/2020/12/04/struts2中实现返回json格式请求/","content":"struts2实现json请求，可以有两种方式：\n\n通过struts2-json-plugin插件，这种方式需要在struts.xml中配置action,而且package需要继承json-struts，另外还需要配置结果资源。\n传统的输出流，向ajax请求写结果。第一种方式，如果是maven工程，那么就需要在pom.xml中加入struts2-json-plugin依赖。第一种方式，如果是maven工程，那么就需要在pom.xml中加入struts2-json-plugin依赖。1.引入依赖&lt;dependency&gt;    &lt;groupId&gt;org.apache.struts&lt;/groupId&gt;    &lt;artifactId&gt;struts2-core&lt;/artifactId&gt;    &lt;version&gt;$&#123;struts2.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.struts&lt;/groupId&gt;    &lt;artifactId&gt;struts2-json-plugin&lt;/artifactId&gt;    &lt;version&gt;$&#123;struts2.version&#125;&lt;/version&gt;&lt;/dependency&gt;\n2.编写action,其中，方法返回结果不重要，也不需要指定资源，但是返回给ajax请求的结果需要声明在action中，并提供get,set方法。我们只需要给请求结果赋值。package com.xxx.struts.action;import com.opensymphony.xwork2.Action;import com.xxx.struts.entity.User;public class ApiAction &#123;\t\tprivate User user;\tpublic User getUser()&#123;return this.user;&#125;\tpublic void setUser(User user)&#123;this.user = user;&#125;\tpublic String json()&#123;\t\tuser  = new User();\t\tuser.setId(&quot;1&quot;);\t\tuser.setUsername(&quot;ajax返回json&quot;);\t\tuser.setPassword(&quot;123456&quot;);\t\tSystem.out.println(&quot;method get call.&quot;);\t\treturn Action.SUCCESS;\t&#125;&#125;\n这里，我们返回的是User对象的变量user,我们需要在json()方法中给user赋值。或者返回指定属性:package com.haier.tmsorder.order.cbs.action;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import com.alibaba.fastjson.JSONObject;import com.haier.tmsorder.basic.webapp.action.BaseBasicAction;import com.haier.tmsorder.http.service.LogisticsCBSService;public class HttpServiceAction  extends BaseBasicAction&#123;\t//日志    private static Logger logger = LoggerFactory.getLogger(HttpServiceAction.class);\tprivate static final long serialVersionUID = -4352661852597387975L;\tprivate LogisticsCBSService logisticsCBSService;\tprivate boolean flag;\tprivate String msg;\t//入参\tprivate String params;\t\t\t/**\t * 接收物流信息,存入物流表\t * @return\t */\t public String receiveLogistics() &#123;    \tSystem.err.print(params);    \t//参数判空    \tif (StringUtils.isBlank(params)) &#123;\t\t\tflag=false;\t\t\tmsg=&quot;the params is empty,please check!&quot;;\t\t\treturn SUCCESS;\t\t&#125;    \treturn SUCCESS;\t &#125;\tpublic boolean isFlag() &#123;return flag;&#125;\tpublic void setFlag(boolean flag) &#123;this.flag = flag;&#125;\tpublic String getMsg() &#123;return msg;&#125;\tpublic void setMsg(String msg) &#123;this.msg = msg;&#125;\tpublic String getParams() &#123;return params;&#125;\tpublic void setParams(String params) &#123;this.params = params;&#125;\tpublic LogisticsCBSService getLogisticsCBSService() &#123;return logisticsCBSService;&#125;\tpublic void setLogisticsCBSService(LogisticsCBSService logisticsCBSService) &#123;this.logisticsCBSService = logisticsCBSService;&#125;\t&#125;\n3.配置struts.xml上图是返回对象转json时的配置或者返回指定几个属性:\npackage需要继承json-default\nresult的type值是json\nparam名为root的参数就是我们在 action中定义的user变量 / param名为includeProperties中的参数flag,msg就是我们要返回的json数据4.测试\n\n\n第二种方式见原文链接\n\n转自:原文链接\n","categories":["java"],"tags":["java","struts2","json"]},{"title":"cmd命令生成项目webservice客户端","url":"https://www.mele.cool/2020/12/04/webservice接口生成客户端代码及使用/","content":"1.webservice接口的检查能够正常调用的webservice接口是可以直接访问的。在浏览器中输入webservice接口的URL，注意：一定要带上“？wsdl”结尾。调用成功会返回一串xml格式的数据，该数据便是接口具体的方法和返回的类型，如下图所示：\n2.cmd命令生成项目webservice客户端wsimport -s D:\\Desktop\\temp\\s -p com.map -verbose -keep http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx?wsdl参数介绍：-keep：是否生成java源文件-d：指定.class文件的输出目录-s：指定.java文件的输出目录-p：定义生成类的包名，不定义的话有默认包名-verbose：在控制台显示输出信息-b：指定jaxws/jaxb绑定文件或额外的schemas-extension：使用扩展来支持SOAP1.2\n\n注意：1.指定的文件输出目录一定是要先建好文件夹，不然会报找不到目录；建议按着项目的路径把这里填上，方便直接复制到项目中。\n\n3.客户端代码的使用1.执行完2.2的操作后，在指定目录中就会找到生成后的代码，可直接把其拷贝到项目中。2.在生成的代码中找出接口调用的连接类。一般是WS或Service结尾。打开后会有下图红框的结构。3.找出其调用类4.另写一个Service，并在该Service中写一个单例来注入webservice接口的连接类。参考代码如下：\nprivate MobileCodeWSSoap mobileCodeWSSoap;public MobileCodeWSSoap getMobileCodeWSSoap() &#123;\t        if(mobileCodeWSSoap != null)&#123;\t            return mobileCodeWSSoap;\t        &#125;\t        try &#123;\t            URL uurl = new URL(&quot;MobileTokenConstants.getValue(MobileTokenConstants.KEY_ADDRESS)&quot;);//URL在配置文件中动态配置\t            MobileCodeWS mobileCodeWS = new MobileCodeWS(uurl);\t            mobileCodeWSSoap = mobileCodeWS.getMobileCodeWSSoap();\t        &#125; catch (MalformedURLException e) &#123; \t            e.printStackTrace();\t        &#125;\t            return mobileCodeWSSoap;\t&#125;","categories":["java"],"tags":["命令","webservice"]},{"title":"日志关键词高亮显示","url":"https://www.mele.cool/2020/12/04/tomcat常用命令/","content":"\n日志关键词高亮显示:\n\n\n格式:tail -f 日志文件 | perl -pe ‘s/(关键词)/\\e[1;颜色$1\\e[0m/g’\n\n\n例如:tail -f catalina.out | perl -pe ‘s/(172.16.0.243)/\\e[1;31m$1\\e[0m/g’\n\n","categories":["linux"],"tags":["linux","tomcat","日志"]},{"title":"一个家越过越好的三个迹象","url":"https://www.mele.cool/2020/12/04/一个家越过越好的3个迹象/","content":"一是，小事不争对错。\n\n　　听过这样一个故事：一次，有个姑娘在朋友家留宿，晚上，她和朋友一起去吃了夜宵。饭后回到住处，朋友从冰箱里取出两盒鲜奶，二人正要喝，朋友的婆婆忽然喊道：“赶紧吃点东西，不能空腹喝牛奶！”\n　　姑娘刚想解释，朋友悄悄做了个制止的手势，很快拿出一片面包，分给了她一半。老太太见二人吃了面包，喜滋滋地忙别的事去了。\n　　朋友解释道：“如果她能在这件小事上获得成就感，我们又何必告诉她真相呢？真相对她不重要，对我们也没意义，不过是半口面包的事。”\n　　以前单位有个同事，每天早晨都要和我们说一下家里的鸡飞狗跳：婆婆今早做的饭不讲究营养搭配；老公不够认真，冲奶粉的比例不精确……她说得最多的话就是“那么做不对，我肯定得说他一顿啊……”终于有一天，她不再抱怨和唠叨，脸上也没有了神采和光芒。我们才知道，她的老公跟她提出了离婚。\n　　一个家庭，在鸡毛蒜皮的小事上争对错、在细枝末节里辩输赢，最容易产生怨气，也最容易耗尽热情。家是安乐窝，不是辩论场；家是避风港，不是角斗场。在无关痛痒的小事上彼此包容，在无伤大雅的细节里懂得退让，留得住爱，才守得住家。\n　　二是，大事有商有量。\n\n　　电视剧《都挺好》里，有这样一个情节：苏明成想投资，可妻子朱丽谨慎，拒绝了他的提议。苏明成表面打消了念头，私下里却偷偷卖了车，又借了一笔钱，还动用了家里的存款，最终凑够资金入了股。\n　　朱丽得知真相后，特别生气地问苏明成：“你有没有跟我商量过，我还是不是你老婆了？”小两口原本恩爱有加，却因此产生了隔阂，最终劳燕分飞。\n　　婚姻里，有一种心寒叫“我拿你当亲人，你把我当外人”。我对你坦诚相待，你却对我遮遮掩掩。所以，有人说，朱丽并不是小题大做，而是在大事面前，一方擅自做主，一方蒙在鼓里，这本身就是一种不公平。\n　　自作主张的决定，折射的是当事人的霸道和自私；先斩后奏的行为，伤害的是对方的颜面和信任。大事上，多多交流，才避得开风险和陷阱；努力沟通，才有机会磨合思想升华感情；学会商量，才找得到解决问题的最优解。一家人同舟共济、坦诚相待、以和为贵，才能不畏风浪、不惧骤雨。\n　　三是，往事不翻旧账。\n\n　　在我们身边，翻旧账的例子比比皆是：谈恋爱时少送了一次生日礼物，妻子唠叨了好些年；妻子有一件小事没做好，丈夫也不忘反复指责“都错过一次了，怎么还不长记性！”\n　　陈年旧账，就像“案底”，一笔笔记下的都是对方的“罪行”。翻旧账的人，更像拿着一把尖刀，他知道你的软肋，所以例无虚发、刀刀见血。但其实，真正聪明的人都懂得：旧事翻篇，才能拥有崭新而美好的人生。\n　　如果非要和最亲的人说最狠的话，那好好的家可能就会在陈芝麻烂谷子的旧账里失守了幸福。\n　　 “人非圣贤，孰能无过。”结痂的伤疤不必再揭，曾经的错误无需再苛责。从容过活，就是谅己；把握当下，就是珍惜。\n　　余生，愿我们都能明白：小事不争不辩，彼此越理解，感情越和睦；大事有商有量，双方越信任，生活越幸福；往事看轻看淡，家人越包容，家庭越兴旺。\n","categories":["其他"],"tags":[]},{"title":"xml和对象转换工具类（JAXB）","url":"https://www.mele.cool/2020/12/04/xml与对象转换工具类(JAXB)/","content":"package com.haier.otcwms.util;import java.io.StringReader;import java.io.StringWriter;import javax.xml.bind.JAXB;import javax.xml.bind.JAXBException;/*** * xml与对象互转 */public class XmlUtil &#123;\t//xml字符串转化成对象\tpublic static Object jaxbUnmarshalString(String xml, Class&lt;?&gt; type) throws JAXBException &#123;\t\treturn JAXB.unmarshal(new StringReader(xml), type);\t&#125;\t//对象转化成xml字符串\tpublic static String jaxbMarshalString(Object obj) &#123;\t\tStringWriter stringWriter = new StringWriter();\t\tJAXB.marshal(obj, stringWriter);\t\treturn stringWriter.toString();\t&#125;&#125;","categories":["工具类"],"tags":["tool","xml"]},{"title":"不重启清空catalina.out","url":"https://www.mele.cool/2020/12/04/不重启清空catalina.out/","content":"1.重定向方法清空文件[root@localhost logs]# du -h catalina.out  查看文件大小17M catalina.out[root@localhost logs]# &gt; catalina.out             重定向清空文件[root@localhost logs]# du -h catalina.out       查看文件大小0 catalina.out \n2.使用true命令重定向清空文件[root@localhost logs]# du -h catalina.out448K catalina.out[root@localhost logs]# true &gt; catalina.out [root@localhost logs]# du -h catalina.out 0 catalina.out\n3、使用cat/cp/dd命令及/dev/null设备来清空文件cat /dev/null &gt; catalina.outcp  /dev/null &gt; catalina.outdd if=/dev/null of=catalina.out\n4、使用echo命令清空文件echo -n  &quot; &quot; &gt; catalina.out   \n==》加上”-n”参数，默认情况下会”\\n”，也就是回车符\n5、使用truncate命令清空文件truncate -s 0 catalina.out   \n-s参数是设置文件的大小，清空文件的话，就设定为0\nfrom  https://www.cnblogs.com/centos2017/p/9922959.html\n","categories":["linux"],"tags":["linux","tomcat","日志"]},{"title":"事务隔离级别","url":"https://www.mele.cool/2020/12/04/事务隔离级别/","content":"1.事务的特性？任何支持事务的数据库，都必须具备四个特性，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），也就是我们常说的事务ACID，这样才能保证事务（（Transaction）中数据的正确性。\n2.隔离性隔离性是指，多个并发的事务同时访问一个数据库时，一个事务不应该被另一个事务所干扰，每个并发的事务间要相互进行隔离。\n如果没有事务隔离，会出现什么样的情况呢？\n假设我们现在有这样一张表（T），里面记录了很多牛人的名字，我们不进行事务的隔离看看会发生什么呢？\n\n脏读—A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据\n\n\n第一天，事务A访问了数据库，它干了一件事情，往数据库里加上了新来的牛人的名字，但是没有提交事务。\ninsert into T values (4, ‘牛D’);\n这时，来了另一个事务B，他要查询所有牛人的名字。\nselect Name from T;\n这时，如果没有事务之间没有有效隔离，那么事务B返回的结果中就会出现“牛D”的名字。这就是“脏读（dirty read）”。\n\n\n不可重复度—前后多次读取，数据内容不一致\n\n\n第二天，事务A访问了数据库，他要查看ID是1的牛人的名字，于是执行了\nselect Name from T where ID = 1;\n这时，事务B来了，因为ID是1的牛人改名字了，所以要更新一下，然后提交了事务。\nupdate T set Name = ‘不牛’ where ID = 1;\n接着，事务A还想再看看ID是1的牛人的名字，于是又执行了\nselect Name from T where ID = 1;\n结果，两次读出来的ID是1的牛人名字竟然不相同，这就是不可重复读（unrepeatable read）。\n\n\n幻读—前后多次读取，数据总量不一致\n\n\n第三天，事务A访问了数据库，他想要看看数据库的牛人都有哪些，于是执行了\nselect * from T;\n这时候，事务B来了，往数据库加入了一个新的牛人。\ninsert into T values(4, ‘牛D’);\n这时候，事务A忘了刚才的牛人都有哪些了，于是又执行了。\nselect * from T;\n结果，第一次有三个牛人，第二次有四个牛人。\n相信这个时候事务A就蒙了，刚才发生了什么？这种情况就叫“幻读（phantom problem）”。\n\n3.隔离级别一般的数据库，都包括以下四种隔离级别：\n\n读未提交（Read Uncommitted）\n\n读提交（Read Committed）\n\n可重复读（Repeated Read）\n\n串行化（Serializable）\n\n读未提交（Read Uncommitted）\n\n\n读未提交，顾名思义，就是可以读到未提交的内容。\n因此，在这种隔离级别下，查询是不会加锁的，也由于查询的不加锁，所以这种隔离级别的一致性是最差的，可能会产生“脏读”、“不可重复读”、“幻读”。\n如无特殊情况，基本是不会使用这种隔离级别的。\n\n\n读提交（Read Committed）\n\n\n读提交，顾名思义，就是只能读到已经提交了的内容。\n这是各种系统中最常用的一种隔离级别，也是SQL Server和Oracle的默认隔离级别。这种隔离级别能够有效的避免脏读，但除非在查询中显示的加锁，如：\nselect * from T where ID=2 lock in share mode;\nselect * from T where ID=2 for update;\n不然，普通的查询是不会加锁的。\n那为什么“读提交”同“读未提交”一样，都没有查询加锁，但是却能够避免脏读呢？\n这就要说道另一个机制“快照（snapshot）”，而这种既能保证一致性又不加锁的读也被称为“快照读（Snapshot Read）”\n假设没有“快照读”，那么当一个更新的事务没有提交时，另一个对更新数据进行查询的事务会因为无法查询而被阻塞，这种情况下，并发能力就相当的差。\n而“快照读”就可以完成高并发的查询，不过，“读提交”只能避免“脏读”，并不能避免“不可重复读”和“幻读”。\n\n\n可重复读(Repeated Read)\n\n\n可重复读，顾名思义，就是专门针对“不可重复读”这种情况而制定的隔离级别，自然，它就可以有效的避免“不可重复读”。而它也是MySql的默认隔离级别。\n在这个级别下，普通的查询同样是使用的“快照读”，但是，和“读提交”不同的是，当事务启动时，就不允许进行“修改操作（Update）”了，而“不可重复读”恰恰是因为两次读取之间进行了数据的修改，因此，“可重复读”能够有效的避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于“插入或者删除操作（Insert or Delete）”而产生的。\n\n\n串行化（Serializable）\n\n\n这是数据库最高的隔离级别，这种级别下，事务“串行化顺序执行”，也就是一个一个排队执行。\n这种级别下，“脏读”、“不可重复读”、“幻读”都可以被避免，但是执行效率奇差，性能开销也最大，所以基本没人会用。\n\n4.总结一下\n为什么会出现“脏读”？因为“select”操作没有规矩。\n为什么会出现“不可重复读”？因为“update”操作没有规矩。\n为什么会出现“幻读”？因为“insert”和“delete”操作没有规矩。\n“读未提（Read Uncommitted）”能预防啥？啥都预防不了。\n“读提交（Read Committed）”能预防啥？使用“快照读（Snapshot Read）”，避免“脏读”，但是可能出现“不可重复读”和“幻读”。\n“可重复读（Repeated Red）”能预防啥？使用“快照读（Snapshot Read）”，锁住被读取记录，避免出现“脏读”、“不可重复读”，但是可能出现“幻读”。\n“串行化（Serializable）”能预防啥？排排坐，吃果果，有效避免“脏读”、“不可重复读”、“幻读”，不过效果谁用谁知道。\n\n转自:  https://baijiahao.baidu.com/s?id=1611918898724887602&amp;wfr=spider&amp;for=pc\n","categories":["db"],"tags":["事务","acid"]},{"title":"代码中有意思注释","url":"https://www.mele.cool/2020/12/04/代码中有意思注释/","content":"System.out.println(&quot;/***\\n&quot; +        &quot; *                    .::::.\\n&quot; +        &quot; *                  .::::::::.\\n&quot; +        &quot; *                 :::::::::::  \\n&quot; +        &quot; *             ..:::::::::::&#x27;\\n&quot; +        &quot; *           &#x27;::::::::::::&#x27;\\n&quot; +        &quot; *             .::::::::::\\n&quot; +        &quot; *        &#x27;::::::::::::::..\\n&quot; +        &quot; *             ..::::::::::::.\\n&quot; +        &quot; *           ``::::::::::::::::\\n&quot; +        &quot; *            ::::``:::::::::&#x27;        .:::.\\n&quot; +        &quot; *           ::::&#x27;   &#x27;:::::&#x27;       .::::::::.\\n&quot; +        &quot; *         .::::&#x27;      ::::     .:::::::&#x27;::::.\\n&quot; +        &quot; *        .:::&#x27;       :::::  .:::::::::&#x27; &#x27;:::::.\\n&quot; +        &quot; *       .::&#x27;        :::::.:::::::::&#x27;      &#x27;:::::.\\n&quot; +        &quot; *      .::&#x27;         ::::::::::::::&#x27;         ``::::.\\n&quot; +        &quot; *  ...:::           ::::::::::::&#x27;              ``::.\\n&quot; +        &quot; * ```` &#x27;:.          &#x27;:::::::::&#x27;                  ::::..\\n&quot; +        &quot; *                    &#x27;.:::::&#x27;                    &#x27;:&#x27;````..\\n&quot; +        &quot; */&quot;);System.out.println(&quot;\\n&quot; +        &quot;/***\\n&quot; +        &quot; * ┌───┐   ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐\\n&quot; +        &quot; * │Esc│   │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│  ┌┐    ┌┐    ┌┐\\n&quot; +        &quot; * └───┘   └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘  └┘    └┘    └┘\\n&quot; +        &quot; * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐\\n&quot; +        &quot; * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │\\n&quot; +        &quot; * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤\\n&quot; +        &quot; * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123; [│&#125; ]│ | \\\\ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │   │\\n&quot; +        &quot; * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │\\n&quot; +        &quot; * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│\\&quot; &#x27;│ Enter  │               │ 4 │ 5 │ 6 │   │\\n&quot; +        &quot; * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤     ┌───┐     ├───┼───┼───┼───┤\\n&quot; +        &quot; * │ Shift  │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│  Shift   │     │ ↑ │     │ 1 │ 2 │ 3 │   │\\n&quot; +        &quot; * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││\\n&quot; +        &quot; * │ Ctrl│    │Alt │         Space         │ Alt│    │    │Ctrl│ │ ← │ ↓ │ → │ │   0   │ . │←─┘│\\n&quot; +        &quot; * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘\\n&quot; +        &quot; */&quot;);System.out.println(&quot;/***\\n&quot; +        &quot; *                    _ooOoo_\\n&quot; +        &quot; *                   o8888888o\\n&quot; +        &quot; *                   88\\&quot; . \\&quot;88\\n&quot; +        &quot; *                   (| -_- |)\\n&quot; +        &quot; *                    O\\\\ = /O\\n&quot; +        &quot; *                ____/`---&#x27;\\\\____\\n&quot; +        &quot; *              .   &#x27; \\\\\\\\| |// `.\\n&quot; +        &quot; *               / \\\\\\\\||| : |||// \\\\\\n&quot; +        &quot; *             / _||||| -:- |||||- \\\\\\n&quot; +        &quot; *               | | \\\\\\\\\\\\ - /// | |\\n&quot; +        &quot; *             | \\\\_| &#x27;&#x27;\\\\---/&#x27;&#x27; | |\\n&quot; +        &quot; *              \\\\ .-\\\\__ `-` ___/-. /\\n&quot; +        &quot; *           ___`. .&#x27; /--.--\\\\ `. . __\\n&quot; +        &quot; *        .\\&quot;\\&quot; &#x27;&lt; `.___\\\\_&lt;|&gt;_/___.&#x27; &gt;&#x27;\\&quot;\\&quot;.\\n&quot; +        &quot; *       | | : `- \\\\`.;`\\\\ _ /`;.`/ - ` : | |\\n&quot; +        &quot; *         \\\\ \\\\ `-. \\\\_ __\\\\ /__ _/ .-` / /\\n&quot; +        &quot; * ======`-.____`-.___\\\\_____/___.-`____.-&#x27;======\\n&quot; +        &quot; *                    `=---=&#x27;\\n&quot; +        &quot; *\\n&quot; +        &quot; * .............................................\\n&quot; +        &quot; */&quot;);System.out.println(&quot;/***\\n&quot; +        &quot; *      ┌─┐       ┌─┐\\n&quot; +        &quot; *   ┌──┘ ┴───────┘ ┴──┐\\n&quot; +        &quot; *   │                 │\\n&quot; +        &quot; *   │       ───       │\\n&quot; +        &quot; *   │  ─┬┘       └┬─  │\\n&quot; +        &quot; *   │                 │\\n&quot; +        &quot; *   │       ─┴─       │\\n&quot; +        &quot; *   │                 │\\n&quot; +        &quot; *   └───┐         ┌───┘\\n&quot; +        &quot; *       │         │\\n&quot; +        &quot; *       │         │\\n&quot; +        &quot; *       │         │\\n&quot; +        &quot; *       │         └──────────────┐\\n&quot; +        &quot; *       │                        │\\n&quot; +        &quot; *       │                        ├─┐\\n&quot; +        &quot; *       │                        ┌─┘\\n&quot; +        &quot; *       │                        │\\n&quot; +        &quot; *       └─┐  ┐  ┌───────┬──┐  ┌──┘\\n&quot; +        &quot; *         │ ─┤ ─┤       │ ─┤ ─┤\\n&quot; +        &quot; *         └──┴──┘       └──┴──┘\\n&quot; +        &quot; *                神兽保佑\\n&quot; +        &quot; *               代码无BUG!\\n&quot; +        &quot; */&quot;);System.out.println(&quot;/***\\n&quot; +        &quot; *_______________#########_______________________\\n&quot; +        &quot; *______________############_____________________\\n&quot; +        &quot; *______________#############____________________\\n&quot; +        &quot; *_____________##__###########___________________\\n&quot; +        &quot; *____________###__######_#####__________________\\n&quot; +        &quot; *____________###_#######___####_________________\\n&quot; +        &quot; *___________###__##########_####________________\\n&quot; +        &quot; *__________####__###########_####_______________\\n&quot; +        &quot; *________#####___###########__#####_____________\\n&quot; +        &quot; *_______######___###_########___#####___________\\n&quot; +        &quot; *_______#####___###___########___######_________\\n&quot; +        &quot; *______######___###__###########___######_______\\n&quot; +        &quot; *_____######___####_##############__######______\\n&quot; +        &quot; *____#######__#####################_#######_____\\n&quot; +        &quot; *____#######__##############################____\\n&quot; +        &quot; *___#######__######_#################_#######___\\n&quot; +        &quot; *___#######__######_######_#########___######___\\n&quot; +        &quot; *___#######____##__######___######_____######___\\n&quot; +        &quot; *___#######________######____#####_____#####____\\n&quot; +        &quot; *____######________#####_____#####_____####_____\\n&quot; +        &quot; *_____#####________####______#####_____###______\\n&quot; +        &quot; *______#####______;###________###______#________\\n&quot; +        &quot; *________##_______####________####______________\\n&quot; +        &quot; */&quot;);System.out.println(&quot;                              _(\\\\_/) \\n&quot; +        &quot;                             ,((((^`\\\\\\n&quot; +        &quot;                            ((((  (6 \\\\ \\n&quot; +        &quot;                          ,((((( ,    \\\\\\n&quot; +        &quot;      ,,,_              ,(((((  /\\&quot;._  ,`,\\n&quot; +        &quot;     ((((\\\\\\\\ ,...       ,((((   /    `-.-&#x27;\\n&quot; +        &quot;     )))  ;&#x27;    `\\&quot;&#x27;\\&quot;&#x27;\\&quot;\\&quot;((((   (      \\n&quot; +        &quot;    (((  /            (((      \\\\\\n&quot; +        &quot;     )) |                      |\\n&quot; +        &quot;    ((  |        .       &#x27;     |\\n&quot; +        &quot;    ))  \\\\     _ &#x27;      `t   ,.&#x27;)\\n&quot; +        &quot;    (   |   y;- -,-\\&quot;\\&quot;&#x27;\\&quot;-.\\\\   \\\\/  \\n&quot; +        &quot;    )   / ./  ) /         `\\\\  \\\\\\n&quot; +        &quot;       |./   ( (           / /&#x27;\\n&quot; +        &quot;       ||     \\\\\\\\          //&#x27;|\\n&quot; +        &quot;       ||      \\\\\\\\       _//&#x27;||\\n&quot; +        &quot;       ||       ))     |_/  ||\\n&quot; +        &quot;       \\\\_\\\\     |_/          ||\\n&quot; +        &quot;       `&#x27;\\&quot;                  \\\\_\\\\\\n&quot; +        &quot;                            `&#x27;\\&quot; &quot;);System.out.println(&quot;/***\\n&quot; +        &quot; *          .,:,,,                                        .::,,,::.\\n&quot; +        &quot; *        .::::,,;;,                                  .,;;:,,....:i:\\n&quot; +        &quot; *        :i,.::::,;i:.      ....,,:::::::::,....   .;i:,.  ......;i.\\n&quot; +        &quot; *        :;..:::;::::i;,,:::;:,,,,,,,,,,..,.,,:::iri:. .,:irsr:,.;i.\\n&quot; +        &quot; *        ;;..,::::;;;;ri,,,.                    ..,,:;s1s1ssrr;,.;r,\\n&quot; +        &quot; *        :;. ,::;ii;:,     . ...................     .;iirri;;;,,;i,\\n&quot; +        &quot; *        ,i. .;ri:.   ... ............................  .,,:;:,,,;i:\\n&quot; +        &quot; *        :s,.;r:... ....................................... .::;::s;\\n&quot; +        &quot; *        ,1r::. .............,,,.,,:,,........................,;iir;\\n&quot; +        &quot; *        ,s;...........     ..::.,;:,,.          ...............,;1s\\n&quot; +        &quot; *       :i,..,.              .,:,,::,.          .......... .......;1,\\n&quot; +        &quot; *      ir,....:rrssr;:,       ,,.,::.     .r5S9989398G95hr;. ....,.:s,\\n&quot; +        &quot; *     ;r,..,s9855513XHAG3i   .,,,,,,,.  ,S931,.,,.;s;s&amp;BHHA8s.,..,..:r:\\n&quot; +        &quot; *    :r;..rGGh,  :SAG;;G@BS:.,,,,,,,,,.r83:      hHH1sXMBHHHM3..,,,,.ir.\\n&quot; +        &quot; *   ,si,.1GS,   sBMAAX&amp;MBMB5,,,,,,:,,.:&amp;8       3@HXHBMBHBBH#X,.,,,,,,rr\\n&quot; +        &quot; *   ;1:,,SH:   .A@&amp;&amp;B#&amp;8H#BS,,,,,,,,,.,5XS,     3@MHABM&amp;59M#As..,,,,:,is,\\n&quot; +        &quot; *  .rr,,,;9&amp;1   hBHHBB&amp;8AMGr,,,,,,,,,,,:h&amp;&amp;9s;   r9&amp;BMHBHMB9:  . .,,,,;ri.\\n&quot; +        &quot; *  :1:....:5&amp;XSi;r8BMBHHA9r:,......,,,,:ii19GG88899XHHH&amp;GSr.      ...,:rs.\\n&quot; +        &quot; *  ;s.     .:sS8G8GG889hi.        ....,,:;:,.:irssrriii:,.        ...,,i1,\\n&quot; +        &quot; *  ;1,         ..,....,,isssi;,        .,,.                      ....,.i1,\\n&quot; +        &quot; *  ;h:               i9HHBMBBHAX9:         .                     ...,,,rs,\\n&quot; +        &quot; *  ,1i..            :A#MBBBBMHB##s                             ....,,,;si.\\n&quot; +        &quot; *  .r1,..        ,..;3BMBBBHBB#Bh.     ..                    ....,,,,,i1;\\n&quot; +        &quot; *   :h;..       .,..;,1XBMMMMBXs,.,, .. :: ,.               ....,,,,,,ss.\\n&quot; +        &quot; *    ih: ..    .;;;, ;;:s58A3i,..    ,. ,.:,,.             ...,,,,,:,s1,\\n&quot; +        &quot; *    .s1,....   .,;sh,  ,iSAXs;.    ,.  ,,.i85            ...,,,,,,:i1;\\n&quot; +        &quot; *     .rh: ...     rXG9XBBM#M#MHAX3hss13&amp;&amp;HHXr         .....,,,,,,,ih;\\n&quot; +        &quot; *      .s5: .....    i598X&amp;&amp;A&amp;AAAAAA&amp;XG851r:       ........,,,,:,,sh;\\n&quot; +        &quot; *      . ihr, ...  .         ..                    ........,,,,,;11:.\\n&quot; +        &quot; *         ,s1i. ...  ..,,,..,,,.,,.,,.,..       ........,,.,,.;s5i.\\n&quot; +        &quot; *          .:s1r,......................       ..............;shs,\\n&quot; +        &quot; *          . .:shr:.  ....                 ..............,ishs.\\n&quot; +        &quot; *              .,issr;,... ...........................,is1s;.\\n&quot; +        &quot; *                 .,is1si;:,....................,:;ir1sr;,\\n&quot; +        &quot; *                    ..:isssssrrii;::::::;;iirsssssr;:..\\n&quot; +        &quot; *                         .,::iiirsssssssssrri;;:.\\n&quot; +        &quot; */&quot;);System.out.println(&quot;/***\\n&quot; +        &quot; *  .--,       .--,\\n&quot; +        &quot; * ( (  \\\\.---./  ) )\\n&quot; +        &quot; *  &#x27;.__/o   o\\\\__.&#x27;\\n&quot; +        &quot; *     &#123;=  ^  =&#125;\\n&quot; +        &quot; *      &gt;  -  &lt;\\n&quot; +        &quot; *     /       \\\\\\n&quot; +        &quot; *    //       \\\\\\\\\\n&quot; +        &quot; *   //|   .   |\\\\\\\\\\n&quot; +        &quot; *   \\&quot;&#x27;\\\\       /&#x27;\\&quot;_.-~^`&#x27;-.\\n&quot; +        &quot; *      \\\\  _  /--&#x27;         `\\n&quot; +        &quot; *    ___)( )(___\\n&quot; +        &quot; *   (((__) (__)))    高山仰止,景行行止.虽不能至,心向往之。\\n&quot; +        &quot; */&quot;);System.out.println(&quot;\\n&quot; +        &quot;/***\\n&quot; +        &quot; * ░░░░░░░░░░░░░░░░░░░░░░░░▄░░\\n&quot; +        &quot; * ░░░░░░░░░▐█░░░░░░░░░░░▄▀▒▌░\\n&quot; +        &quot; * ░░░░░░░░▐▀▒█░░░░░░░░▄▀▒▒▒▐\\n&quot; +        &quot; * ░░░░░░░▐▄▀▒▒▀▀▀▀▄▄▄▀▒▒▒▒▒▐\\n&quot; +        &quot; * ░░░░░▄▄▀▒░▒▒▒▒▒▒▒▒▒█▒▒▄█▒▐\\n&quot; +        &quot; * ░░░▄▀▒▒▒░░░▒▒▒░░░▒▒▒▀██▀▒▌\\n&quot; +        &quot; * ░░▐▒▒▒▄▄▒▒▒▒░░░▒▒▒▒▒▒▒▀▄▒▒\\n&quot; +        &quot; * ░░▌░░▌█▀▒▒▒▒▒▄▀█▄▒▒▒▒▒▒▒█▒▐\\n&quot; +        &quot; * ░▐░░░▒▒▒▒▒▒▒▒▌██▀▒▒░░░▒▒▒▀▄\\n&quot; +        &quot; * ░▌░▒▄██▄▒▒▒▒▒▒▒▒▒░░░░░░▒▒▒▒\\n&quot; +        &quot; * ▀▒▀▐▄█▄█▌▄░▀▒▒░░░░░░░░░░▒▒▒\\n&quot; +        &quot; * 单身狗就这样默默地看着你，一句话也不说。\\n&quot; +        &quot; */\\n&quot;);","categories":["其他"],"tags":["java","注释"]},{"title":"使用springboot发送邮件","url":"https://www.mele.cool/2020/12/04/使用Spring Boot发送邮件/","content":"在项目的维护过程中，我们通常会在应用中加入短信或者邮件预警功能，比如当应用出现异常宕机时应该及时地将预警信息发送给运维或者开发人员，本文将介绍如何在Spring Boot中发送邮件。在Spring Boot中发送邮件使用的是Spring提供的org.springframework.mail.javamail.JavaMailSender，其提供了许多简单易用的方法，可发送简单的邮件、HTML格式的邮件、带附件的邮件，并且可以创建邮件模板。\n引入依赖在Spring Boot中发送邮件，需要用到spring-boot-starter-mail，引入spring-boot-starter-mail：\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt;\n邮件配置在application.yml中进行简单的配置（以163邮件为例）：\nserver:  port: 80spring:  mail:    host: smtp.163.com    username: 你的账号    password: 你的密码    properties:      mail:        smtp:          auth: true          starttls:            enable: true            required: true\nspring.mail.username，spring.mail.password填写自己的邮箱账号密码(smtp服务的授权码)即可。\n发送简单的邮件编写EmailController，注入JavaMailSender:\nimport org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(&quot;/email&quot;)public class EmailController &#123;    @Autowired    private JavaMailSender jms;        @Value(&quot;$&#123;spring.mail.username&#125;&quot;)    private String from;        @RequestMapping(&quot;sendSimpleEmail&quot;)    public String sendSimpleEmail() &#123;        try &#123;            SimpleMailMessage message = new SimpleMailMessage();            message.setFrom(from);            message.setTo(&quot;888888@qq.com&quot;); // 接收地址            message.setSubject(&quot;一封简单的邮件&quot;); // 标题            message.setText(&quot;使用Spring Boot发送简单邮件。&quot;); // 内容            jms.send(message);            return &quot;发送成功&quot;;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return e.getMessage();        &#125;    &#125;&#125;\n启动项目访问http://localhost/email/sendSimpleEmail，提示发送成功：\n\n发送HTML格式的邮件改造EmailController，SimpleMailMessage替换为MimeMessage：\nimport javax.mail.internet.MimeMessage;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(&quot;/email&quot;)public class EmailController &#123;    @Autowired    private JavaMailSender jms;        @Value(&quot;$&#123;spring.mail.username&#125;&quot;)    private String from;        @RequestMapping(&quot;sendHtmlEmail&quot;)    public String sendHtmlEmail() &#123;        MimeMessage message = null;        try &#123;            message = jms.createMimeMessage();            MimeMessageHelper helper = new MimeMessageHelper(message, true);            helper.setFrom(from);             helper.setTo(&quot;888888@qq.com&quot;); // 接收地址            helper.setSubject(&quot;一封HTML格式的邮件&quot;); // 标题            // 带HTML格式的内容            StringBuffer sb = new StringBuffer(&quot;&lt;p style=&#x27;color:#6db33f&#x27;&gt;使用Spring Boot发送HTML格式邮件。&lt;/p&gt;&quot;);            helper.setText(sb.toString(), true);            jms.send(message);            return &quot;发送成功&quot;;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return e.getMessage();        &#125;    &#125;&#125;\nhelper.setText(sb.toString(), true);中的true表示发送HTML格式邮件。启动项目，访问http://localhost/email/sendHtmlEmail，提示发送成功，可看到文本已经加上了颜色#6db33f：\n\n发送带附件的邮件发送带附件的邮件和普通邮件相比，其实就只是多了个传入附件的过程。不过使用的仍是MimeMessage：\npackage com.springboot.demo.controller;import java.io.File;import javax.mail.internet.MimeMessage;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.core.io.FileSystemResource;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(&quot;/email&quot;)public class EmailController &#123;    @Autowired    private JavaMailSender jms;        @Value(&quot;$&#123;spring.mail.username&#125;&quot;)    private String from;\t    @RequestMapping(&quot;sendAttachmentsMail&quot;)    public String sendAttachmentsMail() &#123;        MimeMessage message = null;        try &#123;            message = jms.createMimeMessage();            MimeMessageHelper helper = new MimeMessageHelper(message, true);            helper.setFrom(from);             helper.setTo(&quot;888888@qq.com&quot;); // 接收地址            helper.setSubject(&quot;一封带附件的邮件&quot;); // 标题            helper.setText(&quot;详情参见附件内容！&quot;); // 内容            // 传入附件            FileSystemResource file = new FileSystemResource(new File(&quot;src/main/resources/static/file/项目文档.docx&quot;));            helper.addAttachment(&quot;项目文档.docx&quot;, file);            jms.send(message);            return &quot;发送成功&quot;;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return e.getMessage();        &#125;    &#125;&#125;\n启动项目访问http://localhost/email/sendAttachmentsMail，提示发送成功：\n\n发送带静态资源的邮件发送带静态资源的邮件其实就是在发送HTML邮件的基础上嵌入静态资源（比如图片），嵌入静态资源的过程和传入附件类似，唯一的区别在于需要标识资源的cid：\npackage com.springboot.demo.controller;import java.io.File;import javax.mail.internet.MimeMessage;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.core.io.FileSystemResource;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(&quot;/email&quot;)public class EmailController &#123;    @Autowired    private JavaMailSender jms;        @Value(&quot;$&#123;spring.mail.username&#125;&quot;)    private String from;\t    @RequestMapping(&quot;sendInlineMail&quot;)    public String sendInlineMail() &#123;        MimeMessage message = null;        try &#123;            message = jms.createMimeMessage();            MimeMessageHelper helper = new MimeMessageHelper(message, true);            helper.setFrom(from);             helper.setTo(&quot;888888@qq.com&quot;); // 接收地址            helper.setSubject(&quot;一封带静态资源的邮件&quot;); // 标题            helper.setText(&quot;&lt;html&gt;&lt;body&gt;博客图：&lt;img src=&#x27;cid:img&#x27;/&gt;&lt;/body&gt;&lt;/html&gt;&quot;, true); // 内容            // 传入附件            FileSystemResource file = new FileSystemResource(new File(&quot;src/main/resources/static/img/sunshine.png&quot;));            helper.addInline(&quot;img&quot;, file);             jms.send(message);            return &quot;发送成功&quot;;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return e.getMessage();        &#125;    &#125;&#125;\nhelper.addInline(“img”, file);中的img和图片标签里cid后的名称相对应。启动项目访问http://localhost/email/sendInlineMail，提示发送成功：\n\n使用模板发送邮件在发送验证码等情况下可以创建一个邮件的模板，唯一的变量为验证码。这个例子中使用的模板解析引擎为Thymeleaf，所以首先引入Thymeleaf依赖：\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;\n在template目录下创建一个emailTemplate.html模板：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;模板&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    您好，您的验证码为&#123;code&#125;，请在两分钟内使用完成操作。&lt;/body&gt;&lt;/html&gt;\n发送模板邮件，本质上还是发送HTML邮件，只不过多了绑定变量的过程，详细如下所示：\npackage com.springboot.demo.controller;import java.io.File;import javax.mail.internet.MimeMessage;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.core.io.FileSystemResource;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.thymeleaf.TemplateEngine;import org.thymeleaf.context.Context;@RestController@RequestMapping(&quot;/email&quot;)public class EmailController &#123;    @Autowired    private JavaMailSender jms;        @Value(&quot;$&#123;spring.mail.username&#125;&quot;)    private String from;        @Autowired    private TemplateEngine templateEngine;\t    @RequestMapping(&quot;sendTemplateEmail&quot;)    public String sendTemplateEmail(String code) &#123;        MimeMessage message = null;        try &#123;            message = jms.createMimeMessage();            MimeMessageHelper helper = new MimeMessageHelper(message, true);            helper.setFrom(from);             helper.setTo(&quot;888888@qq.com&quot;); // 接收地址            helper.setSubject(&quot;邮件摸板测试&quot;); // 标题            // 处理邮件模板            Context context = new Context();            context.setVariable(&quot;code&quot;, code);            String template = templateEngine.process(&quot;emailTemplate&quot;, context);            helper.setText(template, true);            jms.send(message);            return &quot;发送成功&quot;;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return e.getMessage();        &#125;    &#125;&#125;\n其中code对应模板里的${code}变量。启动项目，访问http://localhost/email/sendTemplateEmail?code=EOS9，页面提示发送成功：\n\n\n源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/22.Spring-Boot-Email\n\n\n本文作者： MrBird本文链接： http://mrbird.cc/Spring-Boot-Email.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明出处！\n\n","categories":["springboot"],"tags":["springboot","邮件"]},{"title":"命令生成公钥私钥文件","url":"https://www.mele.cool/2020/12/04/命令生成公钥私钥文件/","content":"# 一直回车就可以看到id_rsa和id_rsa.pub这两个文件$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; \n.ssh文件位置：\n\nwindows:  C:\\Users\\Administrator.ssh\n\n\n\nmac      :  ~/.ssh\n\n","categories":["版本控制"],"tags":["git","公钥"]},{"title":"少年，不要滥用箭头函数啊","url":"https://www.mele.cool/2020/12/04/少年，不要滥用箭头函数啊/","content":"在ES6大行其道的今天，不应用点ES6特性似乎有些政治不正确。最近刚好有个Node的项目，最低要支持到nodejs 4.0，在node.green看了下ES6的支持度，我想使用的特性基本都有支持，遂决定在新项目中采用ES6来写。\n当然第一件事情就是毫不留情地消灭var，项目中能用const的地方不用let，能用let的地方不用var。\n第二件事情就是使用劳动人民喜闻乐见的箭头函数替代function。当我心满意足地看到满屏的 =&gt; 时，现实给了我一记响亮的耳光——改过之后的程序错误百出！\n所以，当我们使用箭头函数时，一定要搞清楚箭头函数是什么回事，适用于什么场景。本文就针对以上问题来讨论下箭头函数。\n箭头函数是什么？箭头函数的语法我就不讲了，相信大家都见识过。跟我一样，大家喜欢箭头函数90%的原因是它好看。除了好看，它是不是与function等价呢？肯定不等价，因为TC39不可能仅因为好看而引入一个语法糖（class除外）。\n箭头函数的渊源可以追溯到上古时期一个叫lambda演算的东西。lambda演算是数学家提出来的，有些数学家跟我们程序员一样也很懒，数学定理那么多，今天要证三角定律，明天要证勾股定律，累不累！那能不能将所有的证明问题用一个统一的体系进行形式化描述，然后由机器来完成自动推导呢？lambda演算就是干这个的，图灵也搞了一套体系叫图灵机，两者是等价的。\n关于lambda演算说了这么多，好像跟今天要讲的箭头函数没什么关系？其实是有关系的，lambda演算深刻影响了箭头函数的设计。数学家们喜欢用纯函数式编程语言，纯函数的特点是没有副作用，给予特定的输入，总是产生确定的输出，甚至有些情况下通过输出能够反推输入。要实现纯函数，必须使函数的执行过程不依赖于任何外部状态，整个函数就像一个数学公式，给定一套输入参数，不管是在地球上还是火星上执行都是同一个结果。\n箭头函数要实现类似纯函数的效果，必须剔除外部状态。所以当你定义一个箭头函数，在普通函数里常见的 this 、 arguments 、 caller 是统统没有的。\n箭头函数没有 this箭头函数没有 this ，那下面的代码明显可以取到 this 啊：\nfunction foo() &#123;  let a = 1  let b = () =&gt; console.log(this.a)  b()&#125;foo()  // 1\n以上箭头函数中的 this 其实是父级作用域中的 this ，即函数 foo 的 this 。箭头函数引用了父级的变量，构成了一个闭包。以上代码等价于：\nfunction foo() &#123;  let a = 1  let self = this  let b = () =&gt; console.log(self.a)  b()&#125;foo()  // 1\n箭头函数不仅没有 this ，常用的 arguments 也没有。如果你能获取到 arguments ，那它一定是来自父作用域的。\nfunction foo() &#123;  return () =&gt; console.log(arguments[0])&#125;foo(1, 2)(3, 4)  // 1\n上例中如果箭头函数有 arguments ，就应该输出的是3而不是1。\n一个经常犯的错误是使用箭头函数定义对象的方法，如：\nlet a = &#123;  foo: 1,  bar: () =&gt; console.log(this.foo)&#125;a.bar()  //undefined\n以上代码中，箭头函数中的 this 并不是指向 a 这个对象。对象 a 并不能构成一个作用域，所以再往上到达全局作用域， this 就指向全局作用域。如果我们使用普通函数的定义方法，输出结果就符合预期，这是因为 a.bar() 函数执行时作用域绑定到了 a 对象。\nlet a = &#123;  foo: 1,  bar: function() &#123; console.log(this.foo) &#125;&#125;a.bar()  //undefined\n另一个错误是在原型上使用箭头函数，如：\nfunction A() &#123;  this.foo = 1&#125;A.prototype.bar = () =&gt; console.log(this.foo)let a = new A()a.bar()  //undefined\n同样，箭头函数中的 this 不是指向 A ，而是根据变量查找规则回溯到了全局作用域。同样，使用普通函数就不存在问题。\n通过以上说明，我们可以看出，箭头函数除了传入的参数之外，真的是什么都没有！如果你在箭头函数引用了 this 、 arguments 或者参数之外的变量，那它们一定不是箭头函数本身包含的，而是从父级作用域继承的。\n什么情况下该使用箭头函数到这里，我们可以发现箭头函数并不是万金油，稍不留神就会踩坑。\n至于什么情况该使用箭头函数，《You Don’t Know About JS》给出了一个决策图：\n以上决策图看起来有点复杂，我认为有三点比较重要：\n箭头函数适合于无复杂逻辑或者无副作用的纯函数场景下，例如用在 map 、 reduce 、 filter 的回调函数定义中；不要在最外层定义箭头函数，因为在函数内部操作 this 会很容易污染全局作用域。最起码在箭头函数外部包一层普通函数，将 this 控制在可见的范围内；如开头所述，箭头函数最吸引人的地方是简洁。在有多层函数嵌套的情况下，箭头函数的简洁性并没有很大的提升，反而影响了函数的作用范围的识别度，这种情况不建议使用箭头函数。\n来自：https://jingsam.github.io/2016/12/08/things-you-should-know-about-arrow-functions.html\n","categories":["js"],"tags":["js","箭头函数"]},{"title":"成长","url":"https://www.mele.cool/2020/12/04/成长/","content":"[]\n\n[]\n\n\n","categories":["mele"],"tags":["mele"]},{"title":"接口和抽象类","url":"https://www.mele.cool/2020/12/04/接口和抽象类/","content":"1. 抽象类\n  什么是抽象类:    包含一个抽象方法的类就是抽象类    抽象方法:    声明而未被实现的方法，抽象方法必须使用abstract关键词字声明\n\npublic abstract class People &#123;  //关键词abstract，声明该类为抽象类\t\tpublic int age;\t\tpublic void Num() &#123;    &#125;    public abstract Name(); //声明该方法为抽象方法\t&#125;\n\n抽象类被子类继承，子类（如果不是抽象类）必须重写抽象类中的所有抽象方法\n抽象类不能被直接实例化，要通过其子类进行实例化 \n只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。\n子类中的抽象方法不能与父类的抽象方法同名。\nabstract不能与final并列修饰同一个类。\nabstract不能与private、static、final或native并列修饰同一个方法。\n\n为什么需要用到抽象类？\n在下面这个例子中，把打印机类封装成抽象类，把print定义成抽象类，当HPPrinter和CannonPrinter要继承printer类的时候，必须重写print函数。这样写的好处是，每个打印机都有自己打印方式，此举可以防止子类没有写明打印方式。\n\npublic abstract void Printer() &#123;    public void open() &#123;        system.out.print(&quot;打印机开启&quot;);    &#125;    public void close() &#123;        system.out.print(&quot;打印机关闭&quot;);    &#125;    abstract void print();  //把print方法定义为抽象方法&#125;public HPPrinter extends Printer &#123;    void print()&#123;             //必须重写抽象方法print()           system.out.print(&quot;惠普打印机开始打印&quot;);    &#125;;&#125;public CanonPrinter extends Printer &#123;    void print()&#123;             //必须重写抽象方法print()        system.out.print(&quot;佳能打印机开始打印&quot;);    &#125;;&#125;\n2. 接口\n接口是java中最重要的概念，接口可以理解为一种特殊的类，里面全部是由全局常量和公共的抽象方法组成,接口中所有方法都是抽象方法.接口当中所有的方法都是public类型.\n\n接口的格式:\ninterface interfaceName&#123;    全局常量    抽象方法&#125;\n接口的实现也必须通过子类，使用关键字implements，而且接口是可以多实现的\nclass A implements Inter1,Inter2&#123; //Inter1和Inter2是接口    ...&#125;\n一个类可以同时继承抽象类和接口\nclass A extends Abs implements Inter1,Inter2&#123; //Abs是一个抽象类    ...&#125;\n一个接口不能继承抽象类，但可以通过implements关键字继承多个接口，实现接口的多继承\ninterface Inter implements Inter1,Inter2&#123; //Inter、Inter1、Inter2都为接口    ...&#125;\n3. 抽象类和接口区别3.1 语法层次public abstract class People {  //关键词abstract，声明该类为抽象类    void Num();　　　　　　    abstract void Name(); 　　　//声明该方法为抽象方法}\nInterface Person {　　void Num();　　void Name();}　抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。\n3.2 设计层次1. 抽象层次不同抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。\n2. 跨域不同抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。\n3. 设计层次不同对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n\n语法规范区别：1）接口不能有构造方法，抽象类可以有。2）接口不能有方法体，抽象类可以有。3）接口不能有静态方法，抽象类可以有。4）在接口中凡是变量必须是public static final(只能是常量)，而在抽象类中没有要求。5)抽象类可以定义非抽象方法，而接口中所有的方法都是抽象的\n\n相同点:    都不能被实例化,只能通过子类实例化.    都可以被继承.    都可以实现程序的多态性.不同点:    语法层次:抽象类用abstract关键字修饰类为抽象类,接口Interface;    语法规范:        1）接口不能有构造方法，抽象类可以有。        2）接口不能有方法体，抽象类可以有。        3）接口不能有静态方法，抽象类可以有。        4）在接口中凡是变量必须是public static final(只能是常量)，而在抽象类中没有要求。\n相同点:都不能被实例化,只能通过子类实例化.\n都可以被继承.\n都可以实现程序的多态性.\n\n不同点:语法层次:抽象类用abstract关键字修饰类为抽象类,接口Interface;\n语法规范:\n    1）接口不能有构造方法，抽象类可以有。\n    2）接口不能有方法体，抽象类可以有。\n    3）接口不能有静态方法，抽象类可以有。\n    4）在接口中凡是变量必须是public static final(只能是常量)，而在抽象类中没有要求。\n    5)抽象类可以定义非抽象方法，而接口中所有的方法都是抽象的        5)抽象类可以定义非抽象方法，而接口中所有的方法都是抽象的\n\n作者：FantJ链接：https://www.jianshu.com/p/b0cf5d770a86来源：简书作者: 健健csdn链接:https://blog.csdn.net/weixin_39788493/article/details/80854547来源: CSDN著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","categories":["java"],"tags":["java","接口","抽象类"]},{"title":"消息队列面试题","url":"https://www.mele.cool/2020/12/04/消息队列面试题汇总/","content":"1.消息队列的应用场景有哪些？答：消息队列的应用场景如下。\n\n应用解耦，比如，用户下单后，订单系统需要通知库存系统，假如库存系统无法访问，则订单减库存将失败，从而导致订单失败。订单系统与库存系统耦合，这个时候如果使用消息队列，可以返回给用户成功，先把消息持久化，等库存系统恢复后，就可以正常消费减去库存了。\n削峰填谷，比如，秒杀活动，一般会因为流量过大，从而导致流量暴增，应用挂掉，这个时候加上消息队列，服务器接收到用户的请求后，首先写入消息队列，假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面。\n日志系统，比如，客户端负责将日志采集，然后定时写入消息队列，消息队列再统一将日志数据存储和转发。\n\n2.RabbitMQ 有哪些优点？答：RabbitMQ 的优点如下：\n\n可靠性，RabbitMQ 的持久化支持，保证了消息的稳定性；\n高并发，RabbitMQ 使用了 Erlang 开发语言，Erlang 是为电话交换机开发的语言，天生自带高并发光环和高可用特性；\n集群部署简单，正是因为 Erlang 使得 RabbitMQ 集群部署变的非常简单；\n社区活跃度高，因为 RabbitMQ 应用比较广泛，所以社区的活跃度也很高；\n解决问题成本低，因为资料比较多，所以解决问题的成本也很低；\n支持多种语言，主流的编程语言都支持，如 Java、.NET、PHP、Python、JavaScript、Ruby、Go 等；\n插件多方便使用，如网页控制台消息管理插件、消息延迟插件等。\n\n3.RabbitMQ 有哪些重要的角色？答：RabbitMQ 包含以下三个重要的角色：\n\n生产者：消息的创建者，负责创建和推送数据到消息服务器；\n消费者：消息的接收方，用于处理数据和确认消息；\n代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。\n\n4.RabbitMQ 有哪些重要的组件？它们有什么作用？答：RabbitMQ 包含的重要组件有：ConnectionFactory（连接管理器）、Channel（信道）、Exchange（交换器）、Queue（队列）、RoutingKey（路由键）、BindingKey（绑定键） 等重要的组件，它们的作用如下：\n\nConnectionFactory（连接管理器）：应用程序与 RabbitMQ 之间建立连接的管理器，程序代码中使用；\nChannel（信道）：消息推送使用的通道；\nExchange（交换器）：用于接受、分配消息；\nQueue（队列）：用于存储生产者的消息；\nRoutingKey（路由键）：用于把生成者的数据分配到交换器上；\nBindingKey（绑定键）：用于把交换器的消息绑定到队列上。\n\n运行流程，如下图所示：\n\n5.什么是消息持久化？答：消息持久化是把消息保存到物理介质上，以防止消息的丢失。\n6.RabbitMQ 要实现消息持久化，需要满足哪些条件？答：RabbitMQ 要实现消息持久化，必须满足以下 4 个条件：\n\n投递消息的时候 durable 设置为 true，消息持久化，代码：channel.queueDeclare(x, true, false, false, null)，参数 2 设置为 true 持久化；\n设置投递模式 deliveryMode 设置为 2（持久），代码：channel.basicPublish(x, x, MessageProperties.PERSISTENTTEXTPLAIN,x)，参数 3 设置为存储纯文本到磁盘；\n消息已经到达持久化交换器上；\n消息已经到达持久化的队列。\n\n7.消息持久化有哪些缺点？如何缓解？答：消息持久化的缺点是很消耗性能，因为要写入硬盘要比写入内存性能较低很多，从而降低了服务器的吞吐量。可使用固态硬盘来提高读写速度，以达到缓解消息持久化的缺点。\n8.如何使用 Java 代码连接 RabbitMQ？答：使用 Java 代码连接 RabbitMQ 有以下两种方式：\n方式一：\npublic static Connection GetRabbitConnection() &#123;    ConnectionFactory factory = new ConnectionFactory();    factory.setUsername(Config.UserName);    factory.setPassword(Config.Password);    factory.setVirtualHost(Config.VHost);    factory.setHost(Config.Host);    factory.setPort(Config.Port);    Connection conn = null;    try &#123;        conn = factory.newConnection();    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;    return conn;&#125;\n方式二：\npublic static Connection GetRabbitConnection2() &#123;    ConnectionFactory factory = new ConnectionFactory();    // 连接格式：amqp://userName:password@hostName:portNumber/virtualHost    String uri = String.format(&quot;amqp://%s:%s@%s:%d%s&quot;, Config.UserName, Config.Password, Config.Host, Config.Port,            Config.VHost);    Connection conn = null;    try &#123;        factory.setUri(uri);        factory.setVirtualHost(Config.VHost);        conn = factory.newConnection();    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;    return conn;&#125;\n9.使用 Java 代码编写一个 RabbitMQ 消费和生产的示例？答：代码如下：\npublic static void main(String[] args) &#123;    publisher();     // 生产消息    consumer();     // 消费消息&#125;/** * 推送消息 */public static void publisher() &#123;    // 创建一个连接    Connection conn = ConnectionFactoryUtil.GetRabbitConnection();    if (conn != null) &#123;        try &#123;            // 创建通道            Channel channel = conn.createChannel();            // 声明队列【参数说明：参数一：队列名称，参数二：是否持久化；参数三：是否独占模式；参数四：消费者断开连接时是否删除队列；参数五：消息其他参数】            channel.queueDeclare(Config.QueueName, false, false, false, null);            String content = String.format(&quot;当前时间：%s&quot;, new Date().getTime());            // 发送内容【参数说明：参数一：交换机名称；参数二：队列名称，参数三：消息的其他属性-routing headers，此属性为MessageProperties.PERSISTENT_TEXT_PLAIN用于设置纯文本消息存储到硬盘；参数四：消息主体】            channel.basicPublish(&quot;&quot;, Config.QueueName, null, content.getBytes(&quot;UTF-8&quot;));            System.out.println(&quot;已发送消息：&quot; + content);            // 关闭连接            channel.close();            conn.close();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;/** * 消费消息 */public static void consumer() &#123;    // 创建一个连接    Connection conn = ConnectionFactoryUtil.GetRabbitConnection();    if (conn != null) &#123;        try &#123;            // 创建通道            Channel channel = conn.createChannel();            // 声明队列【参数说明：参数一：队列名称，参数二：是否持久化；参数三：是否独占模式；参数四：消费者断开连接时是否删除队列；参数五：消息其他参数】            channel.queueDeclare(Config.QueueName, false, false, false, null);            // 创建订阅器，并接受消息            channel.basicConsume(Config.QueueName, false, &quot;&quot;, new DefaultConsumer(channel) &#123;                @Override                public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,                        byte[] body) throws IOException &#123;                    String routingKey = envelope.getRoutingKey(); // 队列名称                    String contentType = properties.getContentType(); // 内容类型                    String content = new String(body, &quot;utf-8&quot;); // 消息正文                    System.out.println(&quot;消息正文：&quot; + content);                    channel.basicAck(envelope.getDeliveryTag(), false); // 手动确认消息【参数说明：参数一：该消息的index；参数二：是否批量应答，true批量确认小于index的消息】                &#125;            &#125;);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n10.RabbitMQ 交换器类型有哪些？答：RabbitMQ 消费类型也就是交换器（Exchange）类型有以下四种：\n\ndirect：轮询方式\nheaders：轮询方式，允许使用 header 而非路由键匹配消息，性能差，几乎不用\nfanout：广播方式，发送给所有订阅者\ntopic：匹配模式，允许使用正则表达式匹配消息\n\nRabbitMQ 默认的是 direct 方式。\n11.RabbitMQ 如何确保每个消息能被消费？答：RabbitMQ 使用 ack 消息确认的方式保证每个消息都能被消费，开发者可根据自己的实际业务，选择 channel.basicAck() 方法手动确认消息被消费。\n12.RabbitMQ 接收到消息之后必须消费吗？答：RabbitMQ 接收到消息之后可以不消费，在消息确认消费之前，可以做以下两件事：\n\n拒绝消息消费，使用 channel.basicReject(消息编号, true) 方法，消息会被分配给其他订阅者；\n设置为死信队列，死信队列是用于专门存放被拒绝的消息队列。\n\n13.topic 模式下发布了一个路由键为“com.mq.rabbit.error”的消息，请问以下不能接收到消息的是？A：cn.mq.rabbit.*B：#.errorC：cn.mq.*D：cn.mq.#\n答：C\n题目解析：“*”用于匹配一个分段（用“.”分割）的内容，“#”用于匹配 0 和多个字符。\n14.以下可以获取历史消息的是？A：topic 交换器B：fanout 交换器C：direct 交换器D：以上都不是\n答：C\n题目解析：fanout 和 topic 都是广播形式的，因此无法获取历史消息，而 direct 可以。\n15.RabbitMQ 包含事务功能吗？如何使用？答：RabbitMQ 包含事务功能，主要是对信道（Channel）的设置，主要方法有以下三个：\n\nchannel.txSelect() 声明启动事务模式；\nchannel.txComment() 提交事务；\nchannel.txRollback() 回滚事务。\n\n16.RabbitMQ 的事务在什么情况下是无效的？答：RabbitMQ 的事务在 autoAck=true 也就是自动消费确认的时候，事务是无效的。因为如果是自动消费确认，RabbitMQ 会直接把消息从队列中移除，即使后面事务回滚也不能起到任何作用。\n17.Kafka 可以脱离 ZooKeeper 单独使用吗？答：Kafka 不能脱离 ZooKeeper 单独使用，因为 Kafka 使用 ZooKeeper 管理和协调 Kafka 的节点服务器。\n18.Kafka 有几种数据保留的策略？答：Kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。\n19.Kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 Kafka 将如何处理？答：这个时候 Kafka 会执行数据清除工作，时间和大小不论哪个满足条件，都会清空数据。\n20.什么情况会导致 Kafka 运行变慢？答：以下情况可导致 Kafka 运行变慢：\n\nCPU 性能瓶颈\n磁盘读写瓶颈\n网络瓶颈\n\n21.使用 Kafka 集群需要注意什么？答：Kafka 集群使用需要注意以下事项：\n\n集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低；\n集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。\n\n","categories":["mq"],"tags":["mq","ms"]},{"title":"深入学习springboot自动装配","url":"https://www.mele.cool/2020/12/04/深入学习Spring Boot自动装配/","content":"\n模式注解\n\n\n@Enable模块驱动\n\n\n自动装配\n\n模式注解Stereotype Annotation俗称为模式注解，Spring中常见的模式注解有@Service，@Repository，@Controller等，它们都“派生”自@Component注解。我们都知道，凡是被@Component标注的类都会被Spring扫描并纳入到IOC容器中，那么由@Component派生的注解所标注的类也会被扫描到IOC容器中。下面我们主要通过自定义模式注解来了解@Component的“派生性”和“层次性”。\n@Component “派生性”新建一个Spring Boot工程，Spring Boot版本为2.1.0.RELEASE，artifactId为autoconfig，并引入spring-boot-starter-web依赖。项目结构如下所示:\n\n在com.example.demo下新建annotation包，然后创建一个FirstLevelService注解：\n@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Servicepublic @interface FirstLevelService &#123;    String value() default &quot;&quot;;&#125;\n这个注解定义由@Service标注，查看@Service的源码会发现其被@Component注解标注，所以它们的层次关系为:\n└─@Component   └─@Service      └─@FirstLevelService\n\n\n即@FirstLevelService为@Component派生出来的模式注解，我们来测试一下被它标注的类是否能够被扫描到IOC容器中：\n在com.example.demo下新建service包，然后创建一个TestService类：\n@FirstLevelServicepublic class TestService &#123;&#125;\n\n\n在com.example.demo下新建bootstrap包，然后创建一个ServiceBootStrap类，用于测试注册TestService并从IOC容器中获取它：\n@ComponentScan(&quot;com.example.demo.service&quot;)public class ServiceBootstrap &#123;    public static void main(String[] args) &#123;        ConfigurableApplicationContext context = new SpringApplicationBuilder(ServiceBootstrap.class)                .web(WebApplicationType.NONE)                .run(args);        TestService testService = context.getBean(&quot;testService&quot;, TestService.class);        System.out.println(&quot;TestService Bean: &quot; + testService);        context.close();    &#125;&#125;\n\n\n运行该类的main方法，控制台输出如下：\n\n@Component “层次性”我们在com.example.demo.annotation路径下再创建一个SecondLevelService注解定义，该注解由上面的@FirstLevelService标注：\n@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@FirstLevelServicepublic @interface SecondLevelService &#123;    String value() default &quot;&quot;;&#125;\n\n\n这时候层次关系为：\n└─@Component   └─@Service      └─@FirstLevelService            └─@SecondLevelService\n\n\n我们将TestService上的注解换成@SecondLevelService，然后再次运行ServiceBootStrap的main方法，输出如下：\n\n可见结果也是成功的。\n这里有一点需要注意的是：@Component注解只包含一个value属性定义，所以其“派生”的注解也只能包含一个value属性定义。\n@Enable模块驱动@Enable模块驱动在Spring Framework 3.1后开始支持。这里的模块通俗的来说就是一些为了实现某个功能的组件的集合。通过@Enable模块驱动，我们可以开启相应的模块功能。\n@Enable模块驱动可以分为“注解驱动”和“接口编程”两种实现方式，下面逐一进行演示：\n注解驱动Spring中，基于注解驱动的示例可以查看@EnableWebMvc源码：\n@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)@Documented@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)public @interface EnableWebMvc &#123;&#125;\n\n\n该注解通过@Import导入一个配置类DelegatingWebMvcConfiguration：\n\n该配置类又继承自WebMvcConfigurationSupport，里面定义了一些Bean的声明。\n所以，基于注解驱动的@Enable模块驱动其实就是通过@Import来导入一个配置类，以此实现相应模块的组件注册，当这些组件注册到IOC容器中，这个模块对应的功能也就可以使用了。\n我们来定义一个基于注解驱动的@Enable模块驱动。\n在com.example.demo下新建configuration包，然后创建一个HelloWorldConfiguration配置类：\n@Configurationpublic class HelloWorldConfiguration &#123;    @Bean    public String hello() &#123;        return &quot;hello world&quot;;    &#125;&#125;\n\n\n这个配置类里定义了一个名为hello的Bean，内容为hello world。\n在com.example.demo.annotation下创建一个EnableHelloWorld注解定义：\n@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(HelloWorldConfiguration.class)public @interface EnableHelloWorld &#123;&#125;\n\n\n我们在该注解类上通过@Import导入了刚刚创建的配置类。\n接着在com.example.demo.bootstrap下创建一个TestEnableBootstap启动类来测试@EnableHelloWorld注解是否生效：\n@EnableHelloWorldpublic class TestEnableBootstap &#123;    public static void main(String[] args) &#123;        ConfigurableApplicationContext context = new SpringApplicationBuilder(TestEnableBootstap.class)                .web(WebApplicationType.NONE)                .run(args);        String hello = context.getBean(&quot;hello&quot;, String.class);        System.out.println(&quot;hello Bean: &quot; + hello);        context.close();    &#125;&#125;\n\n\n运行该类的main方法，控制台输出如下：\n\n说明我们自定义的基于注解驱动的@EnableHelloWorld是可行的。\n接口编程除了使用上面这个方式外，我们还可以通过接口编程的方式来实现@Enable模块驱动。Spring中，基于接口编程方式的有@EnableCaching注解，查看其源码：\n@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(&#123;CachingConfigurationSelector.class&#125;)public @interface EnableCaching &#123;    boolean proxyTargetClass() default false;    AdviceMode mode() default AdviceMode.PROXY;    int order() default 2147483647;&#125;\nEnableCaching注解通过@Import导入了CachingConfigurationSelector类，该类间接实现了ImportSelector接口，在 深入学习Spring组件注册 中，我们曾介绍了可以通过ImportSelector来实现组件注册。\n所以通过接口编程实现@Enable模块驱动的本质是：通过@Import来导入接口ImportSelector实现类，该实现类里可以定义需要注册到IOC容器中的组件，以此实现相应模块对应组件的注册。\n接下来我们根据这个思路来自个实现一遍：\n在com.example.demo下新建selector包，然后在该路径下新建一个HelloWorldImportSelector实现ImportSelector接口：\npublic class HelloWorldImportSelector implements ImportSelector &#123;    @Override    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;        return new String[]&#123;HelloWorldConfiguration.class.getName()&#125;;    &#125;&#125;\n\n\n如果看不懂上面这段代码含义的朋友可以阅读深入学习Spring组件注册一文。\n接着我们修改EnableHelloWorld：\n@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(HelloWorldImportSelector.class)public @interface EnableHelloWorld &#123;&#125;\n\n\n上面导入的是HelloWorldImportSelector，而非HelloWorldConfiguration。\n再次运行TestEnableBootstap的main方法，你会发现输出是一样的。\n自动装配Spring Boot中的自动装配技术底层主要用到了下面这些技术:\n\nSpring 模式注解装配\nSpring @Enable 模块装配\nSpring 条件装配装（深入学习Spring组件注册中有介绍）\nSpring 工厂加载机制\n\nSpring 工厂加载机制的实现类为SpringFactoriesLoader，查看其源码：\n\n该类的方法会读取META-INF目录下的spring.factories配置文件，我们查看spring-boot-autoconfigure-2.1.0.RELEASE.jar下的该文件：\n\n\n当启动类被@EnableAutoConfiguration标注后，上面截图中的所有类Spring都会去扫描，看是否可以纳入到IOC容器中进行管理。\n比如我们查看org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration的源码：\n\n可看到该类上标注了一些注解，其中@Configuration为模式注解，@EnableConfigurationProperties为模块装配技术，ConditionalOnClass为条件装配技术。这和我们上面列出的Spring Boot自动装配底层主要技术一致，所以我们可以根据这个思路来自定义一个自动装配实现。\n新建一个配置类HelloWorldAutoConfiguration：\n@Configuration@EnableHelloWorld@ConditionalOnProperty(name = &quot;helloworld&quot;, havingValue = &quot;true&quot;)public class HelloWorldAutoConfiguration &#123;&#125;\n\n\n然后在resources目录下新建META-INF目录，并创建spring.factories文件：\n# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.example.demo.configuration.HelloWorldAutoConfiguration\n接着在配置文件application.properties中添加helloworld=true配置\nhelloworld=true\n\n\n最后创建EnableAutoConfigurationBootstrap，测试下HelloWorldAutoConfiguration是否生效：\n@EnableAutoConfigurationpublic class EnableAutoConfigurationBootstrap &#123;    public static void main(String[] args) &#123;        ConfigurableApplicationContext context = new SpringApplicationBuilder(EnableAutoConfigurationBootstrap.class)                .web(WebApplicationType.NONE)                .run(args);        String hello = context.getBean(&quot;hello&quot;, String.class);        System.out.println(&quot;hello Bean: &quot; + hello);        context.close();    &#125;&#125;\n\n\n运行该main方法，控制台输出如下：\n\n说明我们自定义的自动装配已经成功了。\n下面简要分析下代码的运行逻辑：\n\nSpring 的工厂加载机制会自动读取META-INF目录下spring.factories文件内容；\n\n我们在spring.factories定义了：\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.example.demo.configuration.HelloWorldAutoConfiguration\n我们在测试类上使用了@EnableAutoConfiguration注解标注，那么HelloWorldAutoConfiguration就会被Spring扫描，看是否符合要求，如果符合则纳入到IOC容器中；\n\nHelloWorldAutoConfiguration上的@ConditionalOnProperty的注解作用为：当配置文件中配置了helloworld=true（我们确实添加了这个配置，所以符合要求）则这个类符合扫描规则；@EnableHelloWorld注解是我们前面例子中自定义的模块驱动注解，其引入了hello这个Bean，所以IOC容器中便会存在hello这个Bean了；\n\n通过上面的步骤，我们就可以通过上下文获取到hello这个Bean了。\n\n\n\n源码链接： https://github.com/wuyouzhuguli/SpringAll/tree/master/44.Spring-Boot-Autoconfiguration\nFROM:https://mrbird.cc/deepin-springboot-autoconfig.html\n\n","categories":["springboot"],"tags":["springboot","自动装配"]},{"title":"监控dubbo服务","url":"https://www.mele.cool/2020/12/04/监控Dubbo服务/","content":"Dubbo给我们提供了dubbo-admin和dubbo-monitor-simple用于监控Dubbo服务，可以用来监控接口暴露，注册情况，也可以显示接口的调用明细和调用时间。dubbo-admin和dubbo-monitor-simple的下载地址为：https://github.com/apache/incubator-dubbo-admin/tree/master，这里简单介绍它们如何使用。\n1.准备要监控Dubbo服务，首先我们必须在Dubbo应用上提供连接监控中心的配置，Dubbo支持两种方式：\n\n\n\n属性\n对应URL参数\n类型\n是否必填\n缺省值\n作用\n描述\n兼容性\n\n\n\nprotocol\nprotocol\nstring\n可选\ndubbo\n服务治理\n监控中心协议，如果为protocol=”registry”， 表示从注册中心发现监控中心地址， 否则直连监控中心。\n2.0.9以上版本\n\n\naddress\n\nstring\n可选\nN/A\n服务治理\n直连监控中心服务器地址，address=”10.20.130.230:12080”\n1.0.16以上版本\n\n\n这里我们采用第一种方式，在上一节中的server-provider和server-consumer的配置文件中添加如下配置:\ndubbo:  monitor:    protocol: registry\n\n\n配置好后，依次启动server-provider和server-consumer，接下来开始搭建监控中心。\n2.dubbo-monitor-simple下载https://github.com/apache/incubator-dubbo-admin/tree/master源码后，使用IDEA导入dubbo-monitor-simple应用，修改其配置文件dubbo.properties内容：\ndubbo.container=log4j,spring,registry,jetty-monitordubbo.application.name=simple-monitordubbo.application.owner=dubbodubbo.registry.address=zookeeper://127.0.0.1:2181dubbo.protocol.port=7070dubbo.jetty.port=7000dubbo.jetty.directory=$&#123;user.home&#125;/monitordubbo.charts.directory=$&#123;user.home&#125;/monitor/chartsdubbo.statistics.directory=$&#123;user.home&#125;/monitor/statisticsdubbo.log4j.file=logs/dubbo-monitor-simple.logdubbo.log4j.level=WARN\n\n\n上面主要指定了注册中心地址为zookeeper://127.0.0.1:2181，监控中心协议端口为7070以及监控应用访问端口为7000。\n配置好后，运行启动类MonitorStarter的main方法来启动应用，启动后，访问http://localhost:7000便可看到如下页面：\n\n在线应用信息:\n\n多次访问http://localhost:8081/hello/mrbird后，便可以在监控中心查看服务调用情况：\n\n\n3.dubbo-admin使用IDEA导入dubbo-admin应用，修改其配置文件application.properties：\nserver.port=7001spring.velocity.cache=falsespring.velocity.charset=UTF-8spring.velocity.layout-url=/templates/default.vmspring.messages.fallback-to-system-locale=falsespring.messages.basename=i18n/messagespring.root.password=rootspring.guest.password=guestdubbo.registry.address=zookeeper://127.0.0.1:2181\n\n\n上面配置主要配置了注册中心地址为zookeeper://127.0.0.1:2181，应用端口号为7001，root和guest账户的密码。\n配置好后，启动应用（dubbo-admin使用Spring Boot构建，启动入口类即可），访问http://localhost:7001：\n\n\n\n\nduubo提供了新版的dubbo-admin，采用前后端分离的方式，前端由Vue.js构建，UI更为nice，不过还不完善，所以这里就不介绍了。\n源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/52.Dubbo-OPS-Mointor\n\n本文作者： MrBird\n本文链接： http://mrbird.cc/dubbo-mointor.html\n版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明出处！\n\n","categories":["java"],"tags":["dubbo","监控"]},{"title":"线程池Executors","url":"https://www.mele.cool/2020/12/04/线程池Executors/","content":"线程池的创建分为两种方式：ThreadPoolExecutor 和 Executors\nExecutors可以创建以下6种线程池:\n\nFixedThreadPool(n)：创建一个数量固定的线程池，超出的任务会在队列中等待空闲的线程，可用于控制程序的最大并发数。\n\n\n\n\nCachedThreadPool()：短时间内处理大量工作的线程池，会根据任务数量产生对应的线程，并试图缓存线程以便重复使用，如果限制 60 秒没被使用，则会被移除缓存。\n\n\n\n\nSingleThreadExecutor()：创建一个单线程线程池。\n\n\n\n\nScheduledThreadPool(n)：创建一个数量固定的线程池，支持执行定时性或周期性任务。\n\n\n\n\nSingleThreadScheduledExecutor()：此线程池就是单线程的 newScheduledThreadPool。\n\n\n\n\nWorkStealingPool(n)：Java 8 新增创建线程池的方法，创建时如果不设置任何参数，则以当前机器处理器个数作为线程个数，此线程池会并行处理任务，不能保证执行顺序。\n\n\n下面分别来看以上六种线程池的具体代码使用。\n1.FixedThreadPool 创建固定个数的线程池，具体示例如下：ExecutorService fixedThreadPool = Executors.newFixedThreadPool(2);for (int i = 0; i &lt; 3; i++) &#123;    fixedThreadPool.execute(() -&gt; &#123;        System.out.println(&quot;CurrentTime - &quot; + LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)));        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;);&#125;//以上程序执行结果如下：   // CurrentTime - 2019-06-27 20:58:58    //CurrentTime - 2019-06-27 20:58:58   // CurrentTime - 2019-06-27 20:58:59\n\n根据执行结果可以看出，newFixedThreadPool(2) 确实是创建了两个线程，在执行了一轮（2 次）之后，停了一秒，有了空闲线程，才执行第三次。\n\n2.CachedThreadPool 根据实际需要自动创建带缓存功能的线程池，具体代码如下：ExecutorService cachedThreadPool = Executors.newCachedThreadPool();for (int i = 0; i &lt; 10; i++) &#123;    cachedThreadPool.execute(() -&gt; &#123;        System.out.println(&quot;CurrentTime - &quot; +                           LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)));        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;);&#125;以上程序执行结果如下：        CurrentTime - 2019-06-27 21:24:46        CurrentTime - 2019-06-27 21:24:46        CurrentTime - 2019-06-27 21:24:46        CurrentTime - 2019-06-27 21:24:46        CurrentTime - 2019-06-27 21:24:46        CurrentTime - 2019-06-27 21:24:46        CurrentTime - 2019-06-27 21:24:46        CurrentTime - 2019-06-27 21:24:46        CurrentTime - 2019-06-27 21:24:46        CurrentTime - 2019-06-27 21:24:46\n\n根据执行结果可以看出，newCachedThreadPool 在短时间内会创建多个线程来处理对应的任务，并试图把它们进行缓存以便重复使用。\n\n3.SingleThreadExecutor 创建单个线程的线程池，具体代码如下：ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();for (int i = 0; i &lt; 3; i++) &#123;    singleThreadExecutor.execute(() -&gt; &#123;        System.out.println(&quot;CurrentTime - &quot; +                           LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)));        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;);&#125;//以上程序执行结果如下：        CurrentTime - 2019-06-27 21:43:34        CurrentTime - 2019-06-27 21:43:35        CurrentTime - 2019-06-27 21:43:36\n\n4.ScheduledThreadPool 创建一个可以执行周期性任务的线程池，具体代码如下：ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(2);scheduledThreadPool.schedule(() -&gt; &#123;    System.out.println(&quot;ThreadPool：&quot; + LocalDateTime.now());&#125;, 1L, TimeUnit.SECONDS);System.out.println(&quot;CurrentTime：&quot; + LocalDateTime.now());//以上程序执行结果如下：    CurrentTime：2019-06-27T21:54:21.881    ThreadPool：2019-06-27T21:54:22.845\n\n根据执行结果可以看出，我们设置的 1 秒后执行的任务生效了。\n\n5.SingleThreadScheduledExecutor 创建一个可以执行周期性任务的单线程池，具体代码如下：  ScheduledExecutorService singleThreadScheduledExecutor = Executors.newSingleThreadScheduledExecutor();  singleThreadScheduledExecutor.schedule(() -&gt; {      System.out.println(“ThreadPool：” + LocalDateTime.now());  }, 1L, TimeUnit.SECONDS);  System.out.println(“CurrentTime：” + LocalDateTime.now());\n6.WorkStealingPool Java 8 新增的创建线程池的方式，可根据当前电脑 CPU 处理器数量生成相应个数的线程池，使用代码如下：ExecutorService workStealingPool =     Executors.newWorkStealingPool();for (int i = 0; i &lt; 5; i++) &#123;    int finalNumber = i;    workStealingPool.execute(() -&gt; &#123;        System.out.println(&quot;I：&quot; + finalNumber);    &#125;);&#125;Thread.sleep(5000);//以上程序执行结果如下：        I：0        I：3        I：2        I：1        I：4\n\n根据执行结果可以看出，newWorkStealingPool 是并行处理任务的，并不能保证执行顺序。\n\nThreadPoolExecutor VS Executors\nThreadPoolExecutor 和 Executors 都是用来创建线程池的，其中 ThreadPoolExecutor 创建线程池的方式相对传统，而 Executors 提供了更多的线程池类型（6 种），但很不幸的消息是在实际开发中并不推荐使用 Executors 的方式来创建线程池。\n\n\n《阿里巴巴 Java 开发手册》中对于线程池的创建也是这样规定的，内容如下：\n\n\n线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的读者更加明确线程池的运行规则，规避资源耗尽的风险。\n\n###说明：Executors 返回的线程池对象的弊端如下：\n1）FixedThreadPool 和 SingleThreadPool:\n\n允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM(OutOfMemoryError 的缩写，指内存溢出的意思)。\n\n2）CachedThreadPool 和 ScheduledThreadPool:\n\n允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\n\n举个栗子:\nExecutorService maxFixedThreadPool =  Executors.newFixedThreadPool(10);for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123;    maxFixedThreadPool.execute(()-&gt;&#123;        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;);&#125;\n之后设置 JVM（Java 虚拟机）的启动参数： -Xmx10m -Xms10m （设置 JVM 最大运行内存等于 10M）运行程序，会抛出 OOM 异常，信息如下：\n Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded at java.util.concurrent.LinkedBlockingQueue.offer(LinkedBlockingQueue.java:416) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1371) at xxx.main(xxx.java:127)\n为什么 Executors 会存在 OOM 的缺陷？\n通过以上代码，找到了 FixedThreadPool 的源码，代码如下：\npublic static ExecutorService newFixedThreadPool(int nThreads) &#123;        return new ThreadPoolExecutor(nThreads, nThreads,                                      0L, TimeUnit.MILLISECONDS,                                      new LinkedBlockingQueue&lt;Runnable&gt;());&#125;\n可以看到创建 FixedThreadPool 使用了 LinkedBlockingQueue 作为任务队列，继续查看 LinkedBlockingQueue 的源码就会发现问题的根源，源码如下：\npublic LinkedBlockingQueue() &#123;    this(Integer.MAX_VALUE);&#125;\n当使用 LinkedBlockingQueue 并没有给它指定长度的时候，默认长度为 Integer.MAX_VALUE，这样就会导致程序会给线程池队列添加超多个任务，因为任务量太大就有造成 OOM 的风险。\n\n相关面试题1.Executors 能创建单线程的线程池吗？怎么创建？\n\n答：Executors 可以创建单线程线程池，创建分为两种方式：\n\n\nExecutors.newSingleThreadExecutor()：创建一个单线程线程池。\n\n\nExecutors.newSingleThreadScheduledExecutor()：创建一个可以执行周期性任务的单线程池。\n\n2.Executors 中哪个线程适合执行短时间内大量任务？\n\n答：newCachedThreadPool() 适合处理大量短时间工作任务。它会试图缓存线程并重用，如果没有缓存任务就会新创建任务，如果线程的限制时间超过六十秒，则会被移除线程池，因此它比较适合短时间内处理大量任务。\n\n3.可以执行周期性任务的线程池都有哪些？\n\n答：可执行周期性任务的线程池有两个，分别是：newScheduledThreadPool() 和 newSingleThreadScheduledExecutor()，其中 newSingleThreadScheduledExecutor() 是 newScheduledThreadPool() 的单线程版本。\n\n4.JDK 8 新增了什么线程池？有什么特点？\n\n答：JDK 8 新增的线程池是 newWorkStealingPool(n)，如果不指定并发数（也就是不指定 n），newWorkStealingPool() 会根据当前 CPU 处理器数量生成相应个数的线程池。它的特点是并行处理任务的，不能保证任务的执行顺序。\n\n5.newFixedThreadPool 和 ThreadPoolExecutor 有什么关系？\n\n答：newFixedThreadPool 是 ThreadPoolExecutor 包装，newFixedThreadPool 底层也是通过 ThreadPoolExecutor 实现的。\n\n6.单线程的线程池存在的意义是什么？\n\n答：单线程线程池提供了队列功能，如果有多个任务会排队执行，可以保证任务执行的顺序性。单线程线程池也可以重复利用已有线程，减低系统创建和销毁线程的性能开销。\n\n7.线程池为什么建议使用 ThreadPoolExecutor 创建，而非 Executors？\n\n答：使用 ThreadPoolExecutor 能让开发者更加明确线程池的运行规则，避免资源耗尽的风险。\n\n\nExecutors 返回线程池的缺点如下：\n\n\nFixedThreadPool 和 SingleThreadPool 允许请求队列长度为 Integer.MAX_VALUE，可能会堆积大量请求，可能会导致内存溢出；\n\n\nCachedThreadPool 和 ScheduledThreadPool 允许创建线程数量为 Integer.MAX_VALUE，创建大量线程，可能会导致内存溢出。\n\n","categories":["java"],"tags":["java","线程池","executors"]},{"title":"线程池之ThreadPollExecutor","url":"https://www.mele.cool/2020/12/04/线程池之 ThreadPoolExecutor/","content":"线程池之 ThreadPoolExecutor线程池介绍线程池（Thread Pool）：把一个或多个线程通过统一的方式进行调度和重复使用的技术，避免了因为线程过多而带来使用上的开销。\n为什么要使用线程池？\n可重复使用已有线程，避免对象创建、消亡和过度切换的性能开销。\n避免创建大量同类线程所导致的资源过度竞争和内存溢出的问题。\n支持更多功能，比如延迟任务线程池（newScheduledThreadPool）和缓存线程池（newCachedThreadPool）等。\n\n线程池使用创建线程池有两种方式：ThreadPoolExecutor 和 Executors，其中 Executors 又可以创建 6 种不同的线程池类型，会在下节讲，本节重点来看看 ThreadPoolExecutor 的使用。\nThreadPoolExecutor 的使用线程池使用代码如下：\nThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 10, 10L, TimeUnit.SECONDS, new LinkedBlockingQueue(100));threadPoolExecutor.execute(new Runnable() &#123;    @Override    public void run() &#123;        // 执行线程池        System.out.println(&quot;Hello, Java.&quot;);    &#125;&#125;);\n以上程序执行结果如下：\n\nHello, Java.\n\nThreadPoolExecutor 参数说明ThreadPoolExecutor 构造方法有以下四个，如下图所示：\n\n其中最后一个构造方法有 7 个构造参数，包含了前三个方法的构造参数，这 7 个参数名称如下所示：\npublic ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler) &#123;    //...&#125;\n其代表的含义如下：\n① corePoolSize线程池中的核心线程数，默认情况下核心线程一直存活在线程池中，如果将 ThreadPoolExecutor 的 allowCoreThreadTimeOut 属性设为 true，如果线程池一直闲置并超过了 keepAliveTime 所指定的时间，核心线程就会被终止。\n② maximumPoolSize最大线程数，当线程不够时能够创建的最大线程数。\n③ keepAliveTime线程池的闲置超时时间，默认情况下对非核心线程生效，如果闲置时间超过这个时间，非核心线程就会被回收。如果 ThreadPoolExecutor 的 allowCoreThreadTimeOut 设为 true 的时候，核心线程如果超过闲置时长也会被回收。\n④ unit配合 keepAliveTime 使用，用来标识 keepAliveTime 的时间单位。\n⑤ workQueue线程池中的任务队列，使用 execute() 或 submit() 方法提交的任务都会存储在此队列中。\n⑥ threadFactory为线程池提供创建新线程的线程工厂。\n⑦ rejectedExecutionHandler线程池任务队列超过最大值之后的拒绝策略，RejectedExecutionHandler 是一个接口，里面只有一个 rejectedExecution 方法，可在此方法内添加任务超出最大值的事件处理。ThreadPoolExecutor 也提供了 4 种默认的拒绝策略：\n\nnew ThreadPoolExecutor.DiscardPolicy()：丢弃掉该任务，不进行处理\nnew ThreadPoolExecutor.DiscardOldestPolicy()：丢弃队列里最近的一个任务，并执行当前任务\nnew ThreadPoolExecutor.AbortPolicy()：直接抛出 RejectedExecutionException 异常\nnew ThreadPoolExecutor.CallerRunsPolicy()：既不抛弃任务也不抛出异常，直接使用主线程来执行此任务\n\n包含所有参数的 ThreadPoolExecutor 使用代码：\npublic class ThreadPoolExecutorTest &#123;    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(1, 1,                10L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(2),                new MyThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());        threadPool.allowCoreThreadTimeOut(true);//核心线程如果超过闲置时长也会被回收        for (int i = 0; i &lt; 10; i++) &#123;            threadPool.execute(new Runnable() &#123;                @Override                public void run() &#123;                    System.out.println(Thread.currentThread().getName());                    try &#123;                        Thread.sleep(2000);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;);        &#125;    &#125;&#125;class MyThreadFactory implements ThreadFactory &#123;    private AtomicInteger count = new AtomicInteger(0);    @Override    public Thread newThread(Runnable r) &#123;        Thread t = new Thread(r);        String threadName = &quot;MyThread&quot; + count.addAndGet(1);        t.setName(threadName);        return t;    &#125;&#125;\n线程池执行方法 execute() VS submit()execute() 和 submit() 都是用来执行线程池的，区别在于 submit() 方法可以接收线程池执行的返回值。\n下面分别来看两个方法的具体使用和区别：\n// 创建线程池ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 10, 10L, TimeUnit.SECONDS, new LinkedBlockingQueue(100));// execute 使用threadPoolExecutor.execute(new Runnable() &#123;    @Override    public void run() &#123;        System.out.println(&quot;Hello, Java.&quot;);    &#125;&#125;);// submit 使用Future&lt;String&gt; future = threadPoolExecutor.submit(new Callable&lt;String&gt;() &#123;    @Override    public String call() throws Exception &#123;        System.out.println(&quot;Hello, 老王.&quot;);        return &quot;Success&quot;;    &#125;&#125;);System.out.println(future.get());\n以上程序执行结果如下：\n\nHello, Java.\nHello, 老王.\nSuccess\n\n线程池关闭线程池关闭，可以使用 shutdown() 或 shutdownNow() 方法，它们的区别是：\n\nshutdown()：不会立即终止线程池，而是要等所有任务队列中的任务都执行完后才会终止。执行完 shutdown 方法之后，线程池就不会再接受新任务了。\nshutdownNow()：执行该方法，线程池的状态立刻变成 STOP 状态，并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，执行此方法会返回未执行的任务。\n\n下面用代码来模拟 shutdown() 之后，给线程池添加任务，代码如下：\nthreadPoolExecutor.execute(() -&gt; &#123;    for (int i = 0; i &lt; 2; i++) &#123;        System.out.println(&quot;I&#x27;m &quot; + i);        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            System.out.println(e.getMessage());        &#125;    &#125;&#125;);threadPoolExecutor.shutdown();threadPoolExecutor.execute(() -&gt; &#123;    System.out.println(&quot;I&#x27;m Java.&quot;);&#125;);\n以上程序执行结果如下：\n\nI’m 0\nException in thread “main” java.util.concurrent.RejectedExecutionException: Task com.interview.chapter5.Section2$$Lambda$2/1828972342@568db2f2 rejected from java.util.concurrent.ThreadPoolExecutor@378bf509[Shutting down, pool size = 1, active threads = 1, queued tasks = 0, completed tasks = 0]\nI’m 1\n\n可以看出，shutdown() 之后就不会再接受新的任务了，不过之前的任务会被执行完成。\n相关面试题1.ThreadPoolExecutor 有哪些常用的方法？答：常用方法如下所示：\n\nsubmit()/execute()：执行线程池\nshutdown()/shutdownNow()：终止线程池\nisShutdown()：判断线程是否终止\ngetActiveCount()：正在运行的线程数\ngetCorePoolSize()：获取核心线程数\ngetMaximumPoolSize()：获取最大线程数\ngetQueue()：获取线程池中的任务队列\nallowCoreThreadTimeOut(boolean)：设置空闲时是否回收核心线程\n\n2.以下程序执行的结果是什么？ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 10, 10L, TimeUnit.SECONDS, new LinkedBlockingQueue());threadPoolExecutor.execute(new Runnable() &#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 2; i++) &#123;            System.out.println(&quot;I：&quot; + i);            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;);threadPoolExecutor.shutdownNow();System.out.println(&quot;Java&quot;);\n答：程序执行的结果是：\n\nI：0\nJava\njava.lang.InterruptedException: sleep interrupted（报错信息）\nI：1\n\n题目解析：因为程序中使用了 shutdownNow() 会导致程序执行一次之后报错，抛出 sleep interrupted 异常，又因为本身有 try/catch，所以程序会继续执行打印 I：1 。\n3.在 ThreadPool 中 submit() 和 execute() 有什么区别？答：submit() 和 execute() 都是用来执行线程池的，只不过使用 execute() 执行线程池不能有返回方法，而使用 submit() 可以使用 Future 接收线程池执行的返回值。\nsubmit() 方法源码（JDK 8）如下：\npublic &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;    if (task &#x3D;&#x3D; null) throw new NullPointerException();    RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task);    execute(ftask);    return ftask;&#125;\nexecute() 源码（JDK 8）如下：\npublic void execute(Runnable command) &#123;    if (command &#x3D;&#x3D; null)        throw new NullPointerException();    &#x2F;&#x2F;..... 其他&#125;\n4.说一下 ThreadPoolExecutor 都需要哪些参数？答：ThreadPoolExecutor 最多包含以下七个参数：\n\ncorePoolSize：线程池中的核心线程数\nmaximumPoolSize：线程池中最大线程数\nkeepAliveTime：闲置超时时间\nunit：keepAliveTime 超时时间的单位（时/分/秒等）\nworkQueue：线程池中的任务队列\nthreadFactory：为线程池提供创建新线程的线程工厂\nrejectedExecutionHandler：线程池任务队列超过最大值之后的拒绝策略\n\n更多详细介绍，请见正文。\n5.在线程池中 shutdownNow() 和 shutdown() 有什么区别？答：shutdownNow() 和 shutdown() 都是用来终止线程池的，它们的区别是，使用 shutdown() 程序不会报错，也不会立即终止线程，它会等待线程池中的缓存任务执行完之后再退出，执行了 shutdown() 之后就不能给线程池添加新任务了；shutdownNow() 会试图立马停止任务，如果线程池中还有缓存任务正在执行，则会抛出 java.lang.InterruptedException: sleep interrupted 异常。\n6.说一说线程池的工作原理？答：当线程池中有任务需要执行时，线程池会判断如果线程数量没有超过核心数量就会新建线程池进行任务执行，如果线程池中的线程数量已经超过核心线程数，这时候任务就会被放入任务队列中排队等待执行；如果任务队列超过最大队列数，并且线程池没有达到最大线程数，就会新建线程来执行任务；如果超过了最大线程数，就会执行拒绝执行策略。\n7.以下线程名称被打印了几次？ThreadPoolExecutor threadPool = new ThreadPoolExecutor(1, 1,                10L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(2),                new ThreadPoolExecutor.DiscardPolicy());threadPool.allowCoreThreadTimeOut(true);for (int i = 0; i &lt; 10; i++) &#123;    threadPool.execute(new Runnable() &#123;        @Override        public void run() &#123;            // 打印线程名称            System.out.println(Thread.currentThread().getName());            try &#123;                Thread.sleep(2000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;);\n答：线程名被打印了 3 次。题目解析：线程池第 1 次执行任务时，会新创建任务并执行；第 2 次执行任务时，因为没有空闲线程所以会把任务放入队列；第 3 次同样把任务放入队列，因为队列最多可以放两条数据，所以第 4 次之后的执行都会被舍弃（没有定义拒绝策略），于是就打印了 3 次线程名称。\n总结ThreadPoolExecutor 是创建线程池最传统和最推荐使用的方式，创建时要设置线程池的核心线程数和最大线程数还有任务队列集合，如果任务量大于队列的最大长度，线程池会先判断当前线程数量是否已经到达最大线程数，如果没有达到最大线程数就新建线程来执行任务，如果已经达到最大线程数，就会执行拒绝策略（拒绝策略可自行定义）。线程池可通过 submit() 来调用执行，从而获得线程执行的结果，也可以通过 shutdown() 来终止线程池。\n\n点击此处下载本文源码\n\n","categories":["java"],"tags":["线程池","threadPollExecutor"]},{"title":"mybatis自定义插入主键","url":"https://www.mele.cool/2020/12/04/自定义插入数据主键ID/","content":"\nOrder这个属性设为after,before这个执行顺序都是相对于下面的insert into这个sql的;Order设为before:那么就先执行selectkey这个标签的sgl,再将这条sql生成的uuid set到User里面去,然后再执行insert into将这个已经带uuid为id的这个User insert到数据库中.\n\n&lt;!--自增主键之UUID--&gt;&lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.test.mybatis.po.User&quot;&gt;  &lt;!--只要不是自增主键,那么order都设置为before--&gt;  &lt;selectkey keyProperty=&quot;id&quot; resultrype=&quot;string&quot; order=&quot;BEFORE&quot;&gt;  \tSELECT UUID()  &lt;/selectkey&gt;  INSERT INTO USER (ID,USERNAME,BIRTHDAY,SEX,ADDRESS)  VALUES (#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt;","categories":["java"],"tags":["mybatis","java","xml","主键"]},{"title":"获取httpServerletRequest","url":"https://www.mele.cool/2020/12/04/获取HttpServletRequest/","content":"package com.mmile.studysb.utils;import javax.servlet.http.HttpServletRequest;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;/** * 获取HttpServletRequest */public class HttpContextUtils &#123;    public static HttpServletRequest getHttpServletRequest() &#123;        return ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();    &#125;&#125;\n","categories":["java"],"tags":["java","httpServerletRequest"]},{"title":"获取ip地址工具类","url":"https://www.mele.cool/2020/12/04/获取ip地址工具类/","content":"package com.mmile.studysb.utils;import javax.servlet.http.HttpServletRequest;public class IPUtils &#123;    /**     * 获取IP地址     *     * 使用Nginx等反向代理软件， 则不能通过request.getRemoteAddr()获取IP地址     * 如果使用了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串IP地址，X-Forwarded-For中第一个非unknown的有效IP字符串，则为真实IP地址     */    public static String getIpAddr(HttpServletRequest request) &#123;        String ip = request.getHeader(&quot;x-forwarded-for&quot;);        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;            ip = request.getHeader(&quot;Proxy-Client-IP&quot;);        &#125;        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;            ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);        &#125;        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;            ip = request.getRemoteAddr();        &#125;        return &quot;0:0:0:0:0:0:0:1&quot;.equals(ip) ? &quot;127.0.0.1&quot; : ip;    &#125;&#125;","categories":["工具类"],"tags":["工具类","tool","ip"]},{"title":"读取配置文件工具类","url":"https://www.mele.cool/2020/12/04/读取配置文件工具类/","content":"package com.haier.otcwms.util;import java.io.IOException;import java.io.InputStream;import java.util.Properties;public class Sysconfig &#123;\tprivate static Properties sysConfig = new Properties();\tstatic &#123; // 读取配置文件\t\tInputStream inputStream = Sysconfig.class\t\t.getResourceAsStream(&quot;/infterfaceAddr.properties&quot;);\t\ttry &#123;\t\t\tsysConfig.load(inputStream);\t\t&#125; catch (IOException e) &#123;\t\t\te.printStackTrace();\t\t&#125; finally &#123;\t\t\ttry &#123;\t\t\t\tinputStream.close();\t\t\t&#125; catch (IOException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t&#125;\t// 根据属性读取配置文件\tpublic static String getProperty(String key) &#123;\t\treturn sysConfig.getProperty(key);\t&#125;\t// 根据属性写入配置文件\tpublic static void setProperty(String key, String value) &#123;\t\tsysConfig.setProperty(key, value);\t&#125;&#125;","categories":["工具类"],"tags":["tool"]},{"title":"过滤器和拦截器","url":"https://www.mele.cool/2020/12/04/过滤器和拦截器/","content":"1、过滤器（Filter）首先说一下Filter的使用地方，我们在配置web.xml时，总会配置下面一段设置字符编码，不然会导致乱码问题：\n&lt;!--配置字符编码过滤器:解决乱码问题--&gt;&lt;filter&gt;    &lt;filter-name&gt;encoding&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;        &lt;param-value&gt;true&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;encoding&lt;/filter-name&gt;    &lt;servlet-name&gt;/*&lt;/servlet-name&gt;&lt;/filter-mapping&gt;\n配置这个地方的目的，是让所有的请求都需要进行字符编码的设置，下面来介绍一下Filter。\n过滤器(Filter)**：它依赖于servlet容器。在实现上，基于函数回调，它可以对几乎所有请求进行过滤，但是缺点是一个过滤器实例只能在容器初始化时调用一次。使用过滤器的目的，是用来做一些过滤操作，获取我们想要获取的数据，比如：在Javaweb中，对传入的request、response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者Controller进行业务逻辑操作。常用的场景是：在过滤器中修改字符编码（CharacterEncodingFilter）、在过滤器中修改HttpServletRequest的一些参数（XSSFilter(自定义过滤器)），如：过滤低俗文字、危险字符等**。\n2、拦截器（Interceptor）拦截器的配置一般在SpringMVC的配置文件中，使用Interceptors标签，具体配置如下：\n&lt;mvc:interceptors&gt;    &lt;mvc:interceptor&gt;        &lt;mvc:mapping path=&quot;/**&quot; /&gt;        &lt;bean class=&quot;com.scorpios.atcrowdfunding.web.LoginInterceptor&quot;&gt;&lt;/bean&gt;    &lt;/mvc:interceptor&gt;    &lt;mvc:interceptor&gt;        &lt;mvc:mapping path=&quot;/**&quot; /&gt;        &lt;bean class=&quot;com.scorpios.atcrowdfunding.web.AuthInterceptor&quot;&gt;&lt;/bean&gt;    &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;\n\n\n拦截器（Interceptor）：它依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架。在实现上基于Java的反射机制，属于面向切面编程（AOP）的一种运用，就是在service或者一个方法前，调用一个方法，或者在方法后，调用一个方法，比如动态代理就是拦截器的简单实现，在调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在调用方法后打印出字符串，甚至在抛出异常的时候做业务逻辑的操作。由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。但是缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理。\n\n静态资源例如html这些放在webinf目录下 不通过拦截器是访问不了的,\n开发时需要在web.xml文件中设置default sevlet-mapping将静态资源排除掉\n\n3、代码下面在一个项目中我们使用既有多个过滤器，又有多个拦截器，并观察它们的执行顺序：（1）第一个过滤器：\npublic class TestFilter1 implements Filter &#123;     @Override      protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;                   //在DispatcherServlet之前执行  System.out.println(&quot;############TestFilter1 doFilterInternal executed############&quot;);          filterChain.doFilter(request, response);          //在视图页面返回给客户端之前执行，但是执行顺序在Interceptor之后          System.out.println(&quot;############TestFilter1 doFilter after############&quot;);             HttpServletRequest request = (HttpServletRequest) req;    HttpServletResponse response = (HttpServletResponse) rep;    HttpSession session = request.getSession();         ServletContext application = session.getServletContext();    if (session.getAttribute(&quot;userSession&quot;)==null)&#123;//        response.sendRedirect(&quot;/views/index.jsp&quot;);        return;    &#125;else &#123;        //放行        chain.doFilter(req,rep);    &#125;    &#125;  &#125;\n（2）第二个过滤器：\npublic class TestFilter2 implements Filter &#123;    @Override    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;      //在DispatcherServlet之前执行          System.out.println(&quot;############TestFilter2 doFilterInternal executed############&quot;);          filterChain.doFilter(request, response);          //在视图页面返回给客户端之前执行，但是执行顺序在Interceptor之后         System.out.println(&quot;############TestFilter2 doFilter after############&quot;);      &#125;  &#125;\n（3）在web.xml中注册这两个过滤器：\n&lt;!-- 自定义过滤器：testFilter1 --&gt;      &lt;filter&gt;          &lt;filter-name&gt;testFilter1&lt;/filter-name&gt;          &lt;filter-class&gt;com.scorpios.filter.TestFilter1&lt;/filter-class&gt;      &lt;/filter&gt;      &lt;filter-mapping&gt;          &lt;filter-name&gt;testFilter1&lt;/filter-name&gt;          &lt;url-pattern&gt;/*&lt;/url-pattern&gt;      &lt;/filter-mapping&gt;      &lt;!-- 自定义过滤器：testFilter2 --&gt;      &lt;filter&gt;          &lt;filter-name&gt;testFilter2&lt;/filter-name&gt;          &lt;filter-class&gt;com.scorpios.filter.TestFilter2&lt;/filter-class&gt;      &lt;/filter&gt;      &lt;filter-mapping&gt;          &lt;filter-name&gt;testFilter2&lt;/filter-name&gt;          &lt;url-pattern&gt;/*&lt;/url-pattern&gt;      &lt;/filter-mapping&gt;\n再定义两个拦截器：\n（4）第一个拦截器：\npublic class BaseInterceptor implements HandlerInterceptor&#123;            /**      * 在DispatcherServlet之前执行      * */      public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception &#123;          System.out.println(&quot;************BaseInterceptor preHandle executed**********&quot;);          System.out.println(&quot;MyInterceptor:&quot;+request.getContextPath()+&quot;,&quot;+request.getRequestURI()+&quot;,&quot;+request.getMethod());        return true;      &#125;        /**      * 在controller执行之后的DispatcherServlet之后执行      * */      public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception &#123;          System.out.println(&quot;************BaseInterceptor postHandle executed**********&quot;);      &#125;            /**      * 在页面渲染完成返回给客户端之前执行      * */      public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)              throws Exception &#123;          System.out.println(&quot;************BaseInterceptor afterCompletion executed**********&quot;);      &#125;  &#125;\n（5）第二个拦截器：\npublic class TestInterceptor implements HandlerInterceptor &#123;        public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception &#123;          System.out.println(&quot;************TestInterceptor preHandle executed**********&quot;);          return true;      &#125;        public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception &#123;          System.out.println(&quot;************TestInterceptor postHandle executed**********&quot;);      &#125;        public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123;          System.out.println(&quot;************TestInterceptor afterCompletion executed**********&quot;);      &#125;  &#125;\n（6）、在SpringMVC的配置文件中，加上拦截器的配置：\n&lt;!-- 拦截器 --&gt;  &lt;mvc:interceptors&gt;      &lt;!-- 对所有请求都拦截，公共拦截器可以有多个 --&gt;      &lt;bean name=&quot;baseInterceptor&quot; class=&quot;com.scorpios.interceptor.BaseInterceptor&quot; /&gt;  \t\t&lt;mvc:interceptor&gt;     \t\t&lt;!-- 对/test.html进行拦截 --&gt;               &lt;mvc:mapping path=&quot;/test.html&quot;/&gt;          &lt;!-- 特定请求的拦截器只能有一个 --&gt;          &lt;bean class=&quot;com.scorpios.interceptor.TestInterceptor&quot; /&gt;      &lt;/mvc:interceptor&gt;  &lt;/mvc:interceptors&gt;\n\n\n（7）、定义一个Controller控制器：\npackage com.scorpios.controller;  import org.springframework.stereotype.Controller;  import org.springframework.web.bind.annotation.RequestMapping;  import org.springframework.web.servlet.ModelAndView;     @Controller  public class TestController &#123;      @RequestMapping(&quot;/test&quot;)      public ModelAndView handleRequest()&#123;          System.out.println(&quot;---------TestController executed--------&quot;);          return new ModelAndView(&quot;test&quot;);      &#125;  &#125;\n（8）、测试结果：启动测试项目，地址如下：http://www.localhost:8080/demo， 可以看到控制台中输出如下：\n\n这就说明了过滤器的运行是依赖于servlet容器，跟springmvc等框架并没有关系。并且，多个过滤器的执行顺序跟xml文件中定义的先后关系有关。\n接着清空控制台，并访问：\nhttp://www.localhost:8080/demo/test，再次看控制台的输出：\n\n从这个控制台打印输出，就可以很清晰地看到有多个拦截器和过滤器存在时的整个执行顺序了。当然，对于多个拦截器它们之间的执行顺序跟在SpringMVC的配置文件中定义的先后顺序有关。\n4、总结对于上述过滤器和拦截器的测试，可以得到如下结论：\n\nFilter需要在web.xml中配置，依赖于Servlet；\n\nInterceptor需要在SpringMVC中配置，依赖于框架；\n\nFilter的执行顺序在Interceptor之前，具体的流程见下图；\n\n\n两者的本质区别：拦截器（Interceptor）是基于Java的反射机制，而过滤器（Filter）是基于函数回调。从灵活性上说拦截器功能更强大些，Filter能做的事情，都能做，而且可以在请求前，请求后执行，比较灵活。Filter主要是针对URL地址做一个编码的事情、过滤掉没用的参数、安全校验（比较泛的，比如登录不登录之类），太细的话，还是建议用interceptor。不过还是根据不同情况选择合适的。\n\n\n————————————————\n原文链接：https://blog.csdn.net/zxd1435513775/article/details/80556034\n","categories":["java"],"tags":["java基础","filter","interceptor","过滤器","拦截器"]},{"title":"rabbitmq入门使用","url":"https://www.mele.cool/2020/12/04/rabbitmq入门使用/","content":"1.消息队列概述MQ:Message Queue,消息队列是应用程序与应用程序之间的通信方法.\n1.1为什么使用MQ在项目中,可将一些无需即时返回且耗时的操作提取出来,进行异步处理,而这种异步处理的方式大大的节省了服务器的请求响应时间,从而提高了系统的吞吐量。\n1.2 开发中消息队列通常有如下应用场景:1、任务异步处理将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。2、应用程序解耦合MQ相当于一个中介,生产方通过MQ与消费方交互,它将应用程序进行解耦合。\nMQ是消息通信的模型;实现MQ的大致有两种主流方式: AMQP, JMS.\n\nAMQP是一种协议,更准确的说是一种binary wirelevel protocol (链接协议) 。这是其和JMS的本质差别, AMQP不从API层进行限定,而是直接定义网络交换的数据格式。  \nJMS即Java消息服务JavaMessage Service)应用程序接口,是一个java平台关于面向消息中间件(MOM)的API,用于在两个应用程序之间,或分布式系统中发送消息,进行异步通信。\n\n1.3 AMQP与JMS区别\nJMS是定义了统一的接口,来对消息操作进行统一; AMQP是通过规定协议来统一数据交互的格式JMS限定了必须使用ava语言; \nAMQP只是协议,不规定实现方式,因此是跨语言的。\nJMS规定了两种消息模式;而AMQP的消息模式更加丰富\n\n2.mac安装rabbitmqgraph LR;1[安装rabbitmq] --&gt; 2[安装rabbitmq可视化监控插件]--&gt;3[配置环境变量]--&gt;4[后台启动rabbitmq]\n2.1brew install rabbitmq==&gt; Installing rabbitmq==&gt; Downloading https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.3/rabbitmq-server-generic-unix-3.8.3.tar.xz==&gt; Downloading from https://github-production-release-asset-2e65be.s3.amazonaws.com/924551/9b363b00-6236-11ea-964e-aebcb201484a?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAIW######################################################################## 100.0%==&gt; /usr/bin/unzip -qq -j /usr/local/Cellar/rabbitmq/3.8.3/plugins/rabbitmq_management-3.8.3.ez rabbitmq_management-3.8.3/priv/www/cli/rabbitmqadmin==&gt; CaveatsManagement Plugin enabled by default at http://localhost:15672Bash completion has been installed to:  /usr/local/etc/bash_completion.dTo have launchd start rabbitmq now and restart at login:  brew services start rabbitmqOr, if you don&#x27;t want/need a background service you can just run:  rabbitmq-server==&gt; Summary🍺  /usr/local/Cellar/rabbitmq/3.8.3: 281 files, 20.4MB, built in 1 minute 10 seconds\n2.2安装rabbitmq可视化监控插件boguotong:~ boguotong$ cd /usr/local/Cellar/rabbitmq/3.8.3/boguotong:3.8.3 boguotong$ sudo sbin/rabbitmq-plugins enable rabbitmq_management\n2.3配置环境变量vim ~/.bash_profile //加入以下两行export RABBIT_HOME=/usr/local/Cellar/rabbitmq/3.8.3/sbin/export PATH=$CXF3:$JAVA_HOME:$PATH:$SAPJCO:$JETTY_HOME:$PYTHON_HOME:$RABBIT_HOME // 立即生效 source /etc/profile\n2.4后台启动rabbitmq// 后台启动sudo rabbitmq-server -detached  // 查看状态rabbitmqctl status // 访问可视化监控插件的界面// 浏览器内输入 http://localhost:15672,默认的用户名密码都是guest,登录后可以在Admin那一列菜单内添加自己的用户rabbitmqctl stop 关闭\n3.创建工程\n入门工程:生产者发送消息到RabbitMQ的队列(simple-queue ) ;消费者可以从队列中获取消息。可以使用RabRabbitMQ的简单模式( simple )\n\n3.1 引入依赖&lt;dependency&gt;        &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;        &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;        &lt;version&gt;5.6.0&lt;/version&gt;    &lt;/dependency&gt;\n3.2编写生产者代码发送消息到mq\n在设置连接工厂的时候;如果没有指定连接的参数则会有默认值;可以去设置虚拟主机,实际业务中一般根据不同的业务设置不同的虚拟主机. \n\npackage com.bgt.rabbitmq.simple;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;/** * Package: com.bgt.rabbitmq.controller * Description： 消息生产者 * Author: bgt * Date: Created in 2020/9/19 5:27 下午 * Company: * Copyright: * Version: 0.0.1 * Modified By: */public class RabbitMQController &#123;    public static void main(String[] args) throws Exception&#123;//        1,创建连接工厂(设置RabbitMQ的连接参数) ;        ConnectionFactory factory = new ConnectionFactory();//        2.创建连接;        //主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest        factory.setHost(&quot;localhost&quot;);        factory.setPort(5672);        factory.setVirtualHost(&quot;/&quot;);        factory.setUsername(&quot;guest&quot;);        factory.setPassword(&quot;guest&quot;);        Connection connection = factory.newConnection();//        3.创建频道;        Channel channel = connection.createChannel();//        4.声明队列;//        参数1:队列名称//        参数2:是否定义持久化队列(消息会持久化保存在服务器上)//        参数3:是否独占本连接//        参数4:是否在不使用的时候队列自动删除//        参数5:其它参数        channel.queueDeclare(&quot;simple-queue&quot;,true,false,false,null);//        5.发送消息;        String msg = &quot;你好,我的mq!&quot;;//        参数1:交换机名称；如果没有则指定空字符串(表示使用默认的交换机)//        参数2:路由key,简单模式中可以使用队列名称//        参数3:消息其它属性//        参数4:消息内容        channel.basicPublish(&quot;&quot;,&quot;simple-queue&quot;,null,msg.getBytes());//        6.关闭资源        channel.close();        connection.close();    &#125;&#125;\n3.3 编写消费者代码接收消息\n消费者需要持续监听队列消息,所以不要关闭资源\n\npackage com.bgt.rabbitmq.simple;import com.rabbitmq.client.*;import java.io.IOException;/** * Package: com.bgt.rabbitmq.simple * Description： 简单模式 消费者接收消息 * Author: bgt * Date: Created in 2020/9/19 7:53 下午 * Company: * Copyright: * Version: 0.0.1 * Modified By: */public class RabbitmqConsumer &#123;    public static void main(String[] args) throws Exception&#123;        // 1,创建连接工厂(设置RabbitMQ的连接参数) ;        ConnectionFactory factory = new ConnectionFactory();//        2.创建连接;        //主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest        factory.setHost(&quot;localhost&quot;);        factory.setPort(5672);        factory.setVirtualHost(&quot;/&quot;);        factory.setUsername(&quot;guest&quot;);        factory.setPassword(&quot;guest&quot;);        Connection connection = factory.newConnection();//        3.创建频道;        Channel channel = connection.createChannel();//        4.声明队列;//        参数1:队列名称//        参数2:是否定义持久化队列(消息会持久化保存在服务器上)//        参数3:是否独占本连接//        参数4:是否在不使用的时候队列自动删除//        参数5:其它参数        channel.queueDeclare(&quot;simple-queue&quot;,true,false,false,null);//        5.创建消费者接收并处理消息        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;                //路由key 交换机 消息id 接受到的消息                System.out.println(envelope.getRoutingKey());                System.out.println(envelope.getExchange());                System.out.println(envelope.getDeliveryTag());                System.out.println(new String(body,&quot;UTF-8&quot;));            &#125;        &#125;;        //6 监听队列//        参数1:队列名//        参数2:是否要自动确认;设置为true表示消息接收到自动向MQ回复接收到了, MQ则会将消息从队列中删除;//        如果设置为false则需要手动确认//        参数3:消费者        channel.basicConsume(&quot;simple-queue&quot;,true,consumer);    &#125;&#125;\n3.4 测试![image-20200919200926479](/Users/boguotong/Library/Application Support/typora-user-images/image-20200919200926479.png)\n4.RabbitMQ工作模式4.1work queue工作队列模式\nwork queues与入门程序的简单模式相比,多了一个或一些消费端,多个消费端共同消费同一个队列中的消息(竞争关系)。\n\n应用场景: 可以在消费者端处理任务比较耗时的时候;添加对同一个队列的消费者来提高任务处理能力。\n4.1.1 生产者循环发送三十条消息4.1.2 编写两个消费者package com.bgt.rabbitmq.workqueue;import com.rabbitmq.client.*;import java.io.IOException;/** * Package: com.bgt.rabbitmq.simple * Description： 简单模式 消费者接收消息 * Author: bgt * Date: Created in 2020/9/19 7:53 下午 * Company: * Copyright: * Version: 0.0.1 * Modified By: */public class RabbitmqConsumer1 &#123;    public static void main(String[] args) throws Exception&#123;        // 1,创建连接工厂(设置RabbitMQ的连接参数) ;        ConnectionFactory factory = new ConnectionFactory();//        2.创建连接;        //主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest        factory.setHost(&quot;localhost&quot;);        factory.setPort(5672);        factory.setVirtualHost(&quot;/&quot;);        factory.setUsername(&quot;guest&quot;);        factory.setPassword(&quot;guest&quot;);        Connection connection = factory.newConnection();//        3.创建频道;        final Channel channel = connection.createChannel();//        4.声明队列;//        参数1:队列名称//        参数2:是否定义持久化队列(消息会持久化保存在服务器上)//        参数3:是否独占本连接//        参数4:是否在不使用的时候队列自动删除//        参数5:其它参数        channel.queueDeclare(&quot;simple-queue&quot;,true,false,false,null);        //每次可以预取几个消息        channel.basicQos(1);//        5.创建消费者接收并处理消息        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;                //路由key 交换机 消息id 接受到的消息                System.out.println(&quot;路由key:&quot;+envelope.getRoutingKey());                System.out.println(&quot;交换机:&quot;+envelope.getExchange());                System.out.println(&quot;消息id:&quot;+envelope.getDeliveryTag());                System.out.println(&quot;消费者1---接受到的消息:&quot;+new String(body,&quot;UTF-8&quot;));                try &#123;                    Thread.sleep(1000);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                //确认消息//                参数1:消息id//                基数2: false表示只有当前这条被处理                channel.basicAck(envelope.getDeliveryTag(),false);            &#125;        &#125;;        //6 监听队列//        参数1:队列名//        参数2:是否要自动确认;设置为true表示消息接收到自动向MQ回复接收到了, MQ则会将消息从队列中删除;//        如果设置为false则需要手动确认//        参数3:消费者        channel.basicConsume(&quot;simple-queue&quot;,true,consumer);    &#125;&#125;\n\n\n4.1.3 测试:启动两个消费者,然后启动生产者\n结论:一个消息只能被一个消费者接收.\n\n5.订阅模式![image-20200919204735420](/Users/boguotong/Library/Application Support/typora-user-images/image-20200919204735420.png)\n\nP:生产者,也就是要发送消息的程序,但是不再发送到队列中,而是发给x (交换机)\nC:消费者,消息的接受者,会一直等待消息到来。\nQueue:消息队列,接收消息、缓存消息。\n\nExchange:交换机,图中的x,一方面,接收生产者发送的消息。另一方面,知道如何处理消息,例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作,取决于Exchange的类型。Exchang有常见以下3种类型:\n\n Fanout:广播,将消息交给所有绑定到交换机的队列\nDirect:定向,把消息交给符合指定routing key的队列\nTopic:通配符,把消息交给符合routing pattern (路由模式)的队列\n\nExchange (交换机)只负责转发消息,不具备存储消息的能力,因此如果没有任何队列与Exchange绑定,或者没有符合路由规则的队列,那么消息会丢失!\n5.1.pulish/subscribe发布/订阅模式(广播)发布与订阅模式特点:一个消息可以被多个消费者接收;其实是使用了订阅模式,交换机类型为: fanout广播,一个消费者对应一个队列,该队列只能被一个消费者监听。\n5.1.1 生产者package com.bgt.rabbitmq.ps;import com.rabbitmq.client.BuiltinExchangeType;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;/** * Package: com.bgt.rabbitmq.controller * Description： 发布订阅模式  消息生产者 * Author: bgt * Date: Created in 2020/9/19 5:27 下午 * Company: * Copyright: * Version: 0.0.1 * Modified By: */public class Producer &#123;    //交换机    static final String FANOUT_EXCHANGE=&quot;fanout_exchange&quot;;    //队列名称    static final String FANOUT_QUEUE1=&quot;fanout_queue1&quot;;    static final String FANOUT_QUEUE2=&quot;fanout_queue2&quot;;    public static void main(String[] args) throws Exception&#123;//       1.创建连接;        ConnectionFactory factory = new ConnectionFactory();        //主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest        factory.setHost(&quot;localhost&quot;);        factory.setPort(5672);        factory.setVirtualHost(&quot;/&quot;);        factory.setUsername(&quot;guest&quot;);        factory.setPassword(&quot;guest&quot;);        Connection connection = factory.newConnection();//        2.创建频道;        Channel channel = connection.createChannel();        //3,声明交换机;参数1:交换机名称,参数2:交换机类型( fanout, direct, topic)        channel. exchangeDeclare (FANOUT_EXCHANGE, BuiltinExchangeType.FANOUT);        //4．声明队列；        /*参数1:队列名称          参数2:是否定义持久化队列(消息会持久化保存在服务器上)          参数3:是否独占本连接         参数4:是否在不使用的时候队列自动删除         参数5:其它参数        */        channel. queueDeclare (FANOUT_QUEUE1, true,  false,  false,  null);        channel. queueDeclare (FANOUT_QUEUE2, true,  false,  false,  null);//      5.队列绑定到交换机 参数1:队列名称,参数2:交换机名称,参数3:路由key        channel. queueBind (FANOUT_QUEUE1, FANOUT_EXCHANGE,  &quot;&quot;);        channel. queueBind (FANOUT_QUEUE2, FANOUT_EXCHANGE,  &quot;&quot;);        //6 发送消息        //参数1:交换机名称;如果没有则指定空字符串(表示使用默认的交换机)参数2:路由key,简单模式中可以使用队列名称        // 参数3：消息其它属性  参数4:消息内容        for (int i=0;i&lt;10;i++ )&#123;            String msg=&quot;hello mq.发布订阅模式--&quot;+i;            channel.basicPublish(FANOUT_EXCHANGE,&quot;&quot;,null,msg.getBytes());            System.out.println(&quot;已发送消息:&quot;+msg);        &#125;//        6.关闭资源        channel.close();        connection.close();    &#125;&#125;\n\n\n5.1.2 消费者\n创建两个消费者\n\npackage com.bgt.rabbitmq.ps;import com.rabbitmq.client.*;import java.io.IOException;/** * Package: com.bgt.rabbitmq.simple * Description： 发布订阅模式 消费者接收消息 * Author: bgt * Date: Created in 2020/9/19 7:53 下午 * Company: * Copyright: * Version: 0.0.1 * Modified By: */public class Consumer1 &#123;    //交换机    static final String FANOUT_EXCHANGE=&quot;fanout_exchange&quot;;    //队列名称    static final String FANOUT_QUEUE1=&quot;fanout_queue1&quot;;    public static void main(String[] args) throws Exception&#123;        //1.创建连接;        ConnectionFactory factory = new ConnectionFactory();        //主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest        factory.setHost(&quot;localhost&quot;);        factory.setPort(5672);        factory.setVirtualHost(&quot;/&quot;);        factory.setUsername(&quot;guest&quot;);        factory.setPassword(&quot;guest&quot;);        Connection connection = factory.newConnection();//        2.创建频道;        Channel channel = connection.createChannel();        //3 声明交换机        channel.exchangeDeclare(FANOUT_EXCHANGE,BuiltinExchangeType.FANOUT);//        4.声明队列;//        参数1:队列名称//        参数2:是否定义持久化队列(消息会持久化保存在服务器上)//        参数3:是否独占本连接//        参数4:是否在不使用的时候队列自动删除//        参数5:其它参数        channel.queueDeclare(FANOUT_QUEUE1,true,false,false,null);        //5 绑定队列到交换机        channel.queueBind(FANOUT_QUEUE1,FANOUT_EXCHANGE,&quot;&quot;);//        5.创建消费者接收并处理消息        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;                //路由key 交换机 消息id 接受到的消息                System.out.println(&quot;路由key:&quot;+envelope.getRoutingKey());                System.out.println(&quot;交换机:&quot;+envelope.getExchange());                System.out.println(&quot;消息id:&quot;+envelope.getDeliveryTag());                System.out.println(&quot;消费者1---接受到的消息:&quot;+new String(body,&quot;UTF-8&quot;));            &#125;        &#125;;        //6 监听队列//        参数1:队列名//        参数2:是否要自动确认;设置为true表示消息接收到自动向MQ回复接收到了, MQ则会将消息从队列中删除;//        如果设置为false则需要手动确认//        参数3:消费者        channel.basicConsume(FANOUT_QUEUE1,true,consumer);    &#125;&#125;\n5.2routing 路由模式\n特点:\n\n队列与交换机的绑定,不能是任意绑定了,而是要指定一个Routingkey (路由key)\n消息的发送方在向Exchange发送消息时,也必须指定消息的Routingkey.\nExchange不再把消息交给每一个绑定的队列,而是根据消息的Routing key进行判断,只有队列的Routingkey与消息的Routing key完全一致,才会接收到消息\n\n\n![image-20200919212311753](/Users/boguotong/Library/Application Support/typora-user-images/image-20200919212311753.png)\n5.2.1 生产者package com.bgt.rabbitmq.routing;import com.rabbitmq.client.BuiltinExchangeType;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;/** * Package: com.bgt.rabbitmq.controller * Description： 路由模式  消息生产者 * Author: bgt * Date: Created in 2020/9/19 5:27 下午 * Company: * Copyright: * Version: 0.0.1 * Modified By: */public class Producer &#123;    //交换机    static final String DIRECT_EXCHANGE=&quot;direct_exchange&quot;;    //队列名称    static final String DIRECT_QUEUE_INSERT=&quot;direct_queue_insert&quot;;    static final String DIRECT_QUEUE_UPDATE=&quot;direct_queue_update&quot;;    public static void main(String[] args) throws Exception&#123;//       1.创建连接;        ConnectionFactory factory = new ConnectionFactory();        //主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest        factory.setHost(&quot;localhost&quot;);        factory.setPort(5672);        factory.setVirtualHost(&quot;myrouting&quot;);        factory.setUsername(&quot;guest&quot;);        factory.setPassword(&quot;guest&quot;);        Connection connection = factory.newConnection();//        2.创建频道;        Channel channel = connection.createChannel();        //3,声明交换机;参数1:交换机名称,参数2:交换机类型( fanout, direct, topic)        channel. exchangeDeclare (DIRECT_EXCHANGE, BuiltinExchangeType.DIRECT);        //4．声明队列；        /*参数1:队列名称          参数2:是否定义持久化队列(消息会持久化保存在服务器上)          参数3:是否独占本连接         参数4:是否在不使用的时候队列自动删除         参数5:其它参数        */        channel. queueDeclare (DIRECT_QUEUE_INSERT, true,  false,  false,  null);        channel. queueDeclare (DIRECT_QUEUE_UPDATE, true,  false,  false,  null);//      5.队列绑定到交换机 参数1:队列名称,参数2:交换机名称,参数3:路由key        channel. queueBind (DIRECT_QUEUE_INSERT, DIRECT_EXCHANGE,  &quot;insert&quot;);        channel. queueBind (DIRECT_QUEUE_UPDATE, DIRECT_EXCHANGE,  &quot;update&quot;);        //6 发送消息        //参数1:交换机名称;如果没有则指定空字符串(表示使用默认的交换机)参数2:路由key,简单模式中可以使用队列名称        // 参数3：消息其它属性  参数4:消息内容        String msg=&quot;hello mq.路由模式--routingkey是insert&quot;;        channel.basicPublish(DIRECT_EXCHANGE,&quot;insert&quot;,null,msg.getBytes());        System.out.println(&quot;已发送消息:&quot;+msg);        msg=&quot;hello mq.路由模式--routingkey是update&quot;;        channel.basicPublish(DIRECT_EXCHANGE,&quot;update&quot;,null,msg.getBytes());        System.out.println(&quot;已发送消息:&quot;+msg);//        6.关闭资源        channel.close();        connection.close();    &#125;&#125;\n\n\n5.2.2消费者\n创建两个消费者,分别通过不同的routingkey绑定同一个交换机\n\n5.2.2.1消费者1package com.bgt.rabbitmq.routing;import com.rabbitmq.client.*;import java.io.IOException;/** * Package: com.bgt.rabbitmq.simple * Description： 发布订阅模式 消费者接收消息 * Author: bgt * Date: Created in 2020/9/19 7:53 下午 * Company: * Copyright: * Version: 0.0.1 * Modified By: */public class Consumer1 &#123;    //交换机    static final String DIRECT_EXCHANGE=&quot;direct_exchange&quot;;    //队列名称    static final String DIRECT_QUEUE_INSERT=&quot;direct_queue_insert&quot;;    public static void main(String[] args) throws Exception&#123;        //1.创建连接;        ConnectionFactory factory = new ConnectionFactory();        //主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest        factory.setHost(&quot;localhost&quot;);        factory.setPort(5672);        factory.setVirtualHost(&quot;myrouting&quot;);        factory.setUsername(&quot;guest&quot;);        factory.setPassword(&quot;guest&quot;);        Connection connection = factory.newConnection();//        2.创建频道;        Channel channel = connection.createChannel();        //3 声明交换机        channel.exchangeDeclare(DIRECT_EXCHANGE,BuiltinExchangeType.DIRECT);//        4.声明队列;//        参数1:队列名称//        参数2:是否定义持久化队列(消息会持久化保存在服务器上)//        参数3:是否独占本连接//        参数4:是否在不使用的时候队列自动删除//        参数5:其它参数        channel.queueDeclare(DIRECT_QUEUE_INSERT,true,false,false,null);        //5 绑定队列到交换机      //备注:这一步应该可以不要,生产者发送消息时根据routingkey和交换机把消息发送到绑定的队列中,因此消费者只需要监听这个队列就可以获取消息,实测消费者不需要再次绑定交换机/队列/routingkey也可以取到消息,因此这行不需要.       // channel.queueBind(DIRECT_QUEUE_INSERT,DIRECT_EXCHANGE,&quot;insert&quot;);//        5.创建消费者接收并处理消息        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;                //路由key 交换机 消息id 接受到的消息                System.out.println(&quot;路由key:&quot;+envelope.getRoutingKey());                System.out.println(&quot;交换机:&quot;+envelope.getExchange());                System.out.println(&quot;消息id:&quot;+envelope.getDeliveryTag());                System.out.println(&quot;消费者1---接受到的消息:&quot;+new String(body,&quot;UTF-8&quot;));            &#125;        &#125;;        //6 监听队列//        参数1:队列名//        参数2:是否要自动确认;设置为true表示消息接收到自动向MQ回复接收到了, MQ则会将消息从队列中删除;//        如果设置为false则需要手动确认//        参数3:消费者        channel.basicConsume(DIRECT_QUEUE_INSERT,true,consumer);    &#125;&#125;\n5.2.2.2消费者2package com.bgt.rabbitmq.routing;import com.rabbitmq.client.*;import java.io.IOException;/** * Package: com.bgt.rabbitmq.simple * Description： 发布订阅模式 消费者接收消息 * Author: bgt * Date: Created in 2020/9/19 7:53 下午 * Company: * Copyright: * Version: 0.0.1 * Modified By: */public class Consumer2 &#123;    //交换机    static final String DIRECT_EXCHANGE=&quot;direct_exchange&quot;;    //队列名称    static final String DIRECT_QUEUE_UPDATE=&quot;direct_queue_update&quot;;    public static void main(String[] args) throws Exception&#123;        //1.创建连接;        ConnectionFactory factory = new ConnectionFactory();        //主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest        factory.setHost(&quot;localhost&quot;);        factory.setPort(5672);        factory.setVirtualHost(&quot;myrouting&quot;);        factory.setUsername(&quot;guest&quot;);        factory.setPassword(&quot;guest&quot;);        Connection connection = factory.newConnection();//        2.创建频道;        Channel channel = connection.createChannel();        //3 声明交换机        channel.exchangeDeclare(DIRECT_EXCHANGE,BuiltinExchangeType.DIRECT);//        4.声明队列;//        参数1:队列名称//        参数2:是否定义持久化队列(消息会持久化保存在服务器上)//        参数3:是否独占本连接//        参数4:是否在不使用的时候队列自动删除//        参数5:其它参数        channel.queueDeclare(DIRECT_QUEUE_UPDATE,true,false,false,null);        //5 绑定队列到交换机       //备注:这一步应该可以不要,生产者发送消息时根据routingkey和交换机把消息发送到绑定的队列中,因此消费者只需要监听这个队列就可以获取消息,实测消费者不需要再次绑定交换机/队列/routingkey也可以取到消息,因此这行不需要.        //channel.queueBind(DIRECT_QUEUE_UPDATE,DIRECT_EXCHANGE,&quot;update&quot;);//        5.创建消费者接收并处理消息        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;                //路由key 交换机 消息id 接受到的消息                System.out.println(&quot;路由key:&quot;+envelope.getRoutingKey());                System.out.println(&quot;交换机:&quot;+envelope.getExchange());                System.out.println(&quot;消息id:&quot;+envelope.getDeliveryTag());                System.out.println(&quot;消费者1---接受到的消息:&quot;+new String(body,&quot;UTF-8&quot;));            &#125;        &#125;;        //6 监听队列//        参数1:队列名//        参数2:是否要自动确认;设置为true表示消息接收到自动向MQ回复接收到了, MQ则会将消息从队列中删除;//        如果设置为false则需要手动确认//        参数3:消费者        channel.basicConsume(DIRECT_QUEUE_UPDATE,true,consumer);    &#125;&#125;\n5.3 topics通配符模式\nTopic类型与Direct相比,都是可以根据Routingkey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key的时候使用通配符!Routingkey一般都是有一个或多个单词组成,多个单词之间以”.”分割,例如: item.inser\n\n通配符规则:\n\n#：匹配一个或多个词\n*:   匹配不多不少恰好1个词\n\n举例:\n\nitem.#:能够匹配item.insert.abc或者item.insertitem.\n*:只能匹配item.insert\n\n![image-20200919215028302](/Users/boguotong/Library/Application Support/typora-user-images/image-20200919215028302.png)\n![image-20200919215432002](/Users/boguotong/Library/Application Support/typora-user-images/image-20200919215432002.png)\n5.3.1生产者基于路由模式代码改造如下:\n//声明交换机;交换机类型改为通配符模式channel.exchangeDeclare (TOPIC EXCHAGE, BuiltinExchangeType. TOPIC) ://发送三条消息指定不同的routingkeychannel.basicPublish (TOPIC EXCHAGE, routingKey: &quot;item.insert&quot;, props: null, message.getBytes());channel.basicPublish (TOPIC EXCHAGE, routingKey: &quot;item.update&quot;, props: null, message.getBytes());channel.basicPublish (TOPIC EXCHAGE, routingKey: &quot;item.delete&quot;, props: null, message.getBytes());\n5.3.2 消费者\n两个消费者\n\n 基于路由模式代码改造如下:\n//声明交换机;交换机类型改为通配符模式channel.exchangeDeclare (Producer. TOPIC EXCHAGE, BuiltinExchangeType.TOPIC);//消费者1绑定这两个指定routingkeychannel.queueBind (Producer.TOPIC_QUEUE1, Producer.TOPIC_EXCHAGE, &quot;item.update&quot;);channel.queueBind (Producer.TOPIC_QUEUE1, Producer.TOPIC_EXCHAGE, &quot;item.delete&quot;);//消费者2绑定通配符模式的routingkeychannel.queueBind (Producer.TOPIC_QUEUE2, Producer.TOPIC_EXCHAGE, &quot;item.*&quot;);\n5.4 rabbitmq模式总结![image-20200919221146270](/Users/boguotong/Library/Application Support/typora-user-images/image-20200919221146270.png)\n6.springboot整合rabbitmq\nSpring Boot提供了对于AMQP的整合;可以使月RabbitTemplate发送消息;可以使用@RabbitListener注解接收消息。\n示例通配符模式\n\n6.1 生产者工程6.1.1 添加依赖 &lt;!--rabbitmq发送消息核心依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.bootk/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amgp&lt;/artifactrds&lt;/dependency&gt; &lt;!--rabbitmq发送消息测试依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.bootk/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactrds&lt;/dependency&gt;\t\n\n\n6.1.2 添加配置文件\napplication.properties配置rabbitmq连接信息\n\nspring:\trabbitmq:    host: localhost    port: 5672     virtual-host: /    username: guest    password: guest\n6.1.3 创建配置类![image-20200919222543932](/Users/boguotong/Library/Application Support/typora-user-images/image-20200919222543932.png)\n6.1.4 创建发送消息类 ![image-20200919223251686](/Users/boguotong/Library/Application Support/typora-user-images/image-20200919223251686.png)\n6.2 消费者工程6.2.1 添加依赖&lt;!--rabbitmq发送消息核心依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.bootk/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amgp&lt;/artifactrds&lt;/dependency&gt;\n\n\n6.2.2 添加配置文件spring:\trabbitmq:    host: localhost    port: 5672     virtual-host: /    username: guest    password: guest\n6.2.3 编写消息监听器类![image-20200919222909121](/Users/boguotong/Library/Application Support/typora-user-images/image-20200919222909121.png)","categories":["mq"],"tags":["mq","消息队列"]},{"title":"Spring Boot中使用缓存","url":"https://www.mele.cool/2020/12/04/Spring Boot中使用缓存/","content":"在程序中可以使用缓存的技术来节省对数据库的开销。Spring Boot对缓存提供了很好的支持，我们几乎不用做过多的配置即可使用各种缓存实现。这里主要介绍平日里个人接触较多的Ehcache和Redis缓存实现。\n准备工作yml中配置日志输出级别以观察SQL的执行情况：\nlogging:  level:    com:      springboot:        mapper: debug\n\n\n其中com.spring.mapper为MyBatis的Mapper接口路径。\n然后编写如下测试方法：\n@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = Application.class)public class ApplicationTest &#123;    @Autowired    private StudentService studentService;        @Test    public void test() throws Exception &#123;        Student student1 = this.studentService.queryStudentBySno(&quot;001&quot;);        System.out.println(&quot;学号&quot; + student1.getSno() + &quot;的学生姓名为：&quot; + student1.getName());                Student student2 = this.studentService.queryStudentBySno(&quot;001&quot;);        System.out.println(&quot;学号&quot; + student2.getSno() + &quot;的学生姓名为：&quot; + student2.getName());    &#125;&#125;\n\n\n右键run as junit test：\n2017-11-17 16:34:26.535 DEBUG 9932 --- [main] c.s.m.StudentMapper.queryStudentBySno    : ==&gt;  Preparing: select * from student where sno=? 2017-11-17 16:34:26.688 DEBUG 9932 --- [main] c.s.m.StudentMapper.queryStudentBySno    : ==&gt; Parameters: 001(String)2017-11-17 16:34:26.716 DEBUG 9932 --- [main] c.s.m.StudentMapper.queryStudentBySno    : &lt;==      Total: 1学号001的学生姓名为：KangKang2017-11-17 16:34:26.720 DEBUG 9932 --- [main] c.s.m.StudentMapper.queryStudentBySno    : ==&gt;  Preparing: select * from student where sno=? 2017-11-17 16:34:26.720 DEBUG 9932 --- [main] c.s.m.StudentMapper.queryStudentBySno    : ==&gt; Parameters: 001(String)2017-11-17 16:34:26.721 DEBUG 9932 --- [main] c.s.m.StudentMapper.queryStudentBySno    : &lt;==      Total: 1学号001的学生姓名为：KangKang\n\n\n可发现第二个查询虽然和第一个查询完全一样，但其还是对数据库进行了查询。接下来引入缓存来改善这个结果。\n使用缓存要开启Spring Boot的缓存功能，需要在pom中引入spring-boot-starter-cache：\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n接着在Spring Boot入口类中加入@EnableCaching注解开启缓存功能：\n@SpringBootApplication@EnableCachingpublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class,args);    &#125;&#125;\n\n\n在StudentService接口中加入缓存注解：\n@CacheConfig(cacheNames = &quot;student&quot;)@Repositorypublic interface StudentService &#123;    @CachePut(key = &quot;#p0.sno&quot;)    Student update(Student student);        @CacheEvict(key = &quot;#p0&quot;, allEntries = true)    void deleteStudentBySno(String sno);      \t//将id作为redis中的key值    @Cacheable(key = &quot;#p0&quot;)    Student queryStudentBySno(String sno);&#125;\n\n\n我们在StudentService接口中加入了@CacheConfig注解，queryStudentBySno方法使用了注解@Cacheable(key=&quot;#p0&quot;)，即将id作为redis中的key值。当我们更新数据的时候，应该使用@CachePut(key=&quot;#p0.sno&quot;)进行缓存数据的更新，否则将查询到脏数据，因为该注解保存的是方法的返回值，所以这里应该返回Student。\n其实现类：\n@Repository(&quot;studentService&quot;)public class StudentServiceImpl implements StudentService&#123;    @Autowired    private StudentMapper studentMapper;        @Override    public Student update(Student student) &#123;        this.studentMapper.update(student);        return this.studentMapper.queryStudentBySno(student.getSno());    &#125;        @Override    public void deleteStudentBySno(String sno) &#123;        this.studentMapper.deleteStudentBySno(sno);    &#125;        @Override    public Student queryStudentBySno(String sno) &#123;        return this.studentMapper.queryStudentBySno(sno);    &#125;&#125;\n\n\n在Spring Boot中可使用的缓存注解有：\n缓存注解\n@CacheConfig：主要用于配置该类中会用到的一些共用的缓存配置。在这里@CacheConfig(cacheNames = &quot;student&quot;)：配置了该数据访问对象中返回的内容将存储于名为student的缓存对象中，我们也可以不使用该注解，直接通过@Cacheable自己配置缓存集的名字来定义；\n@Cacheable：配置了queryStudentBySno函数的返回值将被加入缓存。同时在查询时，会先从缓存中获取，若不存在才再发起对数据库的访问。该注解主要有下面几个参数：\nvalue、cacheNames：两个等同的参数（cacheNames为Spring 4新增，作为value的别名），用于指定缓存存储的集合名。由于Spring 4中新增了@CacheConfig，因此在Spring 3中原本必须有的value属性，也成为非必需项了；\nkey：缓存对象存储在Map集合中的key值，非必需，缺省按照函数的所有参数组合作为key值，若自己配置需使用SpEL表达式，比如：@Cacheable(key = &quot;#p0&quot;)：使用函数第一个参数作为缓存的key值，更多关于SpEL表达式的详细内容可参考https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache；\ncondition：缓存对象的条件，非必需，也需使用SpEL表达式，只有满足表达式条件的内容才会被缓存，比如：@Cacheable(key = &quot;#p0&quot;, condition = &quot;#p0.length() &lt; 3&quot;)，表示只有当第一个参数的长度小于3的时候才会被缓存；\nunless：另外一个缓存条件参数，非必需，需使用SpEL表达式。它不同于condition参数的地方在于它的判断时机，该条件是在函数被调用之后才做判断的，所以它可以通过对result进行判断；\nkeyGenerator：用于指定key生成器，非必需。若需要指定一个自定义的key生成器，我们需要去实现org.springframework.cache.interceptor.KeyGenerator接口，并使用该参数来指定；\ncacheManager：用于指定使用哪个缓存管理器，非必需。只有当有多个时才需要使用；\ncacheResolver：用于指定使用那个缓存解析器，非必需。需通过org.springframework.cache.interceptor.CacheResolver接口来实现自己的缓存解析器，并用该参数指定；\n\n\n@CachePut：配置于函数上，能够根据参数定义条件来进行缓存，其缓存的是方法的返回值，它与@Cacheable不同的是，它每次都会真实调用函数，所以主要用于数据新增和修改操作上。它的参数与@Cacheable类似，具体功能可参考上面对@Cacheable参数的解析；\n@CacheEvict：配置于函数上，通常用在删除方法上，用来从缓存中移除相应数据。除了同@Cacheable一样的参数之外，它还有下面两个参数：\nallEntries：非必需，默认为false。当为true时，会移除所有数据；\nbeforeInvocation：非必需，默认为false，会在调用方法之后移除数据。当为true时，会在调用方法之前移除数据。\n\n\n\n缓存实现要使用上Spring Boot的缓存功能，还需要提供一个缓存的具体实现。Spring Boot根据下面的顺序去侦测缓存实现：\n\nGeneric\nJCache (JSR-107)\nEhCache 2.x\nHazelcast\nInfinispan\nRedis\nGuava\nSimple\n\n除了按顺序侦测外，我们也可以通过配置属性spring.cache.type来强制指定。\n接下来主要介绍基于Redis和Ehcache的缓存实现。\nRedisRedis的下载地址为https://github.com/MicrosoftArchive/redis/releases，Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 Redis-x64-xxx.zip压缩包到C盘。打开一个CMD窗口，输入如下命令：\nC:\\Users\\Administrator&gt;cd c:\\Redis-x64-3.2.100c:\\Redis-x64-3.2.100&gt;redis-server.exe redis.windows.conf                _._           _.-``__ &#x27;&#x27;-._      _.-``    `.  `_.  &#x27;&#x27;-._           Redis 3.2.100 (00000000/0) 64 bit  .-`` .-```.  ```\\/    _.,_ &#x27;&#x27;-._ (    &#x27;      ,       .-`  | `,    )     Running in standalone mode |`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;|     Port: 6379 |    `-._   `._    /     _.-&#x27;    |     PID: 6404  `-._    `-._  `-./  _.-&#x27;    _.-&#x27; |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;| |    `-._`-._        _.-&#x27;_.-&#x27;    |           http://redis.io  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27; |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;| |    `-._`-._        _.-&#x27;_.-&#x27;    |  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;      `-._    `-.__.-&#x27;    _.-&#x27;          `-._        _.-&#x27;              `-.__.-&#x27;[6404] 25 Dec 09:47:58.890 # Server started, Redis version 3.2.100[6404] 25 Dec 09:47:58.898 * DB loaded from disk: 0.007 seconds[6404] 25 Dec 09:47:58.898 * The server is now ready to accept connections on port 6379\n\n\n然后打开另外一个CMD终端，输入：\nC:\\Users\\Administrator&gt;cd c:\\Redis-x64-3.2.100c:\\Redis-x64-3.2.100&gt;redis-cli.exe -p 6379127.0.0.1:6379&gt;\n\n\n准备工作做完后，接下来开始在Spring Boot项目里引入Redis：\n&lt;!-- spring-boot redis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n在application.yml中配置Redis：\nspring:  redis:    # Redis数据库索引（默认为0）    database: 0    # Redis服务器地址    host: localhost    # Redis服务器连接端口    port: 6379    pool:      # 连接池最大连接数（使用负值表示没有限制）      max-active: 8      # 连接池最大阻塞等待时间（使用负值表示没有限制）      max-wait: -1      # 连接池中的最大空闲连接      max-idle: 8      # 连接池中的最小空闲连接      min-idle: 0    # 连接超时时间（毫秒）    timeout: 0\n\n\n更多关于Spring Boot Redis配置可参考：https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html# REDIS\n接着创建一个Redis配置类：\n@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123;    // 自定义缓存key生成策略    @Bean    public KeyGenerator keyGenerator() &#123;        return new KeyGenerator() &#123;            @Override            public Object generate(Object target, java.lang.reflect.Method method, Object... params) &#123;                StringBuffer sb = new StringBuffer();                sb.append(target.getClass().getName());                sb.append(method.getName());                for (Object obj : params) &#123;                    sb.append(obj.toString());                &#125;                return sb.toString();            &#125;        &#125;;    &#125;    // 缓存管理器    @Bean    public CacheManager cacheManager(@SuppressWarnings(&quot;rawtypes&quot;) RedisTemplate redisTemplate) &#123;        RedisCacheManager cacheManager = new RedisCacheManager(redisTemplate);        // 设置缓存过期时间（秒）        cacheManager.setDefaultExpiration(3600);        return cacheManager;    &#125;    @Bean    public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) &#123;        StringRedisTemplate template = new StringRedisTemplate(factory);        setSerializer(template);// 设置序列化工具        template.afterPropertiesSet();        return template;    &#125;    private void setSerializer(StringRedisTemplate template) &#123;        @SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);        ObjectMapper om = new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        template.setValueSerializer(jackson2JsonRedisSerializer);    &#125;&#125;\n\n\n运行测试，控制台输出：\n2017-11-17 18:17:06.995 DEBUG 8836 --- [main] c.s.m.StudentMapper.queryStudentBySno    : ==&gt;  Preparing: select * from student where sno=? 2017-11-17 18:17:07.128 DEBUG 8836 --- [main] c.s.m.StudentMapper.queryStudentBySno    : ==&gt; Parameters: 001(String)2017-11-17 18:17:07.152 DEBUG 8836 --- [main] c.s.m.StudentMapper.queryStudentBySno    : &lt;==      Total: 1学号001的学生姓名为：KangKang学号001的学生姓名为：KangKang\n\n\n第二次查询没有访问数据库，而是从缓存中获取的，在redis中查看该值：\n127.0.0.1:6379&gt;   keys *1) &quot;student~keys&quot;2) &quot;001&quot;127.0.0.1:6379&gt; get 001&quot;[\\&quot;com.springboot.bean.Student\\&quot;,&#123;\\&quot;sno\\&quot;:\\&quot;001\\&quot;,\\&quot;name\\&quot;:\\&quot;KangKang\\&quot;,\\&quot;sex\\&quot;:\\&quot;M \\&quot;&#125;]&quot;\n\n\n在测试方法中测试更新：\n@Testpublic void test() throws Exception &#123;    Student student1 = this.studentService.queryStudentBySno(&quot;001&quot;);    System.out.println(&quot;学号&quot; + student1.getSno() + &quot;的学生姓名为：&quot; + student1.getName());        student1.setName(&quot;康康&quot;);    this.studentService.update(student1);        Student student2 = this.studentService.queryStudentBySno(&quot;001&quot;);    System.out.println(&quot;学号&quot; + student2.getSno() + &quot;的学生姓名为：&quot; + student2.getName());&#125;\n\n\n控制台输出：\n学号001的学生姓名为：KangKang2017-11-17 19:30:05.813  INFO 11244 --- [main] com.alibaba.druid.pool.DruidDataSource   : &#123;dataSource-1&#125; inited2017-11-17 19:30:05.823 DEBUG 11244 --- [main] c.s.mapper.StudentMapper.update          : ==&gt;  Preparing: update student set sname=?,ssex=? where sno=? 2017-11-17 19:30:05.941 DEBUG 11244 --- [main] c.s.mapper.StudentMapper.update          : ==&gt; Parameters: 康康(String), M (String), 001(String)2017-11-17 19:30:05.953 DEBUG 11244 --- [main] c.s.mapper.StudentMapper.update          : &lt;==    Updates: 12017-11-17 19:30:05.957 DEBUG 11244 --- [main] c.s.m.StudentMapper.queryStudentBySno    : ==&gt;  Preparing: select * from student where sno=? 2017-11-17 19:30:05.959 DEBUG 11244 --- [main] c.s.m.StudentMapper.queryStudentBySno    : ==&gt; Parameters: 001(String)2017-11-17 19:30:05.976 DEBUG 11244 --- [main] c.s.m.StudentMapper.queryStudentBySno    : &lt;==      Total: 1学号001的学生姓名为：康康\n\n\n在redis中查看：\n127.0.0.1:6379&gt; get 001&quot;[\\&quot;com.springboot.bean.Student\\&quot;,&#123;\\&quot;sno\\&quot;:\\&quot;001\\&quot;,\\&quot;name\\&quot;:\\&quot;\\xe5\\xba\\xb7\\xe5\\xba\\xb7\\&quot;,\\&quot;sex\\&quot;:\\&quot;M \\&quot;&#125;]&quot;\n\n\n可见更新数据库的同时，缓存也得到了更新。\n源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/09.Spring-Boot-Redis-Cache\nEhcache引入Ehcache依赖：\n&lt;!-- ehcache --&gt;&lt;dependency&gt;    &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n在src/main/resources目录下新建ehcache.xml：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xsi:noNamespaceSchemaLocation=&quot;ehcache.xsd&quot;&gt;    &lt;defaultCache        maxElementsInMemory=&quot;10000&quot;        eternal=&quot;false&quot;        timeToIdleSeconds=&quot;3600&quot;        timeToLiveSeconds=&quot;0&quot;        overflowToDisk=&quot;false&quot;        diskPersistent=&quot;false&quot;        diskExpiryThreadIntervalSeconds=&quot;120&quot; /&gt;    &lt;cache         name=&quot;student&quot;        maxEntriesLocalHeap=&quot;2000&quot;        eternal=&quot;false&quot;        timeToIdleSeconds=&quot;3600&quot;        timeToLiveSeconds=&quot;0&quot;        overflowToDisk=&quot;false&quot;        statistics=&quot;true&quot;/&gt;&lt;/ehcache&gt;\n\n\n关于Ehcahe的一些说明：\n\nname：缓存名称。\nmaxElementsInMemory：缓存最大数目\nmaxElementsOnDisk：硬盘最大缓存个数。\neternal：对象是否永久有效，一但设置了，timeout将不起作用。\noverflowToDisk：是否保存到磁盘。\ntimeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。\ntimeToLiveSeconds：设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0，也就是对象存活时间无穷大。\ndiskPersistent：是否缓存虚拟机重启期数据，默认值为false。\ndiskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。\ndiskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。\nmemoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。\nclearOnFlush：内存数量最大时是否清除。\nmemoryStoreEvictionPolicy：Ehcache的三种清空策略：FIFO，first in first out，这个是大家最熟的，先进先出。LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。\n\n接着在application.yml中指定ehcache配置的路径：\nspring:  cache:    ehcache:      config: &#x27;classpath:ehcache.xml&#x27;\n\n\n这样就可以开始使用ehcache了，运行测试类，观察控制台：\n2017-11-18 09:10:40.201 DEBUG 3364 --- [main] c.s.m.StudentMapper.queryStudentBySno    : ==&gt;  Preparing: select * from student where sno=? 2017-11-18 09:10:40.343 DEBUG 3364 --- [main] c.s.m.StudentMapper.queryStudentBySno    : ==&gt; Parameters: 001(String)2017-11-18 09:10:40.364 DEBUG 3364 --- [main] c.s.m.StudentMapper.queryStudentBySno    : &lt;==      Total: 1学号001的学生姓名为：KangKang学号001的学生姓名为：KangKang\n\n\n可看到第二次是从缓存中获取的。\n测试更新：\n2017-11-18 09:18:04.230 DEBUG 11556 --- [main] c.s.m.StudentMapper.queryStudentBySno    : ==&gt;  Preparing: select * from student where sno=? 2017-11-18 09:18:04.397 DEBUG 11556 --- [main] c.s.m.StudentMapper.queryStudentBySno    : ==&gt; Parameters: 001(String)2017-11-18 09:18:04.427 DEBUG 11556 --- [main] c.s.m.StudentMapper.queryStudentBySno    : &lt;==      Total: 1学号001的学生姓名为：KangKang2017-11-18 09:18:04.433 DEBUG 11556 --- [main] c.s.mapper.StudentMapper.update          : ==&gt;  Preparing: update student set sname=?,ssex=? where sno=? 2017-11-18 09:18:04.438 DEBUG 11556 --- [main] c.s.mapper.StudentMapper.update          : ==&gt; Parameters: 康康(String), M (String), 001(String)2017-11-18 09:18:04.440 DEBUG 11556 --- [main] c.s.mapper.StudentMapper.update          : &lt;==    Updates: 12017-11-18 09:18:04.440 DEBUG 11556 --- [main] c.s.m.StudentMapper.queryStudentBySno    : ==&gt;  Preparing: select * from student where sno=? 2017-11-18 09:18:04.441 DEBUG 11556 --- [main] c.s.m.StudentMapper.queryStudentBySno    : ==&gt; Parameters: 001(String)2017-11-18 09:18:04.442 DEBUG 11556 --- [main] c.s.m.StudentMapper.queryStudentBySno    : &lt;==      Total: 1学号001的学生姓名为：康康\n\n\n可见，即使更新方法加了@CachePut注解，第二次查询因为Student对象更新了，其是从数据库获取数据的，所以对于Ehcache来说，更新方法加不加@CachePut注解，结果都一样。\n源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/10.Spring-Boot-Ehcache-Cache\nFrom: [https://mrbird.cc/Spring-Boot%20cache.html](\n","categories":["springboot"],"tags":["springboot","缓存"]},{"title":"springCloud入门","url":"https://www.mele.cool/2020/12/04/springcloud入门(1)/","content":"1.RestTemplate的介绍一般情况下有如下三种http客户端工具类包都可以方便的进行http服务调用:\n\nhttpClient\nokHttp\nJDK原生URLConnection\n\nspring提供了RestTemplate的工具类对上述的3种http客户端工具类进行了封装,可在spring项目中使用RestTemplate进行服务调用。\n1.1启动类注入RestTemplate\n1.2 代码中使用\n2.入门工程\n2.1 父工程依赖\n通过scope的import可以继承spring-cloud-dependencies工程中的依赖\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.bgt&lt;/groupId&gt;    &lt;artifactId&gt;springcloud&lt;/artifactId&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;modules&gt;        &lt;module&gt;user-service&lt;/module&gt;        &lt;module&gt;user-consumer&lt;/module&gt;    &lt;/modules&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;        &lt;relativePath&gt;&lt;/relativePath&gt;    &lt;/parent&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;spring-cloud.version&gt;Greenwich.SR1&lt;/spring-cloud.version&gt;        &lt;mapper.starter.version&gt;2.1.5&lt;/mapper.starter.version&gt;        &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt;    &lt;/properties&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;&lt;!--            spring-cloud &lt;scope&gt;import&lt;/scope&gt;此处配置意为本项目不仅继承springboot2.1.5.RELEASE的依赖坐标,同时也继承spring-cloud-dependencies Greenwich.SR1的依赖坐标--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;&lt;!--            通用mapper--&gt;            &lt;dependency&gt;                &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;                &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;                &lt;version&gt;$&#123;mapper.starter.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;mysql&lt;/groupId&gt;                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n2.2 user-service 生产者2.2.1依赖\n版本号在父工程中管理,子工程不需要声明版本号\n\n&lt;!--            通用mapper--&gt;            &lt;dependency&gt;                &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;                &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;            &lt;/dependency&gt;&lt;!--            mysql--&gt;            &lt;dependency&gt;                &lt;groupId&gt;mysql&lt;/groupId&gt;                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;/dependency&gt;\n2.2.2 配置文件\n2.2.3 创建实体类及数据库表2.2.4 启动类加mybatis注解\n2.2.5 编写mapper\n2.2.6 编写业务类service\n2.2.7 编写处理器controller\n2.2.8 测试\n2.3 user-consumer 消费者2.3.1 添加依赖\n2.3.2 启动类注入RestTemplate\n2.3.3 编写controller\n编写用到的user类\n\n\n2.3.4 测试\n2.4 问题\n\n上述的问题都可以通过Spring Cloud的各种组件解决。\n\n3.Eureka 注册中心\n\n\nEureka的主要功能是进行服务管理,定期检查服务状态,返回服务地址列表。\n\n3.1 搭建eureka-server工程\nEureka是服务注册中心,只做服务注册;自身并不提供服务也不消费服务。可以搭建web工程使用Eureka ,可以使用Spring Boot方式搭建。\n\n\n3.1.1 依赖\n3.1.2 启动类\n3.1.3 配置文件\n3.1.4 启动测试,能否查看到\n3.2 服务注册与发现\n目标:将user-service的服务注册到eureka并在consumer-demo中可以根据服务名称调用\n\n\n3.2.1 生产者工程user-serivce依赖\n3.2.2 生产者工程user-serivce启动器修改\n3.2.3 生产者工程user-serivce修改配置文件\n3.2.4 生产者工程user-serivce启动测试测试\n启动eureka服务,启动user-service服务,成功标准是在eureka界面可以看到user-service的服务注册成功.\n\n\n3.2.5 消费者工程user-consumer添加依赖\n3.2.6 消费者工程user-consumer启动类修改\n3.2.7 消费者工程user-consumer配置文件修改\n3.2.8 消费者工程user-consumer处理器controller修改\n3.2.9 测试3.3 Eureka Server高可用配置\n\n3.3.1 eureka-server工程1修改配置文件\n${port:10086}  表示如果提供port就用提供的port,否则使用10086\n\n\n3.3.2 修改启动项,并复制一个新的启动器,相互注册.\n \n3.3.3 启动两个启动类,查看效果\n\n3.3.4  启动user-service\n本服务会自动注册到10086 10087两个eureka-server中\n也可以在配置文件中配置注册到多台eureka-server中\n\n\n3.4 Eureka客户端与服务端配置\n3.4.1 服务提供者设置 使用ip地址\n\n3.4.2 服务提供者服务续约配置\n\n\n并非服务失效时间到了就一定会剔除,只是说时间到了表示该服务可以被剔除,具体啥时剔除需要eureka-server扫描到(默认60秒扫描一次). \n\n3.4.3 服务消费者设置拉取服务列表间隔时间\n3.4.4 eureka-server服务端设置失效剔除时间间隔\n3.4.5 eureka-server服务端设置关闭自我保护模式(开发中推荐设置)\n4.Ribbon负载均衡\n\n依赖来自于eureka.\n需求:可以使用RestTemplate访问http://user-service/user/8获取服务数据。\n\n\n4.1 启动两个user-serivce4.2 服务消费者启动类添加注解\n4.3 服务消费者controller修改\n5.hystrix熔断器(服务消费者)\n雪崩问题:\n\n5.1 开启熔断\n5.1.1 依赖\n5.1.2 服务消费者开启熔断\n5.1.3 服务消费者编写降级逻辑\n5.1.4 服务消费者默认降级逻辑\n5.1.3中针对单个方法的降级逻辑,如果方法多了,每个方法都这么写不现实,可以根据类设置默认降级回调方法\n\n\n\n5.1.5 服务消费者设置熔断器hystrix超时时间\n5.2 熔断原理\n  修改熔断器阈值:\n\n6. Feign\n6.1 使用\n6.1.1 消费者工程添加依赖\n6.1.2 修改启动类,开启feign功能\n6.1.3 编写feign客户端代码\n6.1.4 编写处理器controller\n6.1.5 测试\n6.2feign负载均衡及熔断\n6.2.1 负载均衡\n\n6.2.2 hystrix支持  熔断6.2.2.1 服务消费者修改配置文件开启feign熔断功能\n6.2.2.2 编写熔断降级类\n6.2.2.3  feign客户端指定使用降级类\n6.2.3 请求压缩6.2.4 日志级别7.Gateway 网关\n\n核心概念:\n\n\n7.1 入门工程7.1.1 依赖\n7.1.2 启动类 \n7.1.3 配置文件\n\nhttp://127.0.0.1:10010/user/8 -&gt; http://127.0.0.1:9091/user/8\n\n7.1.4 测试\n7.2 面向服务的路由(动态路由)\n\n7.3 路由前缀处理\n7.3.1 添加前缀\n\n7.3.2 去除前缀\n\n7.4 过滤器\n \n\n\n\n\n\n7.5 自定义过滤器7.5.1 自定义局部过滤器\n需求:在过滤器( MyParamGatewayFilterFactory )中将http://localhost:10010/api/user/8?name=itcast中的参数name的值获取到并输出到控制台;并且参数名是可变的,也就是不一定每次都是name ;需要可以通过配置过滤器的时候做到配置参数名。\n\n7.5.1.1 配置\n7.5.1.2 编写过滤器类\n7.5.1.3 测试\n7.5.2 自定义全局过滤器\n需求:编写全局过滤器,在过滤器中检查请求地址是否携带token参数。如果token参数的值存在则放行;如果token的参数值为空或者不存在则设置返回的状态码为:未授权也不再执行下去\n\n7.5.2.1 编写全局过滤器\n7.5.2.2 测试 \n7.6 gateway其他配置\n8.springcloud config 配置中心\nspring cloud config作用:可以通过修改在git仓库中的配置文件实现其它所有微服务的配置文件的修改。\n\n\n8.1 搭建配置中心微服务8.1.1 依赖\n8.1.2 启动类\n8.1.3 配置文件\n8.1.4 测试\n在gitee中修改了配置文件会在配置中心服务及时更新。\n\n\n8.2  获取配置中心配置\n\n 目标:改造用户微服务user-service ,配置文件信息不再由微服务项目提供,而是从配置中心获取 需求:将服务提供工程user-service的application.yml配置文件删除,修改为从配置中心config-server中获取。 实现步骤:     1.添加启动器依赖;     2.修改配置文件;     3.启动测试\n\n8.2.1 依赖\n8.2.2 删除原来配置文件application.propetes,创建bootstrap.yml\n将原来的application.yml删除;然后添加bootstrap.yml配置文件,该文件也是spring boot的默认配置文件,其内容经常配置一些项目中固定的配置项。如果是项目经常变动的应该配置到application.yml中,现在使用了配置中心则应该配置到git仓库中对于的配置文件。\n\n\n8.2.3 测试成功\n9.springcloud bus消息总线\nSpring Cloud Bus是用轻量的消息代理将分布式的节点连接起来,可以用于广播配置文件的更改或者服务的监控管理。也就是消息总线可以为微服务做监控,也可以实现应用程序之间相互通信。 Spring Cloud Bus可选的消息 理有RabbitMQ和Kafka\nSpring Cloud Bus作用:将git仓库的配置文件更新,在不重启系统的情况下实现及时同步到各个微服务。\n\n\n目标:启动RabbitMQ通过修改码云中的配置文件后发送Post请求实现及时更新用户微服务中的配置项分析需求:**在码云的git仓库中修改user-dev.yml配置文件,实现不重启user-service的情况下可以及时更新配置文件。**实现步骤:\n\n启动RabbitMQ;\n修改配置中心config-server;\n修改服务提供工程dser-service ;\n测试\n\n9.1改造配置中心9.1.1 在config-server项目的pom.xml文件中加入Spring Cloud Bus相关依赖\n9.1.2 修改配置文件\n9.3 修改服务提供工程9.3.1 添加依赖\n9.3.2 配置文件\n9.3.3 修改控制器\n9.3.4 测试git上修改完配置文件后,需要手动访问下配置中心的这个路径,才会发消息给服务获取最新配置项:\n\n\n10. springCloud综合应用\n","categories":["springCloud"],"tags":["入门","java","springCloud"]},{"title":"Java 分布式框架面试题合集","url":"https://www.mele.cool/2020/12/04/分布式框架面试题合集/","content":"1.什么是 ZooKeeper？答：ZooKeeper 是一个开源的分布式应用程序协调服务，是一个典型的分布式数据一致性解决方案。设计目的是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的系统，并以一系列简单易用的原子操作提供给用户使用。\n2.ZooKeeper 提供了哪些功能？答：ZooKeeper 主要提供以下功能：\n\n分布式服务注册与订阅：在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就须要在这些对等的服务器中选择一个来执行相关的业务逻辑，比较典型的服务注册与订阅，如 Dubbo。\n分布式配置中心：发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到 ZooKeeper 节点上，供订阅者获取数据，实现配置信息的集中式管理和动态更新。\n命名服务：在分布式系统中，通过命名服务客户端应用能够根据指定名字来获取资源、服务地址和提供者等信息。\n分布式锁：这个主要得益于 ZooKeeper 为我们保证了数据的强一致性。\n\n3.ZooKeeper 有几种搭建模式？答：ZooKeeper 通常有三种搭建模式：\n\n单机模式：zoo.cfg 中只配置一个 server.id 就是单机模式了，此模式一般用在测试环境，如果当前主机宕机，那么所有依赖于当前 ZooKeeper 服务工作的其他服务器都不能进行正常工作；\n伪分布式模式：在一台机器启动不同端口的 ZooKeeper，配置到 zoo.cfg 中，和单机模式相同，此模式一般用在测试环境；\n分布式模式：多台机器各自配置 zoo.cfg 文件，将各自互相加入服务器列表，上面搭建的集群就是这种完全分布式。\n\n4.ZooKeeper 有哪些特性？答： ZooKeeper 特性如下：\n\n顺序一致性（Sequential Consistency）：来自相同客户端提交的事务，ZooKeeper 将严格按照其提交顺序依次执行；\n原子性（Atomicity）：于 ZooKeeper 集群中提交事务，事务将“全部完成”或“全部未完成”，不存在“部分完成”；\n单一系统镜像（Single System Image）：客户端连接到 ZooKeeper 集群的任意节点，其获得的数据视图都是相同的；\n可靠性（Reliability）：事务一旦完成，其产生的状态变化将永久保留，直到其他事务进行覆盖；\n实时性（Timeliness）：事务一旦完成，客户端将于限定的时间段内，获得最新的数据。\n\n5.以下关于 ZooKeeper 描述错误的是？A：所有的节点都具有稳定的存储能力 B：ZooKeeper 任意节点之间都能够进行通信（消息发送 &amp; 接收） C：为了提高性能，ZooKeeper 允许同一份数据存在一部分节点写成功，另一部分节点写失败 D：ZooKeeper 集群运行期间，只要半数以上节点存活，ZooKeeper 就能正常服务 答：C 题目解析：ZooKeeper 不允许同一份数据存在一部分节点写成功，另一部分节点写失败的情况，这不符合 ZooKeeper“一致性”的原则。\n6.ZooKeeper 如何实现分布式锁？答：ZooKeeper 实现分布式锁的步骤如下：\n\n客户端连接 ZooKeeper，并在 /lock 下创建临时的且有序的子节点，第一个客户端对应的子节点为 /lock/lock-10000000001，第二个为 /lock/lock-10000000002，以此类推。\n客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，否则监听刚好在自己之前一位的子节点删除消息，获得子节点变更通知后重复此步骤直至获得锁；\n执行业务代码；\n完成业务流程后，删除对应的子节点释放锁。\n\n整体流程如下图所示：\n\n7.ZooKeeper 如何实现分布式事务？答：ZooKeeper 实现分布式事务，类似于两阶段提交，总共分为以下 4 步：\n\n客户端先给 ZooKeeper 节点发送写请求；\nZooKeeper 节点将写请求转发给 Leader 节点，Leader 广播给集群要求投票，等待确认；\nLeader 收到确认，统计投票，票数过半则提交事务；\n事务提交成功后，ZooKeeper 节点告知客户端。\n\n8.集群中为什么要有主节点？答：在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，这就是主节点存在的意义。\n9.Dubbo 是什么？答：Dubbo 是一款高性能、轻量级的开源 Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。\n10.Dubbo 有哪些特性？答：Dubbo 特性如下：\n\n面向接口代理的高性能 RPC 调用：提供高性能的基于代理的远程调用能力，服务以接口为粒度，为开发者屏蔽远程调用底层细节；\n智能负载均衡：内置多种负载均衡策略，智能感知下游节点健康状况，显著减少调用延迟，提高系统吞吐量；\n服务自动注册与发现：支持多种注册中心服务，服务实例上下线实时感知；\n高度可扩展能力：遵循微内核+插件的设计原则，所有核心能力如 Protocol、Transport、Serialization 被设计为扩展点，平等对待内置实现和第三方实现；\n运行期流量调度：内置条件、脚本等路由策略，通过配置不同的路由规则，轻松实现灰度发布，同机房优先等功能；\n可视化的服务治理与运维：提供丰富服务治理、运维工具：随时查询服务元数据、服务健康状态及调用统计，实时下发路由策略、调整配置参数。\n\n11.Dubbo 有哪些核心组件？答：Dubbo 核心组件如下：\n\nProvider：服务提供方\nConsumer：服务消费方\nRegistry：服务注册与发现的注册中心\nMonitor：主要用来统计服务的调用次数和调用时间\nContainer：服务的运行容器\n\n12.Dubbo 有哪些负载均衡策略？答：Dubbo 负责均衡策略如下：\n\n随机负载均衡（Random LoadBalance）：按权重设置随机概率，在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重；\n轮询负载均衡（RoundRobin LoadBalance）：按公约后的权重设置轮询比率，存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上；\n最少活跃调用数负载均衡（LeastActive LoadBalance）：使用最少活跃调用数，活跃数指调用前后计数差；\n哈希负载均衡（ConsistentHash LoadBalance）：使用哈希值转发，相同参数的请求总是发到同一提供者。\n\n负载均衡配置如下：\n服务端服务级别\n&lt;dubbo:service interface=&quot;xxx&quot; loadbalance=&quot;roundrobin&quot; /&gt;\n客户端服务级别\n&lt;dubbo:reference interface=&quot;xxx&quot; loadbalance=&quot;roundrobin&quot; /&gt;\n服务端方法级别\n&lt;dubbo:service interface=&quot;xxx&quot;&gt;   &lt;dubbo:method name=&quot;xxx&quot; loadbalance=&quot;roundrobin&quot;/&gt;&lt;/dubbo:service&gt;\n客户端方法级别\n&lt;dubbo:reference interface=&quot;xxx&quot;&gt;   &lt;dubbo:method name=&quot;xxx&quot; loadbalance=&quot;roundrobin&quot;/&gt;&lt;/dubbo:reference&gt;\n13.Dubbo 不支持以下哪种协议？A：dubbo://B：rmi://C：redis://D：restful://\n答：D\n题目解析：restful 是一种编程规范，并不是一种传输协议，也不被 Dubbo 支持。\n14.Dubbo 默认使用什么注册中心，还有别的选择吗？答：推荐使用 ZooKeeper 作为注册中心，还有 Nacos、Redis、Simple 注册中心（普通的 Dubbo 服务）。\n15.Dubbo 支持多注册中心吗？答：Dubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。\n多注册中心注册：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt;    &lt;dubbo:application name=&quot;world&quot;  /&gt;    &lt;!-- 多注册中心配置 --&gt;    &lt;dubbo:registry id=&quot;hangzhouRegistry&quot; address=&quot;10.20.141.150:9090&quot; /&gt;    &lt;dubbo:registry id=&quot;qingdaoRegistry&quot; address=&quot;10.20.141.151:9010&quot; default=&quot;false&quot; /&gt;    &lt;!-- 向多个注册中心注册 --&gt;    &lt;dubbo:service interface=&quot;com.alibaba.hello.api.HelloService&quot; version=&quot;1.0.0&quot; ref=&quot;helloService&quot; registry=&quot;hangzhouRegistry,qingdaoRegistry&quot; /&gt;&lt;/beans&gt;\n16.Dubbo 支持的连接方式有哪些？答：Dubbo 支持的主要连接方式有：组播、直连和 ZooKeeper 等注册中心。\n① 组播方式，不需要启动任何中心节点，只要广播地址一样，就可以互相发现。\n\n\n提供方启动时广播自己的地址\n消费方启动时广播订阅请求\n提供方收到订阅请求时，单播自己的地址给订阅者，如果设置了 unicast=false，则广播给订阅者\n消费方收到提供方地址时，连接该地址进行 RPC 调用\n\n组播受网络结构限制，只适合小规模应用或开发阶段使用。组播地址段：224.0.0.0 ~ 239.255.255.255\n配置\n&lt;dubbo:registry address&#x3D;&quot;multicast:&#x2F;&#x2F;224.5.6.7:1234&quot; &#x2F;&gt;\n或\n&lt;dubbo:registry protocol&#x3D;&quot;multicast&quot; address&#x3D;&quot;224.5.6.7:1234&quot; &#x2F;&gt;\n为了减少广播量，Dubbo 缺省使用单播发送提供者地址信息给消费者，如果一个机器上同时启了多个消费者进程，消费者需声明 unicast=false，否则只会有一个消费者能收到消息；当服务者和消费者运行在同一台机器上，消费者同样需要声明 unicast=false，否则消费者无法收到消息，导致 No provider available for the service 异常：\n&lt;dubbo:registry address&#x3D;&quot;multicast:&#x2F;&#x2F;224.5.6.7:1234?unicast&#x3D;false&quot; &#x2F;&gt;\n或\n&lt;dubbo:registry protocol&#x3D;&quot;multicast&quot; address&#x3D;&quot;224.5.6.7:1234&quot;&gt;    &lt;dubbo:parameter key&#x3D;&quot;unicast&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;&lt;&#x2F;dubbo:registry&gt;\n② 直连方式，注册中心本身就是一个普通的 Dubbo 服务，可以减少第三方依赖，使整体通讯方式一致。\n&lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;N/A&quot;  file=&quot;./.dubbo-platform&quot;/&gt;\n将 Simple 注册中心暴露成 Dubbo 服务：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;    xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&quot;    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-4.3.xsd http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&quot;&gt;    &lt;!-- 当前应用信息配置 --&gt;    &lt;dubbo:application name&#x3D;&quot;simple-registry&quot; &#x2F;&gt;    &lt;!-- 暴露服务协议配置 --&gt;    &lt;dubbo:protocol port&#x3D;&quot;9090&quot; &#x2F;&gt;    &lt;!-- 暴露服务配置 --&gt;    &lt;dubbo:service interface&#x3D;&quot;org.apache.dubbo.registry.RegistryService&quot; ref&#x3D;&quot;registryService&quot; registry&#x3D;&quot;N&#x2F;A&quot; ondisconnect&#x3D;&quot;disconnect&quot; callbacks&#x3D;&quot;1000&quot;&gt;        &lt;dubbo:method name&#x3D;&quot;subscribe&quot;&gt;&lt;dubbo:argument index&#x3D;&quot;1&quot; callback&#x3D;&quot;true&quot; &#x2F;&gt;&lt;&#x2F;dubbo:method&gt;        &lt;dubbo:method name&#x3D;&quot;unsubscribe&quot;&gt;&lt;dubbo:argument index&#x3D;&quot;1&quot; callback&#x3D;&quot;false&quot; &#x2F;&gt;&lt;&#x2F;dubbo:method&gt;    &lt;&#x2F;dubbo:service&gt;    &lt;!-- 简单注册中心实现，可自行扩展实现集群和状态同步 --&gt;    &lt;bean id&#x3D;&quot;registryService&quot; class&#x3D;&quot;org.apache.dubbo.registry.simple.SimpleRegistryService&quot; &#x2F;&gt;&lt;&#x2F;beans&gt;\n引用 Simple Registry 服务：\n&lt;dubbo:registry address&#x3D;&quot;127.0.0.1:9090&quot; &#x2F;&gt;\n或者：\n&lt;dubbo:service interface&#x3D;&quot;org.apache.dubbo.registry.RegistryService&quot; group&#x3D;&quot;simple&quot; version&#x3D;&quot;1.0.0&quot; ... &gt;\n或者：\n&lt;dubbo:registry address&#x3D;&quot;127.0.0.1:9090&quot; group&#x3D;&quot;simple&quot; version&#x3D;&quot;1.0.0&quot; &#x2F;&gt;\n适用性说明：此 SimpleRegistryService 只是简单实现，不支持集群，可作为自定义注册中心的参考，但不适合直接用于生产环境。\n③ ZooKeeper 注册中心，Zookeeper 是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。\n\n流程说明：\n\n服务提供者启动时：向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址\n服务消费者启动时：订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址，并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址\n监控中心启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址\n\n支持以下功能：\n\n当提供者出现断电等异常停机时，注册中心能自动删除提供者信息\n当注册中心重启时，能自动恢复注册数据，以及订阅请求\n当会话过期时，能自动恢复注册数据，以及订阅请求\n当设置 `` 时，记录失败注册和订阅请求，后台定时重试\n可通过 `` 设置 zookeeper 登录信息\n可通过 `` 设置 zookeeper 的根节点，不设置将使用无根树\n支持 * 号通配符 ``，可订阅服务的所有分组和所有版本的提供者\n\nZookeeper 使用\n在 provider 和 consumer 中增加 zookeeper 客户端 jar 包依赖：\n&lt;dependency&gt;    &lt;groupId&gt;org.apache.zookeeper&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;zookeeper&lt;&#x2F;artifactId&gt;    &lt;version&gt;3.3.3&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;\nDubbo 支持 zkclient 和 curator 两种 Zookeeper 客户端实现：\n\n注意：在 2.7.x 的版本中已经移除了 zkclient 的实现，如果要使用 zkclient 客户端，需要自行拓展。\n\n使用 zkclient 客户端\n从 2.2.0 版本开始缺省为 zkclient 实现，以提升 zookeeper 客户端的健状性。zkclient 是 Datameer 开源的一个 Zookeeper 客户端实现。\n缺省配置：\n&lt;dubbo:registry ... client&#x3D;&quot;zkclient&quot; &#x2F;&gt;\n或：\ndubbo.registry.client&#x3D;zkclient\n或：\nzookeeper:&#x2F;&#x2F;10.20.153.10:2181?client&#x3D;zkclient\n需依赖或直接下载：\n&lt;dependency&gt;    &lt;groupId&gt;com.github.sgroschupf&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;zkclient&lt;&#x2F;artifactId&gt;    &lt;version&gt;0.1&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;\n使用 curator 客户端\n从 2.3.0 版本开始支持可选 curator 实现。Curator 是 Netflix 开源的一个 Zookeeper 客户端实现。\n如果需要改为 curator 实现，请配置：\n&lt;dubbo:registry ... client&#x3D;&quot;curator&quot; &#x2F;&gt;\n或：\ndubbo.registry.client&#x3D;curator\n或：\nzookeeper:&#x2F;&#x2F;10.20.153.10:2181?client&#x3D;curator\n需依赖或直接下载：\n&lt;dependency&gt;    &lt;groupId&gt;com.netflix.curator&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.1.10&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;\nZookeeper 单机配置:\n&lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;10.20.153.10:2181&quot; &#x2F;&gt;\n或：\n&lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;10.20.153.10:2181&quot; &#x2F;&gt;\nZookeeper 集群配置：\n&lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;10.20.153.10:2181?backup&#x3D;10.20.153.11:2181,10.20.153.12:2181&quot; &#x2F;&gt;\n或：\n&lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;10.20.153.10:2181,10.20.153.11:2181,10.20.153.12:2181&quot; &#x2F;&gt;\n同一 Zookeeper，分成多组注册中心：\n&lt;dubbo:registry id&#x3D;&quot;chinaRegistry&quot; protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;10.20.153.10:2181&quot; group&#x3D;&quot;china&quot; &#x2F;&gt;&lt;dubbo:registry id&#x3D;&quot;intlRegistry&quot; protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;10.20.153.10:2181&quot; group&#x3D;&quot;intl&quot; &#x2F;&gt;\n17.什么是服务熔断？答：在应用系统服务中，当依赖服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，临时切断对下游服务的调用。这种牺牲局部，保全整体的措施就叫做熔断。\n18.Dubbo 可以对结果进行缓存吗？支持的缓存类型都有哪些？答：可以，Dubbo 提供了声明式缓存，用于加速热门数据的访问速度，以减少用户加缓存的工作量。\nDubbo 支持的缓存类型有：\n\nlru 基于最近最少使用原则删除多余缓存，保持最热的数据被缓存；\nthreadlocal 当前线程缓存，比如一个页面渲染，用到很多 portal，每个 portal 都要去查用户信息，通过线程缓存，可以减少这种多余访问；\njcache 集成，可以桥接各种缓存实现。\n\n配置如下：\n&lt;dubbo:reference interface=&quot;com.foo.BarService&quot; cache=&quot;lru&quot; /&gt;\n或\n&lt;dubbo:reference interface=&quot;com.foo.BarService&quot;&gt;    &lt;dubbo:method name=&quot;findBar&quot; cache=&quot;lru&quot; /&gt;&lt;/dubbo:reference&gt;\n19.Dubbo 有几种集群容错模式？答：Dubbo 集群容错模式如下。\n① Failover Cluster失败自动切换，当出现失败，重试其他服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数（不含第一次）。\n重试次数配置如下：\n&lt;dubbo:service retries=&quot;2&quot; /&gt;\n或\n&lt;dubbo:reference retries=&quot;2&quot; /&gt;\n或\n&lt;dubbo:reference&gt;    &lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;&lt;/dubbo:reference&gt;\n② Failfast Cluster快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。\n③ Failsafe Cluster失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。\n④ Failback Cluster失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。\n⑤ Forking Cluster并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2” 来设置最大并行数。\n⑥ Broadcast Cluster广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。\n","categories":["java"],"tags":["分布式","ms"]},{"title":"深入学习springboot中的SpringApplication","url":"https://www.mele.cool/2020/12/04/深入学习Spring Boot中的SpringApplication/","content":"在Spring Boot的入口类中，我们通常是通过调用SpringApplication的run方法来启动Spring Boot项目。这节我们来深入学习下SpringApplication的一些细节。\n自定义SpringApplication默认的我们都是直接通过SpringApplication的run方法来直接启动Spring Boot，其实我们可以通过一些API来调整某些行为。\n通过SpringApplication API调整我们新建一个SpringBoot项目，Spring Boot版本为2.1.0.RELEASE，artifactId为SpringApplication，并引入spring-boot-starter-web依赖。项目结构如下所示:\n\n我们将入口类的代码改为：\nSpringApplication application = new SpringApplication(DemoApplication.class);application.setBannerMode(Banner.Mode.OFF);//关闭了Banner的打印application.setWebApplicationType(WebApplicationType.NONE);//设置应用环境为非WEB应用application.setAdditionalProfiles(&quot;dev&quot;);//profiles指定为devapplication.run(args);\n\n\n通过调用SpringApplication的方法，我们关闭了Banner的打印，设置应用环境为非WEB应用，profiles指定为dev。除此之外，SpringApplication还包含了许多别的方法，具体可以查看源码或者官方文档：\n\n通过SpringApplicationBuilder API调整SpringApplicationBuilder提供了Fluent API，可以实现链式调用，下面的代码和上面的效果一致，但在编写上较为方便：\nnew SpringApplicationBuilder(DemoApplication.class)        .bannerMode(Banner.Mode.OFF)        .web(WebApplicationType.NONE)        .profiles(&quot;dev&quot;)        .run(args);\nSpringApplication准备阶段SpringApplication的生命周期阶段大致可以分为准备阶段和运行阶段。\n我们通过源码来查看SpringApplication的有参构造器：\n\n通过有参构造器里的代码我们可以将SpringApplication的准备阶段分为以下几个步骤：\n配置源构造器中this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));这行代码用于加载我们配置的Spring Boot Bean源。通常我们使用SpringApplication或者SpringApplicationBuilder的构造器来直接指定源。\n所谓的Spring Boot Bean源指的是某个被@SpringBootApplication注解标注的类，比如入口类：\n\n我们也可以将上面的代码改为下面这种方式：\npublic class DemoApplication &#123;    public static void main(String[] args) &#123;        SpringApplication application &#x3D; new SpringApplication(ApplicationResource.class);        application.run(args);    &#125;    @SpringBootApplication    public static class ApplicationResource &#123;    &#125;&#125;\n\n\n这样也是可行的。查看SpringApplication的单个参数构造器：\n\n说明我们除了配置单个源外，还可以配置多个源。\n推断应用类型构造器中这行this.webApplicationType = WebApplicationType.deduceFromClasspath();代码用于推断当前Spring Boot应用类型。\nSpring Boot 2.0后，应用可以分为下面三种类型：\n\nWebApplicationType.NONE：非WEB类型；\nWebApplicationType.REACTIVE：Web Reactive类型；\nWebApplicationType.SERVLET：Web Servlet类型。\n\nWebApplicationType.deduceFromClasspath()或根据当前应用ClassPath中是否存在相关的实现类来判断应用类型到底是哪个，deduceFromClasspath方法的源码如下所示:\n\n我们也可以直接通过SpringApplication的setWebApplicationType方法或者SpringApplicationBuilder的web方法来指定当前应用的类型。\n加载应用上下文初始器接着下一行代码setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));用于加载应用上下文初始器ApplicationContextInitializer。\ngetSpringFactoriesInstances方法的源码如下所示：\n\n上面代码利用Spring工厂加载机制，实例化ApplicationContextInitializer实现类，并进行排序。\n所以我们可以通过实现ApplicationContextInitializer接口用于在Spring Boot应用初始化之前执行一些自定义操作。\n举个例子，在com.example.demo下新建initializer包，然后创建一个HelloApplicationContextInitializer类，实现ApplicationContextInitializer接口：\n@Order(Ordered.HIGHEST_PRECEDENCE)public class HelloApplicationContextInitializer implements ApplicationContextInitializer &#123;    @Override    public void initialize(ConfigurableApplicationContext applicationContext) &#123;        System.out.println(&quot;ConfigurableApplicationContext.id - &quot; + applicationContext.getId());    &#125;&#125;\n\n\n上面代码中实现了initialize方法，并且使用@Order注解指定优先级。其中Ordered.HIGHEST_PRECEDENCE等于Integer.MIN_VALUE，Ordered.LOWEST_PRECEDENCE等于Integer.MAX_VALUE。所以数值越小，优先级越高。\n除了使用@Order注解来指定优先级外，我们也可以通过实现org.springframework.core.Ordered接口的getOrder方法来指定优先级。\n接着我们来创建一个优先级比HelloApplicationContextInitializer低的Initializer —— AfterHelloApplicationContextInitializer：\npublic class AfterHelloApplicationContextInitializer implements ApplicationContextInitializer, Ordered &#123;    @Override    public void initialize(ConfigurableApplicationContext applicationContext) &#123;        System.out.println(&quot;AfterHelloApplicationContextInitializer: &quot; + applicationContext.getId());    &#125;    @Override    public int getOrder() &#123;        return Ordered.LOWEST_PRECEDENCE;    &#125;&#125;\n\n\n上面通过getOrder方法来指定了优先级为最低优先级。\n创建好后，我们还需在工厂配置文件里配置这两个实现类。在resources目录下新建META-INF目录，并创建spring.factories文件：\n# Initializersorg.springframework.context.ApplicationContextInitializer=\\com.example.demo.initializer.HelloApplicationContextInitializer,\\com.example.demo.initializer.AfterHelloApplicationContextInitializer\n\n\n这时候，启动Spring Boot项目，会发现控制台在打印Banner后就执行了这两个初始化器，并且HelloApplicationContextInitializer的initialize方法执行时机先于AfterHelloApplicationContextInitializer的initialize方法：\n\n加载应用事件监听器在加载完应用上下文初始器后，下一行的setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));代码加载了应用事件监听器。与加载事件上下文初始器类似，Spring Boot也是通过Spring的工厂方法来实例化ApplicationListener的实现类，并进行排序。\n既然是事件监听，那么其可以监听什么事件呢？其监听的是ApplicationEvent接口的实现类，我们查看一下都有哪些事件实现了这个接口：\n\n这里我们以ContextClosedEvent为例子来编写自定义的应用事件监听器，监听Spring上下文关闭事件。\n在com.example.demo下新建listener包，然后创建一个ContextClosedEventListener类，实现ApplicationListener接口：\n@Order(Ordered.HIGHEST_PRECEDENCE)public class ContextClosedEventListener implements ApplicationListener&lt;ContextClosedEvent&gt; &#123;    @Override    public void onApplicationEvent(ContextClosedEvent event) &#123;        System.out.println(&quot;ContextClosedEvent: &quot; + event.getApplicationContext().getId());    &#125;&#125;\n\n\n上面代码实现了对ContextClosedEvent事件的监听，并且分配了最高优先级。\n接着创建一个优先级比ContextClosedEventListener低的上面代码实现了对ContextClosedEvent事件监听器AfterContextClosedEventListener：\npublic class AfterContextClosedEventListener implements ApplicationListener&lt;ContextClosedEvent&gt;, Ordered &#123;    @Override    public void onApplicationEvent(ContextClosedEvent event) &#123;        System.out.println(&quot;AfterContextClosedEventr: &quot; + event.getApplicationContext().getId());    &#125;    @Override    public int getOrder() &#123;        return Ordered.HIGHEST_PRECEDENCE + 1;    &#125;&#125;\n\n\n最后，别忘了在Spring工厂配置文件里进行配置：\n# Application Listenersorg.springframework.context.ApplicationListener=\\com.example.demo.listener.ContextClosedEventListener,\\com.example.demo.listener.AfterContextClosedEventListener\n\n\n在Spring Boot入口类中将环境指定为非WEB环境（这样在启动后应用会马上关闭）:\nnew SpringApplicationBuilder(DemoApplication.class)                .web(WebApplicationType.NONE)                .run(args);\n\n\n运行Spring Boot入口类，控制台输出如下：\n推断入口类接着构造器里的代码下一行this.mainApplicationClass = deduceMainApplicationClass();用于推断运行Spring Boot应用的入口类。查看deduceMainApplicationClass方法源码：\n\n代码主要逻辑是根据Main线程执行堆栈判断实际的入口类。\n准备阶段介绍完毕后，接下来开始介绍运行阶段。\nSpringApplication运行阶段SpringApplication的运行阶段对应SpringApplication的run方法，我们查看其源码：\npublic ConfigurableApplicationContext run(String... args) &#123;    StopWatch stopWatch = new StopWatch();    stopWatch.start();    ConfigurableApplicationContext context = null;    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();    configureHeadlessProperty();    SpringApplicationRunListeners listeners = getRunListeners(args);    listeners.starting();    try &#123;        ApplicationArguments applicationArguments = new DefaultApplicationArguments(                args);        ConfigurableEnvironment environment = prepareEnvironment(listeners,                applicationArguments);        configureIgnoreBeanInfo(environment);        Banner printedBanner = printBanner(environment);        context = createApplicationContext();        exceptionReporters = getSpringFactoriesInstances(                SpringBootExceptionReporter.class,                new Class[]&#123;ConfigurableApplicationContext.class&#125;, context);        prepareContext(context, environment, listeners, applicationArguments,                printedBanner);        refreshContext(context);        afterRefresh(context, applicationArguments);        stopWatch.stop();        if (this.logStartupInfo) &#123;            new StartupInfoLogger(this.mainApplicationClass)                    .logStarted(getApplicationLog(), stopWatch);        &#125;        listeners.started(context);        callRunners(context, applicationArguments);    &#125; catch (Throwable ex) &#123;        handleRunFailure(context, ex, exceptionReporters, listeners);        throw new IllegalStateException(ex);    &#125;    try &#123;        listeners.running(context);    &#125; catch (Throwable ex) &#123;        handleRunFailure(context, ex, exceptionReporters, null);        throw new IllegalStateException(ex);    &#125;    return context;&#125;\n\n\n运行阶段大致可以分为下面这几个过程：\n开启时间监听run方法开头的这两行代码用于开启时间监听：\nStopWatch stopWatch = new StopWatch();stopWatch.start();\n\n\n上面代码用于开启Spring Boot应用启动时间监听，配合下面的stopWatch.stop();便可以计算出完整的启动时间。\n开启运行监听器run方法的这几行代码用于加载Spring应用运行监听器（SpringApplicationRunListener）：\nSpringApplicationRunListeners listeners = getRunListeners(args);listeners.started();\n\n\ngetRunListeners方法源码：\nprivate SpringApplicationRunListeners getRunListeners(String[] args) &#123;    Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;    return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(        SpringApplicationRunListener.class, types, this, args));&#125;\n\n\n上面代码通过SpringFactoriesLoader检索META-INF/spring.factories找到声明的所有SpringApplicationRunListener的实现类并将其实例化，然后装配到List运行监听器集合中。\nlisteners.started();用于遍历运行监听器集合中的所有SpringApplicationRunListener的实现类，并逐一调用它们的starting方法，广播Spring Boot应用要开始启动了。\n在Spring Boot中SpringApplicationRunListener接口用于监听整个Spring Boot应用生命周期，其代码如下所示：\npublic interface SpringApplicationRunListener &#123;    void starting();    void environmentPrepared(ConfigurableEnvironment environment);    void contextPrepared(ConfigurableApplicationContext context);    void contextLoaded(ConfigurableApplicationContext context);    void started(ConfigurableApplicationContext context);    void running(ConfigurableApplicationContext context);    void failed(ConfigurableApplicationContext context, Throwable exception);&#125;\n\n\n这些方法对应着Spring Boot应用生命周期的各个阶段：\n\n\n\n方法名称\n对应生命周期\nSpring Boot起始版本\n\n\n\nstarting()\nSpring 应用刚启动\n1.0\n\n\nenvironmentPrepared(ConfigurableEnvironment)\nConfigurableEnvironment 准备完毕，允许将其调整\n1.0\n\n\ncontextPrepared(ConfigurableApplicationContext)\nConfigurableApplicationContext 准备完毕，允许将其调整\n1.0\n\n\ncontextLoaded(ConfigurableApplicationContext)\nConfigurableApplicationContext 已装载，但仍未启动\n1.0\n\n\nstarted(ConfigurableApplicationContext)\nConfigurableApplicationContext 已启动，此时 Spring Bean 已初始化完成\n2.0\n\n\nrunning(ConfigurableApplicationContext)\nSpring 应用正在运行\n2.0\n\n\nfailed(ConfigurableApplicationContext,Throwable)\nSpring 应用运行失败\n2.0\n\n\n我们在com.example.demo.linstener下自定义一个SpringApplicationRunListener接口实现类HelloSpringApplicationRunListener：\npublic class HelloApplicationRunListener implements SpringApplicationRunListener &#123;    public HelloApplicationRunListener(SpringApplication application, String[] args) &#123;    &#125;    @Override    public void starting() &#123;        System.out.println(&quot;HelloApplicationRunListener starting......&quot;);    &#125;    @Override    public void environmentPrepared(ConfigurableEnvironment environment) &#123;    &#125;    @Override    public void contextPrepared(ConfigurableApplicationContext context) &#123;    &#125;    @Override    public void contextLoaded(ConfigurableApplicationContext context) &#123;    &#125;    @Override    public void started(ConfigurableApplicationContext context) &#123;    &#125;    @Override    public void running(ConfigurableApplicationContext context) &#123;    &#125;    @Override    public void failed(ConfigurableApplicationContext context, Throwable exception) &#123;    &#125;&#125;\n\n\n通过这个实现类，我们可以在Spring Boot应用刚启动的时候在控制台输出HelloApplicationRunListener starting......。\n因为其基于Spring的工厂方法来实现，所以我们需要在spring.factories文件里配置这个实现类:\n# Run Listenersorg.springframework.boot.SpringApplicationRunListener=\\com.example.demo.run.HelloApplicationRunListener\n\n\n启动Spring Boot应用便可以在控制台看到如下输出了：\n\n创建 Environmentrun方法中的这行代码用于创建并配置当前SpringBoot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）：\nConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);\n\n\n我们已经在准备阶段里推断出了应用类型，这里只要根据相应的应用类型来创建相应的应用环境即可，类型和环境对应关系如下：\n\nWeb Reactive： StandardReactiveWebEnvironment\nWeb Servlet： StandardServletEnvironment\n非 Web： StandardEnvironment\n\n在prepareEnvironment方法中会执行listeners.environmentPrepared(environment);，用于遍历调用所有SpringApplicationRunListener实现类的environmentPrepared()方法，广播Environment准备完毕。\n是否打印Bannerrun方法中的这行代码会根据我们的配置来决定是否打印Banner：\nBanner printedBanner = printBanner(environment);\n\n\n创建Contextrun方法中的这行代码用于创建ApplicationContext：\ncontext = createApplicationContext();\n\n\n不同的环境对应不同的ApplicationContext：\n\nWeb Reactive： AnnotationConfigReactiveWebServerApplicationContext\nWeb Servlet： AnnotationConfigServletWebServerApplicationContext\n非 Web： AnnotationConfigApplicationContext\n\n装配Contextrun方法中的这行代码用于装配Context：\nprepareContext(context, environment, listeners, applicationArguments, printedBanner);\n\n\n方法prepareContext的源码如下所示:\nprivate void prepareContext(ConfigurableApplicationContext context,                            ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,                            ApplicationArguments applicationArguments, Banner printedBanner) &#123;    context.setEnvironment(environment);    postProcessApplicationContext(context);    applyInitializers(context);    listeners.contextPrepared(context);    if (this.logStartupInfo) &#123;        logStartupInfo(context.getParent() == null);        logStartupProfileInfo(context);    &#125;    // Add boot specific singleton beans    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();    beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);    if (printedBanner != null) &#123;        beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);    &#125;    if (beanFactory instanceof DefaultListableBeanFactory) &#123;        ((DefaultListableBeanFactory) beanFactory)                .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);    &#125;    // Load the sources    Set&lt;Object&gt; sources = getAllSources();    Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);    load(context, sources.toArray(new Object[0]));    listeners.contextLoaded(context);&#125;\n\n\nprepareContext方法开头为ApplicationContext加载了environment，之后通过applyInitializers方法逐个执行ApplicationContextInitializer的initialize方法来进一步封装ApplicationContext，并调用所有的SpringApplicationRunListener实现类的contextPrepared方法，广播ApplicationContext已经准备完毕了。\n之后初始化IOC容器，并调用SpringApplicationRunListener实现类的contextLoaded方法，广播ApplicationContext加载完成，这里就包括通过@EnableAutoConfiguration导入的各种自动配置类。\nRefresh Contextrun方法中的这行代码用于初始化所有自动配置类，并调用ApplicationContext的refresh方法：\nrefreshContext(context);\n\n\n广播应用已启动run方法中的这行代码用于广播Spring Boot应用已启动：\nlisteners.started(context);\n\n\nstarted方法会调用所有的SpringApplicationRunListener的finished方法，广播SpringBoot应用已经成功启动。\n执行Runnerrun方法中的这行代码callRunners(context, applicationArguments);遍历所有ApplicationRunner和CommandLineRunner的实现类，并执行其run方法。我们可以实现自己的ApplicationRunner或者CommandLineRunner，来对Spring Boot的启动过程进行扩展。\n我们在com.example.demo下新建runner包，然后创建一个ApplicationRunner的实现类HelloApplicationRunner：\n@Componentpublic class HelloApplicationRunner implements ApplicationRunner &#123;    @Override    public void run(ApplicationArguments args) &#123;        System.out.println(&quot;HelloApplicationRunner: hello spring boot&quot;);    &#125;&#125;\n\n\n这里我们需要将HelloApplicationRunner使用@Component注解标注，让其注册到IOC容器中。\n然后再创建一个CommandLineRunner的实现类HelloCommandLineRunner：\n@Componentpublic class HelloCommandLineRunner implements CommandLineRunner &#123;    @Override    public void run(String... args) &#123;        System.out.println(&quot;HelloCommandLineRunner: hello spring boot&quot;);    &#125;&#125;\n\n\n启动Spring Boot应用，便可以在应用刚启动好后看到如下输出：\n\n广播应用运行中run方法中的这行代码listeners.running(context);用于调用SpringApplicationRunListener的running方法，广播Spring Boot应用正在运行中。\n当run方法运行出现异常时，便会调用handleRunFailure方法来处理异常，该方法里会通过listeners.failed(context, exception);来调用SpringApplicationRunListener的failed方法，广播应用启动失败，并将异常扩散出去。\n上面所有的广播事件都是使用Spring的应用事件广播器接口ApplicationEventMulticaster的实现类SimpleApplicationEventMulticaster来进行广播的。\n\n源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/45.Spring-Boot-SpringApplication\nFROM:https://mrbird.cc/deepin-springboot-application.html\n\n","categories":["springboot"],"tags":["springboot","springApplication","入口类"]},{"title":"数据库系统原理","url":"https://www.mele.cool/2020/12/04/数据库系统原理/","content":"一、事务概念事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。\n\nACID1. 原子性（Atomicity）事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。\n回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。\n2. 一致性（Consistency）数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。\n3. 隔离性（Isolation）一个事务所做的修改在最终提交以前，对其它事务是不可见的。\n4. 持久性（Durability）一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。\n系统发生奔溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。\n\n事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：\n\n只有满足一致性，事务的执行结果才是正确的。\n在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。\n在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。\n事务满足持久化是为了能应对系统崩溃的情况。\n\nAUTOCOMMITMySQL 默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。\n二、并发一致性问题在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。\n丢失修改丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。\n读脏数据读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。\n不可重复读不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。\n幻影读幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。\n\n产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。\n三、封锁封锁粒度MySQL 中提供了两种封锁粒度：行级锁以及表级锁。\n应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。\n但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。\n在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。\n封锁类型1. 读写锁\n互斥锁（Exclusive），简写为 X 锁，又称写锁。\n共享锁（Shared），简写为 S 锁，又称读锁。\n\n有以下两个规定：\n\n一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。\n一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。\n\n锁的兼容关系如下：\n![image-20200708162307968](/Users/boguotong/Library/Application Support/typora-user-images/image-20200708162307968.png)\n2. 意向锁使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。\n在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。\n意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：\n\n一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；\n一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。\n\n通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。\n各种锁的兼容关系如下：\n\n解释如下：\n\n任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；\n这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）\n\n封锁协议1. 三级封锁协议一级封锁协议\n事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。\n可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。\n二级封锁协议\n在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。\n可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。\n三级封锁协议\n在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。\n可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。\n2. 两段锁协议加锁和解锁分为两个阶段进行。\n可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。\n事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。\nlock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)\n但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。\nlock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)\nMySQL 隐式与显示锁定MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。\nInnoDB 也可以使用特定的语句进行显示锁定：\nSELECT ... LOCK In SHARE MODE;SELECT ... FOR UPDATE;\n四、隔离级别未提交读（READ UNCOMMITTED）事务中的修改，即使没有提交，对其它事务也是可见的。\n提交读（READ COMMITTED）一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。\n可重复读（REPEATABLE READ）保证在同一个事务中多次读取同一数据的结果是一样的。\n可串行化（SERIALIZABLE）强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。\n该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。\n\n\n五、多版本并发控制多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。\n基本思想在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。\n在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。\n脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。\n版本号\n系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。\n事务版本号 TRX_ID ：事务开始时的系统版本号。\n\nUndo 日志MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。\n例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。\nINSERT INTO t(id, x) VALUES(1, &quot;a&quot;);UPDATE t SET x&#x3D;&quot;b&quot; WHERE id&#x3D;1;UPDATE t SET x&#x3D;&quot;c&quot; WHERE id&#x3D;1;\n因为没有使用 START TRANSACTION 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。\nINSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。\nReadViewMVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, …}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。\n在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：\n\nTRX_ID &lt; TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。\nTRX_ID &gt; TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。\nTRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，需要根据隔离级别再进行判断：\n提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。\n可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。\n\n\n\n在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。\n快照读与当前读1. 快照读MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。\nSELECT * FROM table ...;\n2. 当前读MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。\nINSERT;UPDATE;DELETE;\n在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。\nSELECT * FROM table WHERE ? lock in share mode;SELECT * FROM table WHERE ? for update;\n六、Next-Key LocksNext-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。\nMVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。\nRecord Locks锁定一个记录上的索引，而不是记录本身。\n如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。\nGap Locks锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。\nSELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;\nNext-Key Locks它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：\n(-∞, 10](10, 11](11, 13](13, 20](20, +∞)\n七、关系数据库设计理论函数依赖记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。\n如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。\n对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。\n对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。\n异常以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。\n\n\n\nSno\nSname\nSdept\nMname\nCname\nGrade\n\n\n\n1\n学生-1\n学院-1\n院长-1\n课程-1\n90\n\n\n2\n学生-2\n学院-2\n院长-2\n课程-2\n80\n\n\n2\n学生-2\n学院-2\n院长-2\n课程-1\n100\n\n\n3\n学生-3\n学院-2\n院长-2\n课程-2\n95\n\n\n不符合范式的关系，会产生很多异常，主要有以下四种异常：\n\n冗余数据：例如 学生-2 出现了两次。\n修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。\n删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 课程-1 需要删除第一行和第三行，那么 学生-1 的信息就会丢失。\n插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。\n\n范式范式理论是为了解决以上提到四种异常。\n高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。\n1. 第一范式 (1NF)属性不可分。\n2. 第二范式 (2NF)每个非主属性完全函数依赖于键码。\n可以通过分解来满足。\n分解前\n\n\n\nSno\nSname\nSdept\nMname\nCname\nGrade\n\n\n\n1\n学生-1\n学院-1\n院长-1\n课程-1\n90\n\n\n2\n学生-2\n学院-2\n院长-2\n课程-2\n80\n\n\n2\n学生-2\n学院-2\n院长-2\n课程-1\n100\n\n\n3\n学生-3\n学院-2\n院长-2\n课程-2\n95\n\n\n以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：\n\nSno -&gt; Sname, Sdept\nSdept -&gt; Mname\nSno, Cname-&gt; Grade\n\nGrade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。\nSname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。\n分解后\n关系-1\n\n\n\nSno\nSname\nSdept\nMname\n\n\n\n1\n学生-1\n学院-1\n院长-1\n\n\n2\n学生-2\n学院-2\n院长-2\n\n\n3\n学生-3\n学院-2\n院长-2\n\n\n有以下函数依赖：\n\nSno -&gt; Sname, Sdept\nSdept -&gt; Mname\n\n关系-2\n\n\n\nSno\nCname\nGrade\n\n\n\n1\n课程-1\n90\n\n\n2\n课程-2\n80\n\n\n2\n课程-1\n100\n\n\n3\n课程-2\n95\n\n\n有以下函数依赖：\n\nSno, Cname -&gt; Grade\n\n3. 第三范式 (3NF)非主属性不传递函数依赖于键码。\n上面的 关系-1 中存在以下传递函数依赖：\n\nSno -&gt; Sdept -&gt; Mname\n\n可以进行以下分解：\n关系-11\n\n\n\nSno\nSname\nSdept\n\n\n\n1\n学生-1\n学院-1\n\n\n2\n学生-2\n学院-2\n\n\n3\n学生-3\n学院-2\n\n\n关系-12\n\n\n\nSdept\nMname\n\n\n\n学院-1\n院长-1\n\n\n学院-2\n院长-2\n\n\n八、ER 图Entity-Relationship，有三个组成部分：实体、属性、联系。\n用来进行关系型数据库系统的概念设计。\n实体的三种联系包含一对一，一对多，多对多三种。\n\n如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；\n如果是一对一，画两个带箭头的线段；\n如果是多对多，画两个不带箭头的线段。\n\n下图的 Course 和 Student 是一对多的关系。\n\n表示出现多次的关系一个实体在联系出现几次，就要用几条线连接。\n下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。\n\n联系的多向性虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。\n\n表示子类用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。\n\n转自:https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md\n\n","categories":["db"],"tags":["事务","acid","原理"]},{"title":"springboot项目打包成war包","url":"https://www.mele.cool/2020/12/02/SpringBoot项目打包成war包/","content":"1.修改pom.xml文件将打包方式改为war：&lt;packaging&gt;war&lt;/packaging&gt;\n然后添加如下的Tomcat依赖配置，覆盖Spring Boot自带的Tomcat依赖：&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;\n在&lt;build&gt;&lt;/build&gt;标签内配置项目名（该配置类似于server.context-path=mrbird）：...&lt;build&gt;    ...    &lt;finalName&gt;mrbird&lt;/finalName&gt;&lt;/build&gt;...\n添加启动类ServletInitializer：import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.boot.web.support.SpringBootServletInitializer;public class ServletInitializer extends SpringBootServletInitializer &#123;    @Override    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;        return application.sources(Application.class);    &#125;&#125;\n其中Application为Spring Boot的启动类。\n##2.准备完毕后，运行mvn clean package命令即可在target目录下生产war包：\n\nFROM:MiBird\n","categories":["springboot"],"tags":["springboot","war"]},{"title":"docker","url":"https://www.mele.cool/2020/12/02/docker/","content":"1.镜像相关命令#查看镜像docker images#搜索镜像docker search centos7# 拉取镜像docker pull centos:7#删除镜像docker rmi 镜像ID#删除本地全部镜像 慎用docker rmi `docker images -q`\n2.容器相关命令2.1 创建并启动交互式容器\n docker交互式容器:(启动容器之后会直接进入容器的命令行终端,如果退出则容器停止运行）\n\n# 查看正在运行的容器docker ps# 查看全部容器docker ps -a#创建并启动容器docker run#创建并启动交互式容器 退出:exit,退出则容器停止运行docker run -it --name=mycentos7 centos:7 /bin/bash\n\n2.2 创建并启动守护式容器\n创建启动docker容器,可以在后台运行;\n\n#创建并启动守护式容器docker run -di --name=mycentos2 centos:7#登陆进入已启动的容器 退出:exit,退出后容器仍在运行docker exec -it mycentos2 /bin/bash\n2.3 容器常用命令\n容器的停止 启动 、拷贝文件\n\n#停止docker stop 容器名称#启动docker start 容器名称#复制宿主机文件到docker 在docker中运行命令docker cp abc.txt mycentos2:/#复制docker文件到宿主机 在宿主机中运行命令docker cp mycentos2:/abc.txt /root\n\n目录挂载:可以在创建容器的时候,将宿主机的目录与容器内的目录进行映射,这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。创建容器时添加-v参数,后边为宿主机目录:容器目录,例如: \n\ndocker run -di -v /usr/local/test:/usr/local/test --name=mycentos3 centos:7#在linux宿主机下查看mycentos3的ipdocker inspect mycentos3#删除容器(非运行状态)docker rm mycentos7#删除全部容器(包括运行的与非运行的)docker rm `docker ps -a -q\\`\n2.4 mysql容器部署\n\n拉取mysql镜像;\n创建并启动守护式容器；\n在容器中操作mysql;\n使用图形界面工具(windows )操作在docker中安装的mysql ;在创建mysql容器的时候使用-p指定端口映射实现连接.在创建容器的时候mysql的root用户可以指定远程访问的密码。\n\n\n #拉取 docker search mysql docker pull centos/mysql-57-centos7 #创建并启动守护式容器,指定端口映射  docker run -di --name=mysql5.7 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root centos/mysql-57-centos7 #进入容器 docker exec -it mysql5.7 /bin/bash mysql -u root -p #此处密码是空,直接enter登陆 #远程连接操作: 宿主机ip:3306  因为已经指定端口映射了 #授权GRANT ALL PRIVILEGES ON *.* TO root@&quot;%&quot; IDENTIFIED BY &quot;密码&quot;;flush privileges;#进入mysql，然后编辑/etc/mysql/mysql.conf.d/mysqld.cnf,然后重启docker#参考:https://zhuanlan.zhihu.com/p/46207256bind-address 0.0.0.0#解决mysql容器中没有vim命令#进入运行中的mysql容器，执行如下语句：docker exec -it dd75f390a5df /bin/bash,其中dd75f390a5df是容器IDapt-get install vim#若出现报错的输出语句，就执行：apt-get update,然后重新执行apt-get install vim\n\n总结:在创建容器的时候指定环境变量MYSQL-ROOT-PASSWORD表示使用root进行远程连接时候的密码。如果需要进行远程连接的话可以使用-p进行端口映射。\n\n2.5 tomcat容器部署\n将项目文件上传到容器中的tomcat目录(webapps)\n创建容器的时候可以指定-进行目录挂载, tomcat在容器中的目录(/usr/local/tomcat/webapps )\n\n可以通过外部浏览器访问容器中的项目\n创建容器的时候可以指定-p进行端口映射\n\n\n1,拉取tomcat镜像; docker pu11 tomcat\n2.创建并启动tomcat容器\ndocker run -di --name=mytomcat -p 9000:8080 -v /usr/1ocal/tomcat/webapps:/usr/local/tomcat/webapps tomcat#如果出现WARNING: IPv4 forwarding is disabled. Networking wil1 not work.#执行如下操作#1、编辑sysct1.confvi /etc/sysctl.conf#2、在上述打开的文件中后面添加net.ipv4.ip_forward=1#3、重启networksystemctl restart network\n3,访问容器中tomcat    http://192.168.76.128:9000 显示404说明部署成功\n2.6 Nginx容器部署\nnginx默认端口是80\n\n#拉取nginxdocker pull nginx#创建并启动nginxdocker run -di --name=mynginx -p 80:80 nginx\n测试,\n2.7 redis容器部署\n默认端口:6379\n\n#拉取docker pull redis#创建并启动容器docker run -di --name=myredis -p 6379:6379 redis# 进入容器docker exec -it myredis /bin/bash# 进入命令目录,启动rediscd /usr/local/bin./redis-cli#在redis中输入ping,返回pong说明启动成功\n测试:使用redis图形化工具 Redis Desktop Manager连接redis容器:\n\n3.Docker Compose\nCompose项目是Docker官方的开源项目,负责实现对Docker容器集群的快速编排。它是一个定义和运行多容器的docker应用工具。使用compose,你能通过YMAL文件配置你自己的服务,然后通过一个命令,你能使用配置文件创建和运行所有的服务。\ndocker-compose是一个应用工具;可以通过配置docker-compose.yml文件同时启动多个容器。\n\n组成:Docker-Compose将所管理的容器分为三层,分别是工程(project) ,服务(service)以及容器(container) .Docker-Compose运行目录下的所有文件(docker-compose.yml, extends文件或环境变量文件等)组成一个工程,若无特殊指定工程名即为当前目录名。一个工程当中可包含多个服务,每个服务钟定义了容器运行的镜像,参数,依赖。一个服务当中可包括多个容器实例。\nDocker-Compose的工程配置文件默认为docker-compose.yml,可通过环境变量COMPOSE-FILE或-参数自定义配置文件,其定义了多个有依赖关系的服务及每个服务运行的容器。\n使用一个Dockerfile模板文件,可以让用户很方便的定义一个单独的应用容器。在工作中,经常会碰到需要多个容器相互配合来完成某项任务的情况。例如:要部署一个Web项目,除了Web服务容器,往往还需要再加上后端的数据库服务容器,甚至还包括负载均衡容器等。\n安装与卸载:Compose目前已经完全支持Linux, Mac OS和Windows,在我们安装Compose之前,需要先安装Docker,下面我们以编译好的二进制包方式安装在Linux系统中。\n#安装curl -L &quot;https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/1ocal/bin/docker-compose#设置文件可执行权限chmod +x /usr/local/bin/docker-compose#查看版本信息docker-compose -version#卸载rm -rf /usr/local/bin/docker-compose \n应用:\n模板文件是使用Compose的核心,涉及的指令关键字也比较多,大部分指令与docker run相关参数的含义都是类似的。默认的模板文件名称为docker-compose.yml,格式为YAML格式。\n\nCompose命令的基本的使用格式为:\ndocker-compose [-f 參数..] [options] [COMMAND] [ARGS...]-f, -file FILE指定使用的compose模板文件,默认为docker-compose.yml,可以多次指定。-p,-project-name NAME指定项目名称,默认将使用所在目录名称作为项目名。-x-network-driver 使用Docker的可拔插网络后端特性(需要Docker 1.9及以后版本)-x-network-driver DRIVER指定网络后端的驱动,默认为bridge (需要Docker 1.9及以后版本)-verbose输出更多调试信息-v,-version打印版本并退出\n使用Compose前,可以通过执行docker-compose –help|-h来查看Compose基本命令用法。也可以通过执行docker-compose [COMMAND] –help或者docker-compose –help [COMMAND]来查看某个具体的使用格式。\n常用命令:up\nps\n\n格式:docker-compose ps [options] [SERVICE …]作用:列出项目中目前的所有容器。选项包括：    -q 只打印容器的ID信息\n\nstop\n\n格式为:docker-compose stop [options] [SERVICE…]\n作用:停止已经处于运行状态的容器,但不删除它\n选项包括:\n​    -t, –timeout TIMEOUT 停止容器时候的超时(默认为10秒)\n\ndown\n\nrestart\nrm \n\nstart\n\nrun\nconfig\nkill\ncreate\nexec\n\nCompose模板文件:\nDocker Compose常用模板文件主要命令:\n![image-20201022214437985](/Users/boguotong/Library/Application Support/typora-user-images/image-20201022214437985.png)\ncompose应用:\n需求:编写compose模版文件,实现同时启动tomcat, mysql和redis容器。\n分析: do cker-compose可以实现一次启动多个容器;通过配置docker-compose模板文件( docker-compose.yml ),在这个配置文件中去配置各个容器及其相关的依赖。1,编写模板文件;2.创建并启动docker-compose项目(模板文件所在的目录, docker-compose.yml )3.测试\n\n1.编写模板文件#创建文件夹mkdir -p /usr/local/mycompose#进入文件夹cd /usr/local/mycompose#创建docker-compose.yml文件;内容如下vi docker-compose.yml\n\n \n2.启动docker-compose 编写完配置文件,由于之前启动了容器,为了避免重复启动,可以重启docker之后再启动docker-compose\n#重启dockersystemctl restart dockerpwd/usr/local/mycompose#后台启动docker-composedocker-compose up -d#启动完成后查看正在运行的容器,发现web1 mysql1 redis1都成功运行了docker ps#如果要停止 down会删除容器和网络 stop不会docker-compose down #查看都有哪些网络 可以发现docker network ls\n打开浏览器,测试访问已启动的那些容器.\n4.迁移和备份\n 目标:**能够将容器保存为镜像,备份,恢复镜像再启动以恢复的镜像作为基础的容器**分析：在当前的容器中安装了各种组件;期望在其他服务器上也能快速拥有该容器的一切环境;可以将当前的容器制作为一个镜像,再将该镜像复制到其他服务器,其他服务器再基于镜像运行容器。\n\n\n其中涉及到的命令有:\n\ndocker commit将容器保存为镜像\ndocker save将镜像备份为tar文件\ndocker load根据tar文件恢复为镜像\n\n步骤:\n#把容器名为mynginx的容器打包成一个镜像,命名镜像名为mynginx docker commit mynginx mynginx#把myninx镜像保存为mynginx.tar文件,保存到本地路径.保存完可以ll查看tar文件docker save -o mynginx.tar mynginx#tar包复制到另一个服务器后进行恢复,后可以docker images查看此镜像,然后根据镜像运行容器docker load -i mynginx.tar#启动docker run -di --name=mynginx -p 80:80 mynginx\n5.使用Dockerfile创建镜像\n已经知道了,要获得镜像,可以从Docker仓库中进行下载。那如果我们想自己开发一个镜像,那该如何做呢?答案是:DockerfileDockerfile其实就是一个文本文件,由一系列命令和参数构成, Docker可以读取Dockerfile文件并根据Dockerfile文件的描述来构建镜像。\nDockerfile文件内容一般分为4部分:\n\n基础镜像信息\n维护者信息\n镜像操作指令\n容器启动时执行的指令\n\n\nDockerfile常用命令:\n\n**DEMO:**在centos7作为基础镜像上;添加idk1.8并构建一个包含idk1.8的centos7新镜像。\n实现步骤：\n\n拉取centos7镜像;\n\n上传jdk1.8;\n\n编写Dockerfile文件;\n\n构建镜像;\n\n5测试(基于新镜像创建并运行容器,运行java-version)\n\n\ndocker pull centos7#创建jdk放置目录,并把jdk8文件上传进去,在此目录下执行以下命令mkdir -p /usr/local/dockerjdk8#创建Dockerfile文件vi Dockerfile#Dockerfile内容beginFROM centos:7MAINTAINER mynameWORKDIR /usrRUN mkdir /usr/local/javaADD jdk-8u202-1inux-x64.tar.gz /usr/local/java/ENV JAVA-HOME /usr/local/java/jdk1.8.0_202ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA-HOME/1ib/dt.jar:$JAVA-HOME/1ib/tools.jar:$JRE_HOME/1ib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH#Dockerfile内容end#构建镜像.注意最后一个点,表示在当前目录下构建镜像,镜像名为jdk1.8docker build -t=&#x27;jdk1.8&#x27; .#查看镜像是否建立完成docker images#创建并启动容器 启动后会默认进入文件中设置的工作目录/usrdocker run -it --name=testjdk jdk1.8 /bin/bash#验证java版本是否显示java -verison\n6.私有仓库搭建与配置\nDocker官方的Docker hub (http://hub.docker.com)是一个用于管理公共镜像的仓库,我们可以从上面拉取镜像到本地,也可以把我们自己的镜像推送上去。但是,有时候我们的服务器无法访问互联网,或者你不希望将自己的镜像放到公网当中,那么我们就需要搭建自己的私有仓库来存储和管理自己的镜像。\n\n私有仓库搭建步骤:\n#1、拉取私有仓库镜像docker pull registry#2、启动私有仓库容器docker run -di --name=registry -p 5000:5000 registry#3、打开浏览器输入地址http://宿主机ip: 5000/v2/_catalog,看到&#123;&quot;repositories&quot;:[]&#125;表示私有仓库搭建成功#4、修改daemon.jsonvi /etc/docker/daemon.json#在上述文件中添加一个key,保存退出。此步用于让docker信任私有仓库地址;注意将宿主机ip修改为自己宿主机真实ip&#123;&quot;insecure-registries&quot; : [&quot;宿主机ip: 5000&quot;]&#125;#5、重启docker服务systemctl restart dockerdocker start registry#打开浏览器输入地址http://宿主机ip: 5000/v2/_catalog,看到&#123;&quot;repositories&quot;:[]&#125;表示私有仓库搭建成功\n将镜像上传至私有仓库#1、标记镜像为私有仓库的镜像docker tag jdk1.8 宿主机IP:5000/jdk1.8#2、再次启动私有仓库容器docker restart registry#3、上传标记的镜像docker push 宿主机IP:5000/jdk1.8#4、输入网址查看仓库效果\n从私有仓库拉取镜像#若是在私有仓库所在的服务器上去拉取镜像;那么直接执行如下命令:#因为私有仓库所在的服务器上已经存在相关镜像;所以先删除;请指定镜像名,不是iddocker rmi 服务器ip:5000/jdk1.8#拉取镜像docker pul1 服务器ip:5000/jdk1.8#可以通过如下命令查看docker的信息;了解到私有仓库地址docker info#大多数情况下,都是某台服务器部署了私有镜像仓库之后;到其它服务器上从私有仓库中拉取镜像,若要拉取私有仓库镜像需要去修改docker的配置文件,设置启动时候的仓库地址。#打开配置文件vi /usr/lib/systemd/system/docker.service#在打开的上述文件中按照下面的图,添加如下的内容;注意修改下面内容中的ip地址--add-registry=192.168.12.135:5000 --insecure-registry=192.168.12.135:5000#修改完后需要重新加载docker配置文件并重启dockersystemctl daemon-reload systemctl restart docker#在重启之后;那么则可以去拉取私有仓库中的镜像:#执行拉取镜像命令并查看docker pull jdk1.8 docker images","categories":["docker"],"tags":["docker"]},{"title":"git","url":"https://www.mele.cool/2020/12/02/git/","content":"1.git常用命令1.1.设置用户信息:标识是谁提交的代码\n设置用户名 git config –global user.name “yourname”\n设置邮箱 git config –global user.email “&#x79;&#111;&#117;&#x65;&#109;&#97;&#105;&#108;&#x40;&#113;&#x71;&#46;&#x63;&#111;&#x6d;“\n查看配置信息 git config –list  \n查看用户名  git config user.name\n\n配置信息保存在   ~/.gitconfig 文件中\n1.2 获取git仓库要使用git对代码进行版本控制,首先要获得git仓库,获得方式有两种:\n\n本地初始化一个git仓库\n\n# 在本地仓库文件夹中git init\n\n从远程仓库克隆\n\ngit clone 远程仓库地址\n1.3 工作目录、暂存区以及版本库 概念\n**版本库:**前面看到的.git隐藏文件夹就是版本库,版本库中存储了很多配置信息、日志信息和文件版本信息等\n工作目录(工作区) :包含.git文件夹的目录就是工作目录,主要用于存放开发的代码\n暂存区: .git文件夹中有很多文件,其中有一个index文件就是暂存区,也可以叫做stage.暂存区是一个临时保存修改文件的地方\n\n\n1.4 Git工作目录下文件的两种状态\nuntracked未跟踪(未被纳入版本控制)\ntracked已跟踪(被纳入版本控制)\nUnmodified未修改状态\nModified已修改状态\nStaged已暂存状态\n\n\n\n1.5 提交命令和查看状态# 查看各个文件状态git status# 使输出信息更简洁git status -s# 把文件加入暂存区 git add hell.java# 把文件取消暂存git reset HEAD hell.java# 把暂存区文件提交到本地仓库 (如果文件没加入暂存区则无法提交到本地仓库)# 如果不加-m,则会打开编辑器让填写日志git commit -m &quot;提交日志&quot; # 删除文件(删除本地工作区文件,需要git commit -m &quot;delete file&quot; 提交到远程) # 如果右键删除文件,并没有加到暂存区,还需要通过git add 文件名加到暂存区后再commit同步到git远程 # 推荐git rm方式删除 git rm hell.java \n1.6 将文件添加到忽略列表\n一般我们总会有些文件无需纳入Git的管理,也不希望它们总出现在未跟踪文件列表,通常都是些自动生成的文件,比如日志文件,或者编译过程中创建的临时文件等。在这种情况下,我们可以在工作目录中创建一个名为.gitignore的文件(文件名称固定) ,列出要忽略的文件模式。下面是一个示例:\nwindows下无法直接创建.gitignore文件,需要通过gitbash命令:touch .gitignore创建\n\n\n1.7 查看日志记录# 通过回车分页查看 退出输入qgit log\n1.8 远程仓库\n查看远程仓库如果想查看已经配置的远程仓库服务器,可以运行git remote命令,显示和本地仓库已经关联的远程仓库。它会列出指定的每一个远程服务器的简写。如果已经克隆了远程仓库,那么至少应该能看到origin,这是Git克隆的仓库服务器的默认名字\ngit remote -v 显示更多信息\n\n添加远程仓库\n一个本地仓库可以绑定多个远程仓库\ngit remote add     shortname远程仓库简称\nEg: git remote add origin https://gitee. com/ChuanzhiBoKe/repo1.git\n\n移除远程仓库\n如果因为一些原因想要移除一个远程仓库,可以使用git remote rm 远程仓库简称\n注意:此命令只是从本地移除远程仓库的记录,并不会真正影响到远程仓库\n\n抓取和拉取\n\ngit fetch是从远程仓库获取最新版本到本地仓库,不会自动merge\n\n\n执行完git fetch后会把远程仓库文件以二进制形式存储到.git中,并不会主动合并到工作区,还需要手动合并:\ngit merge origin/master  (origin/master会在git fetch后显示)\n\n\ngit pull是从远程仓库获取最新版本并merge到本地仓库\n\n注意:如果当前本地仓库不是从远程仓库克隆,而是本地创建的仓库,并且仓库中存在文件,此时再从远程仓库拉取文件(git pull origin master)的时候会报错(fatal:refusing to merge unrelated histories ) ,\n解决此问题可以在git pull命令后加入参数**-allow-unrelated-histories**\n然后会让输入日志.保存即可.\n\n\n\n\n推送到远程仓库\n​    git push origin master\n\n只有把文件加入暂存区才可加到本地仓库,如果想一步完成:\ngit commit -a -m “提交日志”\n\n\n\n1.9 git分支\n查看分支:\n\n#列出所有本地分支$ git branch#列出所有远程分支$ git branch -r#列出所有本地分支和远程分支$ git branch -a\n\n创建分支\n\n# 创建分支 (在当前分支基础上创建)git branch 分支名称# 切换分支git checkout 分支名称\n\n推送本地分支至远程分支\n\ngit push origin 本地分支名称\n\n合并分支\n# 在master分支下操作此命令,表示把b1分支合并到mastergit merge b1# 有时候合并操作不会如此顺利。如果你在两个不同的分支中,对同一个文件的同一个部分进行了不同的修改, Git就没办法合并它们,同时会提示文件冲突。此时需要我们打开冲突的文件并修复冲突内容,最后执行git add命令来标识中突已解决# 步骤如下# 1 git merge b1# 2 提示冲突,手动解决冲突# 3 git add# 4 git commit -m &quot;解决冲突日志&quot;\n\n新增文件推送到远程分支\n\ngit push origin 远程分支名称\t\t\n\n删除本地分支\n# 删除本地分支 不会影响远程分支#如果要删除的分支中进行了一些开发动作,此时执行上面的删除命令并不会删除分支,如果坚持要删除此分支,可以将命令中的一d参数改为-Dgit branch -d 本地分支名称\n\n\n\n\n删除远程分支\ngit push origin -d branchName\n1.10 git标签\n\n\n像其他版本控制系统(VCS)一样, Git可以给历史中的某一个提交打上标签,以示重要。比较有代表性的是人们会使用这个功能来标记发布结点(v1.0,v1.2等) 。标签指的是某个分支某个特定时间点的状态。通过标签,可以很方便的切换到标记时的状态。\n\n# 列出所有标签git tag# 创建标签 v0,1是标签名git tag v0.1  # 查看tag信息 比较详细git show 标签名# 推送标签到远程仓库git push origin 标签名#检出标签#新建一个分支，指向某个tag$ git checkout -b [新分支名] [标签名]# 例如:git checkout -b b3 v1.0 表示创建一个b3分支,其代码状态就是v1.0标签时的代码状态#删除本地标签git tag -d 本地标签名#删除远程标签git push origin:refs/tags/远程标签名\n2. TortoiseGitTortoiseGit是一款开源的Git图形界面工具,使用TortoiseGit可以简化Git相关的操作(本质上还是执行的Git相关命令)TortoiseGit下载地址: https://tortoisegit.org/download/\n3.IDEA使用git4.SSH协议配置\n可以使用Git提供的命令行工具Git Bash生成公钥和私钥,具体操作过程如下:\n1、使用命令ssh-keygen-trsa生成公钥和私钥,执行完成后在windows本地用户.ssh目录:  C:\\Users\\用户名\\.ssh 下面生成公钥和私钥2.把公钥内容复制到服务器","categories":["版本控制"],"tags":["git"]},{"title":"mybaby","url":"https://www.mele.cool/2020/12/02/mybaby/","content":"\n安静的美女子\n\n\n\n\n认识下我的朋友们\n\n\n\n\n我是采蘑菇的小村姑\n\n\n\n\n\n困不行了 我先眯会儿\n\n\n\n\n\n换个姿势 继续怡然自得\n\n\n\n\n\n\n\n\n\n","categories":["mele"],"tags":["baby","photo"]},{"title":"redis入门","url":"https://www.mele.cool/2020/12/02/redis入门/","content":"1.redis简介1.1 nosqlNoSQL:即Not-Only SQL (泛指非关系型的数据库) ,作为关系型数据库的补充。作用:应对基于海量用户和海量数据前提下的数据处理问题。\n特征:\n\n可扩容,可伸缩\n大数据量下高性能\n灵活的数据模型\n高可用\n\n\n1.2 redis概念: Redis (REmote DIctionary Server)是用C语言开发的一个开源的高性能键值对(key-value)数据库。\n特征：\n1,数据间没有必然的关联关系\n2,内部采用单线程机制进行工作\n3,高性能。官方提供测试数据, 50个并发执行100000个请求读的速度是110000/,写的速度是81000次/s。\n4,多数据类型支持\n\n​    字符串类型 string\n​    列表类型 list\n​    散列类型 hash\n​    集合类型 set \n​    有序集合类型 sorted set\n\n5,持久化支持。可以进行数据灾难恢复\n默认端口:6379\n2.redis基本操作功能性命令\n# 设置信息set key value# 获取信息 如果不存在返回nilget key\n清除屏幕信息\nclear\n帮助信息查阅\nhelp 命令eg: help set# 查看群组命令help @组名\n退出指令\nquitexit&lt;ESC&gt;\n3.redis数据类型3.1 string3.1.1 简介\n存储的数据:单个数据,最简单的数据存储类型,也是最常用的数据存储类型\n存储数据的格式:一个存储空间保存一个数据\n存储内容:通常使用字符串,如果字符串以整数的形式展示,可以作为数字操作使用\n\n3.1.2 常用命令#添加/修改数据set key value#获取数据get key#删除数据del key#添加/修改多个数据mset keyl valuel key2 value2...#获取多个数据mget keyl key2...#获取数据字符个数(字符串长度)strlen key#追加信息到原始信息后部(如果原始信息存在就追加,否则新建)append key value#设置数值数据增加指定范围的值#增加一个数值incr key#增加一个给定的值 eg:incrby count 20 表示增加20  increment可正可负incrby key increment #增加一个给定的值 专门操作小数inczbyfloat key increment#设置数值数据减少指定范围的值#减少一个数值decr key#减少一个给定的值 increment可正可负decrby key increment\n3.1.3 作为数值操作\nstring作为数值操作\n\nstring在redis内部存储默认就是一个字符串,当遇到增减类操作incr, decr时会转成教值型进行计算。\nredis所有的操作都是原子性的，采用单线程处理所有业务,命令是一个一个执行的,因此无需考虑并发带来的数据影响。\n注意:按数值进行操作的数据,如果原始数据不能转成教值,或超越了redis数值上限范围,将报错。9223372036854775807 (java+long型数据最大值, Long.MAX VALUE)\n\n\n\nTips :\nredis用于控制数据库表主键id,为数据库表主键提供生成策略,保障数据库表的主键唯一性\n此方案适用于所有数据库,且支持数据库集群\n\n3.1.4 设置生命周期设置数据具有指定的生命周期# 秒 eg:setex news_id 10 1 设置news_id有效期10秒内值为1setex key seconds value # 毫秒psetex key milliseconds value\n\n3.2 hash\n\n新的存储需求:对一系列存储的数据进行编组,方便管理,典型应用存储对象信息\n需要的存储结构：一个存储空间保存多个键值对数据\nhash类型:底层使用哈希表结构实现数据存储\n\n\n\n\nhash存储结构优化\n\n如果field数量较少,存储结构优化为类数组结构\n如果field数量较多,存储结构使用HashMap结构\n\n\n3.2.1 基本操作#添加/修改数据hset key field value#获取数据hget key fielyhgetall key#删除数据hdel key fieldl [field2]#添加/修改多个数据hmset key fieldl valuel field2 value2#获取多个数据hmget key fieldl field2...#获取哈希表中字段的数量hlen key#获取哈希表中是否存在指定的字段hexists key field\n3.2.2 扩展操作#获取哈希表中所有的字段名或字段值 列表hkeys keyhvals key#设置指定字段的数值数据增加指定范围的值hincrby key field increment hincrbyfloat key field increment\n3.2.3 hash类型数据操作的注意事项\nhash类型下的value只能存储字符串,不允许存储其他数据类型,不存在嵌套现象。如果数据未获取到,对应的值为(nil)\n每个hash可以存储2^32-1个键值对\nhash类型十分贴近对象的数据存储形式,并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的,切记不可滥用,更不可以将hash作为对象列表使用\nhgetall操作可以获取全部属性,如果内部field过多,遍历整体数据效率就很会低,有可能成为数据访问瓶颈\n\n3.2.4 hash应用场景3.2.4.1 购物车\n解决方案\n\n以客户id作为key,每位客户创建一个hash存储结构存储对应的购物车信息\n将商品编号作为field,购买数量作为value进行存储\n添加商品：追加全新的field与value\n浏览:遍历hash\n更改数量:自增/自减,设置value值\n删除商品:删除field\n清空:删除key\n\n\n# key value 值存在则不操作,不存在则插入hsetnx key field value\n3.2.4.2 抢购\n\n3.3 list\n需要的存储结构:一个存储空间保存多个数据 ,且通过数据可以体现进入顺序\nlist类型:保存多个数据,底层使用双向链表存储结构实现\n\n3.3.1 基本操作#添加/修改数据lpush key valuel [value2] ....rpush key valuel [value2] ....#获取数据 start stop指索引,从0开始lrange key start stop # 查看全部 -1表示最后一个索引lrange key 0 -1lindex key index llen key#获取并移除数据lpop key rpop key\n3.3.2  扩展操作#规定时间内获取并移除数据 时间单位秒 时间内能取到就取,否则就取到nilblpop keyl [key2...] timeoutbrpop keyl [key2...] timeout#移除指定数据 从左边删除指定key的count个value元素lrem key count value\n3.3.3 list类型数据操作注意事项\nlist中保存的数据都是string类型的,数据总容量是有限的,最多2^32-1个元素(4294967295)\nlist具有索引的概念,但是操作数据时通常以队列的形式进行入队出队操作,或以栈的形式进行入栈出栈操作\n获取全部数据操作结束索引设置为-1\nlist可以对数据进行分页操作,通常第一页的信息来自于list,第2页及更多的信息通过数据库的形式加载\n\n3.4 set\n新的存储需求:存储大量的数据,在查询方面提供更高的效率需要的存储结构:能够保存大量的数据,高效的内部存储机制,便于查询\nset类型:与hash存储结构完全相同,仅存储键,不存储值(nil) ,并且值是不允许重复的\n\n3.4.1 基本操作#添加数据sadd key member1 [member2]#获取全部数据smembers key#删除数据srem key member1 [member2]##获取集合数据总量scard key#判断集合中是否包含指定数据sismember key member\n3.4.2 扩展操作#随机获取集合中指定数量的数据srandmember key [count]#随机获取集合中的几个数据并将该数据移出集合spop key [count]#求两个集合的交、并、差集,差集有方向性sinter keyl [key2]sunion keyl [key2sdiff keyl [key2]#求两个集合的交、并、差集并存储到指定集合中sinterstore destination keyl [key2] sunionstore destination keyl [key2] sdiffstore destination keyl [key2]#将指定数据从原始集合中移动到目标集合中smove source destination member\n3.4.3 注意事项\nset类型不允许数据重复,如果添加的数据在set中已经存在,将只保留一份\nset虽然与hash的存储结构相同,但是无法启用hash中存储值的空间\n\n业务场景:\n公司对旗下新的网站做推广,统计网站的PV (访问量) ,UV (独立访客) ,IP (独立IP)\n\nPV:网站被访问次数,可通过刷新页面提高访问量\nUV:网站被不同用户访问的次数,可通过cookie统计访问量,相同用户切换P地址, UV不变IP:网站被不同IP地址访问的总次数,\n可通过P地址统计访问量,相同IP不同用户访问, IP不变\n\n解决方案:\n\n利用set集合的数据去重特征,记录各种访问数据\n建立string类型数据,利用incr统计日访问量(PV)\n建立set模型,记录不同cookie数量(UV)\n建立se模型,记录不同IP数量(IP)\n\n","categories":["db"],"tags":["redis - db"]},{"title":"springboot整合配置pagehelper","url":"https://www.mele.cool/2020/12/02/springboot整合配置pagehelper/","content":"一.java代码配置法\n　　这种方法个人感觉比较繁琐不是很推荐，而且也不怎么符合springboot的理念，但是胜在也能够用，所以就列起来，万一以后接手的代码是用这种方式的也方便自己维护。\n\n　　首先引入jar包。\n&lt;dependency&gt;　　&lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;　　&lt;artifactId&gt;pagehelper&lt;/artifactId&gt;　　&lt;version&gt;4.1.6&lt;/version&gt;&lt;/dependency&gt;\n　　然后，直接在启动类里面添加如下代码：\n 　　@Beanpublic PageHelper pageHelper()&#123;    PageHelper pageHelper = new PageHelper();    Properties properties = new Properties();    properties.setProperty(&quot;offsetAsPageNum&quot;,&quot;true&quot;);    properties.setProperty(&quot;rowBoundsWithCount&quot;,&quot;true&quot;);    properties.setProperty(&quot;reasonable&quot;,&quot;true&quot;);    properties.setProperty(&quot;dialect&quot;,&quot;mysql&quot;);    //配置mysql数据库的方言    pageHelper.setProperties(properties);    return pageHelper;&#125;\n　　那么这样第一种办法就配置好了。\n二、配置文件配置法　　第二种方法就比较简单了，而且从引入jar包的名字就能看出官方推荐的是哪种配置方式了。\n&lt;dependency&gt;     &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;     &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;     &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt;\n　　引入jar包后只要在application.properties或者application.yml里面加入相关的属性配置就好了，由于个人不太喜欢yml的形式，所以就只列一下application.properties的配置。\n# pagehelper propertiespagehelper.offsetAsPageNum=truepagehelper.rowBoundsWithCount=truepagehelper.pageSizeZero=truepagehelper.reasonable=falsepagehelper.params=pageNum=pageHelperStart;pageSize=pageHelperRows;pagehelper.supportMethodsArguments=false\n　　而且似乎pagehelper不需要配置dialect这个属性也能正常工作。\n","categories":["springboot"],"tags":["springboot","pagehelper - 分页"]},{"title":"springboot热部署","url":"https://www.mele.cool/2020/12/02/springboot项目热部署/","content":"\n平日里开发项目中，修改了Java代码或者配置文件的时候，必须手动重启项目才能生效。所谓的热部署就是在你修改了后端代码后不需要手动重启，工具会帮你快速的自动重启是修改生效。其深层原理是使用了两个ClassLoader，一个Classloader加载那些不会改变的类（第三方Jar包），另一个ClassLoader加载会更改的类，称为restart ClassLoader，这样在有代码更改的时候，原来的restart ClassLoader 被丢弃，重新创建一个restart ClassLoader，由于需要加载的类相比较少，所以实现了较快的重启时间。\n本文将介绍如何通过使用Spring-Boot-devtools来实现Spring Boot项目的热部署。IDE使用的是EclipseOxygen，并且使用Maven构建。\n\n1.引入Devtools搭建一个简单的Spring Boot项目，然后引入Spring-Boot-devtools：\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;\n\n\ndevtools会监听classpath下的文件变动，并且会立即重启应用（发生在保存时机），因为其采用的虚拟机机制，该项重启是很快的。\n在Eclipse中生效还需要修改spring-boot-maven-plugin插件：\n&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;fork&gt;true&lt;/fork&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;\n\n\n并且开启Build Automatically：\n\n2.测试热部署在入口类中添加一个方法，用于热部署测试：\nimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@SpringBootApplicationpublic class DemoApplication &#123;    @RequestMapping(&quot;/&quot;)    String index() &#123;        return &quot;hello spring boot&quot;;    &#125;    public static void main(String[] args) &#123;        SpringApplication.run(DemoApplication.class, args);    &#125;&#125;\n\n\n启动项目访问http://localhost:8080/，页面输出hello spring boot。\n将方法的返回值修改为hello world并在保存的瞬间，应用便重启好了，刷新页面，内容也将得到更改。\n3.所有配置下面是所有Devtools在Spring Boot中的可选配置:\n# Whether to enable a livereload.com-compatible server.spring.devtools.livereload.enabled=true # Server port.spring.devtools.livereload.port=35729 # Additional patterns that should be excluded from triggering a full restart.spring.devtools.restart.additional-exclude= # Additional paths to watch for changes.spring.devtools.restart.additional-paths= # Whether to enable automatic restart.spring.devtools.restart.enabled=true# Patterns that should be excluded from triggering a full restart.spring.devtools.restart.exclude=META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties,META-INF/build-info.properties# Whether to log the condition evaluation delta upon restart.spring.devtools.restart.log-condition-evaluation-delta=true # Amount of time to wait between polling for classpath changes.spring.devtools.restart.poll-interval=1s # Amount of quiet time required without any classpath changes before a restart is triggered.spring.devtools.restart.quiet-period=400ms # Name of a specific file that, when changed, triggers the restart check. If not specified, any classpath file change triggers the restart.spring.devtools.restart.trigger-file=\n\n\n源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/24.Spring-Boot-Devtools\nFrom:  MyBird\n","categories":["springboot"],"tags":["springboot","热部署"]},{"title":"rabbitmq","url":"https://www.mele.cool/2020/12/02/rabbitmq/","content":"1.消息队列概述MQ:Message Queue,消息队列是应用程序与应用程序之间的通信方法.\n1.1为什么使用MQ在项目中,可将一些无需即时返回且耗时的操作提取出来,进行异步处理,而这种异步处理的方式大大的节省了服务器的请求响应时间,从而提高了系统的吞吐量。\n1.2 开发中消息队列通常有如下应用场景:1、任务异步处理将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。2、应用程序解耦合MQ相当于一个中介,生产方通过MQ与消费方交互,它将应用程序进行解耦合。\nMQ是消息通信的模型;实现MQ的大致有两种主流方式: AMQP, JMS.\n\nAMQP是一种协议,更准确的说是一种binary wirelevel protocol (链接协议) 。这是其和JMS的本质差别, AMQP不从API层进行限定,而是直接定义网络交换的数据格式。  \nJMS即Java消息服务JavaMessage Service)应用程序接口,是一个java平台关于面向消息中间件(MOM)的API,用于在两个应用程序之间,或分布式系统中发送消息,进行异步通信。\n\n1.3 AMQP与JMS区别\nJMS是定义了统一的接口,来对消息操作进行统一; AMQP是通过规定协议来统一数据交互的格式JMS限定了必须使用ava语言; \nAMQP只是协议,不规定实现方式,因此是跨语言的。\nJMS规定了两种消息模式;而AMQP的消息模式更加丰富\n\n2.mac安装rabbitmqgraph LR;1[安装rabbitmq] --&gt; 2[安装rabbitmq可视化监控插件]--&gt;3[配置环境变量]--&gt;4[后台启动rabbitmq]\n2.1brew install rabbitmq==&gt; Installing rabbitmq==&gt; Downloading https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.3/rabbitmq-server-generic-unix-3.8.3.tar.xz==&gt; Downloading from https://github-production-release-asset-2e65be.s3.amazonaws.com/924551/9b363b00-6236-11ea-964e-aebcb201484a?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAIW######################################################################## 100.0%==&gt; /usr/bin/unzip -qq -j /usr/local/Cellar/rabbitmq/3.8.3/plugins/rabbitmq_management-3.8.3.ez rabbitmq_management-3.8.3/priv/www/cli/rabbitmqadmin==&gt; CaveatsManagement Plugin enabled by default at http://localhost:15672Bash completion has been installed to:  /usr/local/etc/bash_completion.dTo have launchd start rabbitmq now and restart at login:  brew services start rabbitmqOr, if you don&#x27;t want/need a background service you can just run:  rabbitmq-server==&gt; Summary🍺  /usr/local/Cellar/rabbitmq/3.8.3: 281 files, 20.4MB, built in 1 minute 10 seconds\n2.2安装rabbitmq可视化监控插件boguotong:~ boguotong$ cd /usr/local/Cellar/rabbitmq/3.8.3/boguotong:3.8.3 boguotong$ sudo sbin/rabbitmq-plugins enable rabbitmq_management\n2.3配置环境变量vim ~/.bash_profile //加入以下两行export RABBIT_HOME=/usr/local/Cellar/rabbitmq/3.8.3/sbin/export PATH=$CXF3:$JAVA_HOME:$PATH:$SAPJCO:$JETTY_HOME:$PYTHON_HOME:$RABBIT_HOME // 立即生效 source /etc/profile\n2.4后台启动rabbitmq// 后台启动sudo rabbitmq-server -detached  // 查看状态rabbitmqctl status // 访问可视化监控插件的界面// 浏览器内输入 http://localhost:15672,默认的用户名密码都是guest,登录后可以在Admin那一列菜单内添加自己的用户rabbitmqctl stop 关闭\n3.创建工程\n入门工程:生产者发送消息到RabbitMQ的队列(simple-queue ) ;消费者可以从队列中获取消息。可以使用RabRabbitMQ的简单模式( simple )\n\n3.1 引入依赖&lt;dependency&gt;        &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;        &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;        &lt;version&gt;5.6.0&lt;/version&gt;    &lt;/dependency&gt;\n3.2编写生产者代码发送消息到mq\n在设置连接工厂的时候;如果没有指定连接的参数则会有默认值;可以去设置虚拟主机,实际业务中一般根据不同的业务设置不同的虚拟主机. \n\npackage com.bgt.rabbitmq.simple;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;/** * Package: com.bgt.rabbitmq.controller * Description： 消息生产者 * Author: bgt * Date: Created in 2020/9/19 5:27 下午 * Company: * Copyright: * Version: 0.0.1 * Modified By: */public class RabbitMQController &#123;    public static void main(String[] args) throws Exception&#123;//        1,创建连接工厂(设置RabbitMQ的连接参数) ;        ConnectionFactory factory = new ConnectionFactory();//        2.创建连接;        //主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest        factory.setHost(&quot;localhost&quot;);        factory.setPort(5672);        factory.setVirtualHost(&quot;/&quot;);        factory.setUsername(&quot;guest&quot;);        factory.setPassword(&quot;guest&quot;);        Connection connection = factory.newConnection();//        3.创建频道;        Channel channel = connection.createChannel();//        4.声明队列;//        参数1:队列名称//        参数2:是否定义持久化队列(消息会持久化保存在服务器上)//        参数3:是否独占本连接//        参数4:是否在不使用的时候队列自动删除//        参数5:其它参数        channel.queueDeclare(&quot;simple-queue&quot;,true,false,false,null);//        5.发送消息;        String msg = &quot;你好,我的mq!&quot;;//        参数1:交换机名称；如果没有则指定空字符串(表示使用默认的交换机)//        参数2:路由key,简单模式中可以使用队列名称//        参数3:消息其它属性//        参数4:消息内容        channel.basicPublish(&quot;&quot;,&quot;simple-queue&quot;,null,msg.getBytes());//        6.关闭资源        channel.close();        connection.close();    &#125;&#125;\n3.3 编写消费者代码接收消息\n消费者需要持续监听队列消息,所以不要关闭资源\n\npackage com.bgt.rabbitmq.simple;import com.rabbitmq.client.*;import java.io.IOException;/** * Package: com.bgt.rabbitmq.simple * Description： 简单模式 消费者接收消息 * Author: bgt * Date: Created in 2020/9/19 7:53 下午 * Company: * Copyright: * Version: 0.0.1 * Modified By: */public class RabbitmqConsumer &#123;    public static void main(String[] args) throws Exception&#123;        // 1,创建连接工厂(设置RabbitMQ的连接参数) ;        ConnectionFactory factory = new ConnectionFactory();//        2.创建连接;        //主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest        factory.setHost(&quot;localhost&quot;);        factory.setPort(5672);        factory.setVirtualHost(&quot;/&quot;);        factory.setUsername(&quot;guest&quot;);        factory.setPassword(&quot;guest&quot;);        Connection connection = factory.newConnection();//        3.创建频道;        Channel channel = connection.createChannel();//        4.声明队列;//        参数1:队列名称//        参数2:是否定义持久化队列(消息会持久化保存在服务器上)//        参数3:是否独占本连接//        参数4:是否在不使用的时候队列自动删除//        参数5:其它参数        channel.queueDeclare(&quot;simple-queue&quot;,true,false,false,null);//        5.创建消费者接收并处理消息        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;                //路由key 交换机 消息id 接受到的消息                System.out.println(envelope.getRoutingKey());                System.out.println(envelope.getExchange());                System.out.println(envelope.getDeliveryTag());                System.out.println(new String(body,&quot;UTF-8&quot;));            &#125;        &#125;;        //6 监听队列//        参数1:队列名//        参数2:是否要自动确认;设置为true表示消息接收到自动向MQ回复接收到了, MQ则会将消息从队列中删除;//        如果设置为false则需要手动确认//        参数3:消费者        channel.basicConsume(&quot;simple-queue&quot;,true,consumer);    &#125;&#125;\n3.4 测试\n4.RabbitMQ工作模式4.1work queue工作队列模式\nwork queues与入门程序的简单模式相比,多了一个或一些消费端,多个消费端共同消费同一个队列中的消息(竞争关系)。\n\n应用场景: 可以在消费者端处理任务比较耗时的时候;添加对同一个队列的消费者来提高任务处理能力。\n4.1.1 生产者循环发送三十条消息4.1.2 编写两个消费者package com.bgt.rabbitmq.workqueue;import com.rabbitmq.client.*;import java.io.IOException;/** * Package: com.bgt.rabbitmq.simple * Description： 简单模式 消费者接收消息 * Author: bgt * Date: Created in 2020/9/19 7:53 下午 * Company: * Copyright: * Version: 0.0.1 * Modified By: */public class RabbitmqConsumer1 &#123;    public static void main(String[] args) throws Exception&#123;        // 1,创建连接工厂(设置RabbitMQ的连接参数) ;        ConnectionFactory factory = new ConnectionFactory();//        2.创建连接;        //主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest        factory.setHost(&quot;localhost&quot;);        factory.setPort(5672);        factory.setVirtualHost(&quot;/&quot;);        factory.setUsername(&quot;guest&quot;);        factory.setPassword(&quot;guest&quot;);        Connection connection = factory.newConnection();//        3.创建频道;        final Channel channel = connection.createChannel();//        4.声明队列;//        参数1:队列名称//        参数2:是否定义持久化队列(消息会持久化保存在服务器上)//        参数3:是否独占本连接//        参数4:是否在不使用的时候队列自动删除//        参数5:其它参数        channel.queueDeclare(&quot;simple-queue&quot;,true,false,false,null);        //每次可以预取几个消息        channel.basicQos(1);//        5.创建消费者接收并处理消息        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;                //路由key 交换机 消息id 接受到的消息                System.out.println(&quot;路由key:&quot;+envelope.getRoutingKey());                System.out.println(&quot;交换机:&quot;+envelope.getExchange());                System.out.println(&quot;消息id:&quot;+envelope.getDeliveryTag());                System.out.println(&quot;消费者1---接受到的消息:&quot;+new String(body,&quot;UTF-8&quot;));                try &#123;                    Thread.sleep(1000);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                //确认消息//                参数1:消息id//                基数2: false表示只有当前这条被处理                channel.basicAck(envelope.getDeliveryTag(),false);            &#125;        &#125;;        //6 监听队列//        参数1:队列名//        参数2:是否要自动确认;设置为true表示消息接收到自动向MQ回复接收到了, MQ则会将消息从队列中删除;//        如果设置为false则需要手动确认//        参数3:消费者        channel.basicConsume(&quot;simple-queue&quot;,true,consumer);    &#125;&#125;\n\n\n4.1.3 测试:启动两个消费者,然后启动生产者\n结论:一个消息只能被一个消费者接收.\n\n5.订阅模式\n\nP:生产者,也就是要发送消息的程序,但是不再发送到队列中,而是发给x (交换机)\nC:消费者,消息的接受者,会一直等待消息到来。\nQueue:消息队列,接收消息、缓存消息。\n\nExchange:交换机,图中的x,一方面,接收生产者发送的消息。另一方面,知道如何处理消息,例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作,取决于Exchange的类型。Exchang有常见以下3种类型:\n\n Fanout:广播,将消息交给所有绑定到交换机的队列\n Direct:定向,把消息交给符合指定routing key的队列\n Topic:通配符,把消息交给符合routing pattern (路由模式)的队列\n\nExchange (交换机)只负责转发消息,不具备存储消息的能力,因此如果没有任何队列与Exchange绑定,或者没有符合路由规则的队列,那么消息会丢失!\n5.1.pulish/subscribe发布/订阅模式(广播)发布与订阅模式特点:一个消息可以被多个消费者接收;其实是使用了订阅模式,交换机类型为: fanout广播,一个消费者对应一个队列,该队列只能被一个消费者监听。简单使用：\n\n生产者声明交换机类型为广播类型，并绑定多个队列，然后往这个交换机中发送消息；\n消费者声明同一个交换机，并绑定这个交换机已绑定的其中一个队列，即可监听这个队列获取消息。\n\n5.1.1 生产者package com.bgt.rabbitmq.ps;import com.rabbitmq.client.BuiltinExchangeType;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;/** * Package: com.bgt.rabbitmq.controller * Description： 发布订阅模式  消息生产者 * Author: bgt * Date: Created in 2020/9/19 5:27 下午 * Company: * Copyright: * Version: 0.0.1 * Modified By: */public class Producer &#123;    //交换机    static final String FANOUT_EXCHANGE=&quot;fanout_exchange&quot;;    //队列名称    static final String FANOUT_QUEUE1=&quot;fanout_queue1&quot;;    static final String FANOUT_QUEUE2=&quot;fanout_queue2&quot;;    public static void main(String[] args) throws Exception&#123;//       1.创建连接;        ConnectionFactory factory = new ConnectionFactory();        //主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest        factory.setHost(&quot;localhost&quot;);        factory.setPort(5672);        factory.setVirtualHost(&quot;/&quot;);        factory.setUsername(&quot;guest&quot;);        factory.setPassword(&quot;guest&quot;);        Connection connection = factory.newConnection();//        2.创建频道;        Channel channel = connection.createChannel();        //3,声明交换机;参数1:交换机名称,参数2:交换机类型( fanout, direct, topic)        channel. exchangeDeclare (FANOUT_EXCHANGE, BuiltinExchangeType.FANOUT);        //4．声明队列；        /*参数1:队列名称          参数2:是否定义持久化队列(消息会持久化保存在服务器上)          参数3:是否独占本连接         参数4:是否在不使用的时候队列自动删除         参数5:其它参数        */        channel. queueDeclare (FANOUT_QUEUE1, true,  false,  false,  null);        channel. queueDeclare (FANOUT_QUEUE2, true,  false,  false,  null);//      5.队列绑定到交换机 参数1:队列名称,参数2:交换机名称,参数3:路由key        channel. queueBind (FANOUT_QUEUE1, FANOUT_EXCHANGE,  &quot;&quot;);        channel. queueBind (FANOUT_QUEUE2, FANOUT_EXCHANGE,  &quot;&quot;);        //6 发送消息        //参数1:交换机名称;如果没有则指定空字符串(表示使用默认的交换机)参数2:路由key,简单模式中可以使用队列名称        // 参数3：消息其它属性  参数4:消息内容        for (int i=0;i&lt;10;i++ )&#123;            String msg=&quot;hello mq.发布订阅模式--&quot;+i;            channel.basicPublish(FANOUT_EXCHANGE,&quot;&quot;,null,msg.getBytes());            System.out.println(&quot;已发送消息:&quot;+msg);        &#125;//        6.关闭资源        channel.close();        connection.close();    &#125;&#125;\n\n\n5.1.2 消费者\n创建两个消费者\n\npackage com.bgt.rabbitmq.ps;import com.rabbitmq.client.*;import java.io.IOException;/** * Package: com.bgt.rabbitmq.simple * Description： 发布订阅模式 消费者接收消息 * Author: bgt * Date: Created in 2020/9/19 7:53 下午 * Company: * Copyright: * Version: 0.0.1 * Modified By: */public class Consumer1 &#123;    //交换机    static final String FANOUT_EXCHANGE=&quot;fanout_exchange&quot;;    //队列名称    static final String FANOUT_QUEUE1=&quot;fanout_queue1&quot;;    public static void main(String[] args) throws Exception&#123;        //1.创建连接;        ConnectionFactory factory = new ConnectionFactory();        //主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest        factory.setHost(&quot;localhost&quot;);        factory.setPort(5672);        factory.setVirtualHost(&quot;/&quot;);        factory.setUsername(&quot;guest&quot;);        factory.setPassword(&quot;guest&quot;);        Connection connection = factory.newConnection();//        2.创建频道;        Channel channel = connection.createChannel();        //3 声明交换机        channel.exchangeDeclare(FANOUT_EXCHANGE,BuiltinExchangeType.FANOUT);//        4.声明队列;//        参数1:队列名称//        参数2:是否定义持久化队列(消息会持久化保存在服务器上)//        参数3:是否独占本连接//        参数4:是否在不使用的时候队列自动删除//        参数5:其它参数        channel.queueDeclare(FANOUT_QUEUE1,true,false,false,null);        //5 绑定队列到交换机        channel.queueBind(FANOUT_QUEUE1,FANOUT_EXCHANGE,&quot;&quot;);//        5.创建消费者接收并处理消息        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;                //路由key 交换机 消息id 接受到的消息                System.out.println(&quot;路由key:&quot;+envelope.getRoutingKey());                System.out.println(&quot;交换机:&quot;+envelope.getExchange());                System.out.println(&quot;消息id:&quot;+envelope.getDeliveryTag());                System.out.println(&quot;消费者1---接受到的消息:&quot;+new String(body,&quot;UTF-8&quot;));            &#125;        &#125;;        //6 监听队列//        参数1:队列名//        参数2:是否要自动确认;设置为true表示消息接收到自动向MQ回复接收到了, MQ则会将消息从队列中删除;//        如果设置为false则需要手动确认//        参数3:消费者        channel.basicConsume(FANOUT_QUEUE1,true,consumer);    &#125;&#125;\n5.2routing 路由模式\n特点:\n\n队列与交换机的绑定,不能是任意绑定了,而是要指定一个Routingkey (路由key)\n消息的发送方在向Exchange发送消息时,也必须指定消息的Routingkey.\nExchange不再把消息交给每一个绑定的队列,而是根据消息的Routing key进行判断,只有队列的Routingkey与消息的Routing key完全一致,才会接收到消息\n\n\n简单使用：\n\n生产者声明交换机类型为direct，把交换机和队列绑定的同时指定routingkey，发送消息时同样指定交换机和routingkey；\n消费者声明交换机类型为direct，绑定队列和交换机的同时指定toutingkey，如果routingkey和生产者指定的routingkey一致才能接收到消息。\n\n\n5.2.1 生产者package com.bgt.rabbitmq.routing;import com.rabbitmq.client.BuiltinExchangeType;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;/** * Package: com.bgt.rabbitmq.controller * Description： 路由模式  消息生产者 * Author: bgt * Date: Created in 2020/9/19 5:27 下午 * Company: * Copyright: * Version: 0.0.1 * Modified By: */public class Producer &#123;    //交换机    static final String DIRECT_EXCHANGE=&quot;direct_exchange&quot;;    //队列名称    static final String DIRECT_QUEUE_INSERT=&quot;direct_queue_insert&quot;;    static final String DIRECT_QUEUE_UPDATE=&quot;direct_queue_update&quot;;    public static void main(String[] args) throws Exception&#123;//       1.创建连接;        ConnectionFactory factory = new ConnectionFactory();        //主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest        factory.setHost(&quot;localhost&quot;);        factory.setPort(5672);        factory.setVirtualHost(&quot;myrouting&quot;);        factory.setUsername(&quot;guest&quot;);        factory.setPassword(&quot;guest&quot;);        Connection connection = factory.newConnection();//        2.创建频道;        Channel channel = connection.createChannel();        //3,声明交换机;参数1:交换机名称,参数2:交换机类型( fanout, direct, topic)        channel. exchangeDeclare (DIRECT_EXCHANGE, BuiltinExchangeType.DIRECT);        //4．声明队列；        /*参数1:队列名称          参数2:是否定义持久化队列(消息会持久化保存在服务器上)          参数3:是否独占本连接         参数4:是否在不使用的时候队列自动删除         参数5:其它参数        */        channel. queueDeclare (DIRECT_QUEUE_INSERT, true,  false,  false,  null);        channel. queueDeclare (DIRECT_QUEUE_UPDATE, true,  false,  false,  null);//      5.队列绑定到交换机 参数1:队列名称,参数2:交换机名称,参数3:路由key        channel. queueBind (DIRECT_QUEUE_INSERT, DIRECT_EXCHANGE,  &quot;insert&quot;);        channel. queueBind (DIRECT_QUEUE_UPDATE, DIRECT_EXCHANGE,  &quot;update&quot;);        //6 发送消息        //参数1:交换机名称;如果没有则指定空字符串(表示使用默认的交换机)参数2:路由key,简单模式中可以使用队列名称        // 参数3：消息其它属性  参数4:消息内容        String msg=&quot;hello mq.路由模式--routingkey是insert&quot;;        channel.basicPublish(DIRECT_EXCHANGE,&quot;insert&quot;,null,msg.getBytes());        System.out.println(&quot;已发送消息:&quot;+msg);        msg=&quot;hello mq.路由模式--routingkey是update&quot;;        channel.basicPublish(DIRECT_EXCHANGE,&quot;update&quot;,null,msg.getBytes());        System.out.println(&quot;已发送消息:&quot;+msg);//        6.关闭资源        channel.close();        connection.close();    &#125;&#125;\n\n\n5.2.2消费者\n创建两个消费者,分别通过不同的routingkey绑定同一个交换机\n\n5.2.2.1消费者1package com.bgt.rabbitmq.routing;import com.rabbitmq.client.*;import java.io.IOException;/** * Package: com.bgt.rabbitmq.simple * Description： 发布订阅模式 消费者接收消息 * Author: bgt * Date: Created in 2020/9/19 7:53 下午 * Company: * Copyright: * Version: 0.0.1 * Modified By: */public class Consumer1 &#123;    //交换机    static final String DIRECT_EXCHANGE=&quot;direct_exchange&quot;;    //队列名称    static final String DIRECT_QUEUE_INSERT=&quot;direct_queue_insert&quot;;    public static void main(String[] args) throws Exception&#123;        //1.创建连接;        ConnectionFactory factory = new ConnectionFactory();        //主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest        factory.setHost(&quot;localhost&quot;);        factory.setPort(5672);        factory.setVirtualHost(&quot;myrouting&quot;);        factory.setUsername(&quot;guest&quot;);        factory.setPassword(&quot;guest&quot;);        Connection connection = factory.newConnection();//        2.创建频道;        Channel channel = connection.createChannel();        //3 声明交换机        channel.exchangeDeclare(DIRECT_EXCHANGE,BuiltinExchangeType.DIRECT);//        4.声明队列;//        参数1:队列名称//        参数2:是否定义持久化队列(消息会持久化保存在服务器上)//        参数3:是否独占本连接//        参数4:是否在不使用的时候队列自动删除//        参数5:其它参数        channel.queueDeclare(DIRECT_QUEUE_INSERT,true,false,false,null);        //5 绑定队列到交换机      //备注:这一步应该可以不要,生产者发送消息时根据routingkey和交换机把消息发送到绑定的队列中,因此消费者只需要监听这个队列就可以获取消息,实测消费者不需要再次绑定交换机/队列/routingkey也可以取到消息,因此这行不需要.       // channel.queueBind(DIRECT_QUEUE_INSERT,DIRECT_EXCHANGE,&quot;insert&quot;);//        5.创建消费者接收并处理消息        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;                //路由key 交换机 消息id 接受到的消息                System.out.println(&quot;路由key:&quot;+envelope.getRoutingKey());                System.out.println(&quot;交换机:&quot;+envelope.getExchange());                System.out.println(&quot;消息id:&quot;+envelope.getDeliveryTag());                System.out.println(&quot;消费者1---接受到的消息:&quot;+new String(body,&quot;UTF-8&quot;));            &#125;        &#125;;        //6 监听队列//        参数1:队列名//        参数2:是否要自动确认;设置为true表示消息接收到自动向MQ回复接收到了, MQ则会将消息从队列中删除;//        如果设置为false则需要手动确认//        参数3:消费者        channel.basicConsume(DIRECT_QUEUE_INSERT,true,consumer);    &#125;&#125;\n5.2.2.2消费者2package com.bgt.rabbitmq.routing;import com.rabbitmq.client.*;import java.io.IOException;/** * Package: com.bgt.rabbitmq.simple * Description： 发布订阅模式 消费者接收消息 * Author: bgt * Date: Created in 2020/9/19 7:53 下午 * Company: * Copyright: * Version: 0.0.1 * Modified By: */public class Consumer2 &#123;    //交换机    static final String DIRECT_EXCHANGE=&quot;direct_exchange&quot;;    //队列名称    static final String DIRECT_QUEUE_UPDATE=&quot;direct_queue_update&quot;;    public static void main(String[] args) throws Exception&#123;        //1.创建连接;        ConnectionFactory factory = new ConnectionFactory();        //主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest        factory.setHost(&quot;localhost&quot;);        factory.setPort(5672);        factory.setVirtualHost(&quot;myrouting&quot;);        factory.setUsername(&quot;guest&quot;);        factory.setPassword(&quot;guest&quot;);        Connection connection = factory.newConnection();//        2.创建频道;        Channel channel = connection.createChannel();        //3 声明交换机        channel.exchangeDeclare(DIRECT_EXCHANGE,BuiltinExchangeType.DIRECT);//        4.声明队列;//        参数1:队列名称//        参数2:是否定义持久化队列(消息会持久化保存在服务器上)//        参数3:是否独占本连接//        参数4:是否在不使用的时候队列自动删除//        参数5:其它参数        channel.queueDeclare(DIRECT_QUEUE_UPDATE,true,false,false,null);        //5 绑定队列到交换机       //备注:这一步应该可以不要,生产者发送消息时根据routingkey和交换机把消息发送到绑定的队列中,因此消费者只需要监听这个队列就可以获取消息,实测消费者不需要再次绑定交换机/队列/routingkey也可以取到消息,因此这行不需要.        //channel.queueBind(DIRECT_QUEUE_UPDATE,DIRECT_EXCHANGE,&quot;update&quot;);//        5.创建消费者接收并处理消息        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;                //路由key 交换机 消息id 接受到的消息                System.out.println(&quot;路由key:&quot;+envelope.getRoutingKey());                System.out.println(&quot;交换机:&quot;+envelope.getExchange());                System.out.println(&quot;消息id:&quot;+envelope.getDeliveryTag());                System.out.println(&quot;消费者1---接受到的消息:&quot;+new String(body,&quot;UTF-8&quot;));            &#125;        &#125;;        //6 监听队列//        参数1:队列名//        参数2:是否要自动确认;设置为true表示消息接收到自动向MQ回复接收到了, MQ则会将消息从队列中删除;//        如果设置为false则需要手动确认//        参数3:消费者        channel.basicConsume(DIRECT_QUEUE_UPDATE,true,consumer);    &#125;&#125;\n5.3 topics通配符模式\nTopic类型与Direct相比,都是可以根据Routingkey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key的时候使用通配符!Routingkey一般都是有一个或多个单词组成,多个单词之间以”.”分割,例如: item.inser\n\n通配符规则:\n\n#：匹配一个或多个词\n*:   匹配不多不少恰好1个词\n\n举例:\n\nitem.#:能够匹配item.insert.abc或者item.insertitem.\n*:只能匹配item.insert\n\n\n\n5.3.1生产者基于路由模式代码改造如下:\n//声明交换机;交换机类型改为通配符模式channel.exchangeDeclare (TOPIC EXCHAGE, BuiltinExchangeType. TOPIC) ://发送三条消息指定不同的routingkeychannel.basicPublish (TOPIC EXCHAGE, routingKey: &quot;item.insert&quot;, props: null, message.getBytes());channel.basicPublish (TOPIC EXCHAGE, routingKey: &quot;item.update&quot;, props: null, message.getBytes());channel.basicPublish (TOPIC EXCHAGE, routingKey: &quot;item.delete&quot;, props: null, message.getBytes());\n5.3.2 消费者\n两个消费者\n\n 基于路由模式代码改造如下:\n//声明交换机;交换机类型改为通配符模式channel.exchangeDeclare (Producer. TOPIC EXCHAGE, BuiltinExchangeType.TOPIC);//消费者1绑定这两个指定routingkeychannel.queueBind (Producer.TOPIC_QUEUE1, Producer.TOPIC_EXCHAGE, &quot;item.update&quot;);channel.queueBind (Producer.TOPIC_QUEUE1, Producer.TOPIC_EXCHAGE, &quot;item.delete&quot;);//消费者2绑定通配符模式的routingkeychannel.queueBind (Producer.TOPIC_QUEUE2, Producer.TOPIC_EXCHAGE, &quot;item.*&quot;);\n5.4 rabbitmq模式总结\n6.springboot整合rabbitmq\nSpring Boot提供了对于AMQP的整合;可以使月RabbitTemplate发送消息;可以使用@RabbitListener注解接收消息。\n示例通配符模式\n\n6.1 生产者工程6.1.1 添加依赖 &lt;!--rabbitmq发送消息核心依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.bootk/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amgp&lt;/artifactrds&lt;/dependency&gt; &lt;!--rabbitmq发送消息测试依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.bootk/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactrds&lt;/dependency&gt;\t\n\n\n6.1.2 添加配置文件\napplication.properties配置rabbitmq连接信息\n\nspring:\trabbitmq:    host: localhost    port: 5672     virtual-host: /    username: guest    password: guest\n6.1.3 创建配置类\n6.1.4 创建发送消息类\n6.2 消费者工程6.2.1 添加依赖&lt;!--rabbitmq发送消息核心依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.bootk/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amgp&lt;/artifactrds&lt;/dependency&gt;\n\n\n6.2.2 添加配置文件spring:\trabbitmq:    host: localhost    port: 5672     virtual-host: /    username: guest    password: guest\n6.2.3 编写消息监听器类","categories":["mq"],"tags":["rabbitmq - mq"]},{"title":"springboot单元测试","url":"https://www.mele.cool/2020/12/02/springboot单元测试/","content":"\n编写单元测试可以帮助开发人员编写高质量的代码，提升代码质量，减少Bug，便于重构。SpringBoot提供了一些实用程序和注解，用来帮助我们测试应用程序，在SpringBoot中开启单元测试只需引入spring-boot-starter-test即可，其包含了一些主流的测试库。本文主要介绍基于Service和Controller的单元测试。\n\n一、引入依赖spring-boot-starter-test：&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;\n运行Maven命令dependency:tree可看到其包含了以下依赖：\n[INFO] +- org.springframework.boot:spring-boot-starter-test:jar:1.5.9.RELEASE:test[INFO] |  +- org.springframework.boot:spring-boot-test:jar:1.5.9.RELEASE:test[INFO] |  +- org.springframework.boot:spring-boot-test-autoconfigure:jar:1.5.9.RELEASE:test[INFO] |  +- com.jayway.jsonpath:json-path:jar:2.2.0:test[INFO] |  |  +- net.minidev:json-smart:jar:2.2.1:test[INFO] |  |  |  \\- net.minidev:accessors-smart:jar:1.1:test[INFO] |  |  |     \\- org.ow2.asm:asm:jar:5.0.3:test[INFO] |  |  \\- org.slf4j:slf4j-api:jar:1.7.25:compile[INFO] |  +- junit:junit:jar:4.12:test[INFO] |  +- org.assertj:assertj-core:jar:2.6.0:test[INFO] |  +- org.mockito:mockito-core:jar:1.10.19:test[INFO] |  |  \\- org.objenesis:objenesis:jar:2.1:test[INFO] |  +- org.hamcrest:hamcrest-core:jar:1.3:test[INFO] |  +- org.hamcrest:hamcrest-library:jar:1.3:test[INFO] |  +- org.skyscreamer:jsonassert:jar:1.4.0:test[INFO] |  |  \\- com.vaadin.external.google:android-json:jar:0.0.20131108.vaadin1:test[INFO] |  +- org.springframework:spring-core:jar:4.3.13.RELEASE:compile[INFO] |  \\- org.springframework:spring-test:jar:4.3.13.RELEASE:test\n\n\n\nJUnit，标准的单元测试Java应用程序；\nSpring Test &amp; Spring Boot Test，对Spring Boot应用程序的单元测试提供支持；\nMockito, Java mocking框架，用于模拟任何Spring管理的Bean，比如在单元测试中模拟一个第三方系统Service接口返回的数据，而不会去真正调用第三方系统；\nAssertJ，一个流畅的assertion库，同时也提供了更多的期望值与测试返回值的比较方式；\nHamcrest，库的匹配对象（也称为约束或谓词）；\nJsonPath，提供类似XPath那样的符号来获取JSON数据片段；\nJSONassert，对JSON对象或者JSON字符串断言的库。\n\n一个标准的Spring Boot测试单元应有如下的代码结构：\nimport org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class ApplicationTest &#123;\t&#125;\n\n\n二、知识准备1.JUnit4注解JUnit4中包含了几个比较重要的注解：@BeforeClass、@AfterClass、@Before、@After和@Test。其中， @BeforeClass和@AfterClass在每个类加载的开始和结束时运行，必须为静态方法；而@Before和@After则在每个测试方法开始之前和结束之后运行。见如下例子：\n@RunWith(SpringRunner.class)@SpringBootTestpublic class TestApplicationTests &#123;    @BeforeClass    public static void beforeClassTest() &#123;        System.out.println(&quot;before class test&quot;);    &#125;    @Before    public void beforeTest() &#123;        System.out.println(&quot;before test&quot;);    &#125;    @Test    public void Test1() &#123;        System.out.println(&quot;test 1+1=2&quot;);        Assert.assertEquals(2, 1 + 1);    &#125;    @Test    public void Test2() &#123;        System.out.println(&quot;test 2+2=4&quot;);        Assert.assertEquals(4, 2 + 2);    &#125;    @After    public void afterTest() &#123;        System.out.println(&quot;after test&quot;);    &#125;    @AfterClass    public static void afterClassTest() &#123;        System.out.println(&quot;after class test&quot;);    &#125;&#125;\n\n\n运行输出如下：\n...before class testbefore testtest 1+1=2after testbefore testtest 2+2=4after testafter class test...\n\n\n从上面的输出可以看出各个注解的运行时机。\n2.Assert上面代码中，我们使用了Assert类提供的assert口方法，下面列出了一些常用的assert方法：\n\nassertEquals(&quot;message&quot;,A,B)，判断A对象和B对象是否相等，这个判断在比较两个对象时调用了equals()方法。\nassertSame(&quot;message&quot;,A,B)，判断A对象与B对象是否相同，使用的是==操作符。\nassertTrue(&quot;message&quot;,A)，判断A条件是否为真。\nassertFalse(&quot;message&quot;,A)，判断A条件是否不为真。\nassertNotNull(&quot;message&quot;,A)，判断A对象是否不为null。\nassertArrayEquals(&quot;message&quot;,A,B)，判断A数组与B数组是否相等。\n\n3.MockMvc下文中，对Controller的测试需要用到MockMvc技术。MockMvc，从字面上来看指的是模拟的MVC，即其可以模拟一个MVC环境，向Controller发送请求然后得到响应。\n在单元测试中，使用MockMvc前需要进行初始化，如下所示：\nprivate MockMvc mockMvc;@Autowiredprivate WebApplicationContext wac;@Beforepublic void setupMockMvc()&#123;    mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();&#125;\n\n\n3.1 MockMvc模拟MVC请求模拟一个get请求：\nmockMvc.perform(MockMvcRequestBuilders.get(&quot;/hello?name=&#123;name&#125;&quot;,&quot;mrbird&quot;));\n\n\n模拟一个post请求：\nmockMvc.perform(MockMvcRequestBuilders.post(&quot;/user/&#123;id&#125;&quot;, 1));\n\n\n模拟文件上传：\nmockMvc.perform(MockMvcRequestBuilders.fileUpload(&quot;/fileupload&quot;).file(&quot;file&quot;, &quot;文件内容&quot;.getBytes(&quot;utf-8&quot;)));\n\n\n模拟请求参数：\n// 模拟发送一个message参数，值为hellomockMvc.perform(MockMvcRequestBuilders.get(&quot;/hello&quot;).param(&quot;message&quot;, &quot;hello&quot;));// 模拟提交一个checkbox值，name为hobby，值为sleep和eatmockMvc.perform(MockMvcRequestBuilders.get(&quot;/saveHobby&quot;).param(&quot;hobby&quot;, &quot;sleep&quot;, &quot;eat&quot;));\n\n\n也可以直接使用MultiValueMap构建参数：\nMultiValueMap&lt;String, String&gt; params = new LinkedMultiValueMap&lt;String, String&gt;();params.add(&quot;name&quot;, &quot;mrbird&quot;);params.add(&quot;hobby&quot;, &quot;sleep&quot;);params.add(&quot;hobby&quot;, &quot;eat&quot;);mockMvc.perform(MockMvcRequestBuilders.get(&quot;/hobby/save&quot;).params(params));\n\n\n模拟发送JSON参数：\nString jsonStr = &quot;&#123;\\&quot;username\\&quot;:\\&quot;Dopa\\&quot;,\\&quot;passwd\\&quot;:\\&quot;ac3af72d9f95161a502fd326865c2f15\\&quot;,\\&quot;status\\&quot;:\\&quot;1\\&quot;&#125;&quot;;mockMvc.perform(MockMvcRequestBuilders.post(&quot;/user/save&quot;).content(jsonStr.getBytes()));\n\n\n实际测试中，要手动编写这么长的JSON格式字符串很繁琐也很容易出错，可以借助Spring Boot自带的Jackson技术来序列化一个Java对象（可参考Spring Boot中的JSON技术），如下所示：\nUser user = new User();user.setUsername(&quot;Dopa&quot;);user.setPasswd(&quot;ac3af72d9f95161a502fd326865c2f15&quot;);user.setStatus(&quot;1&quot;);String userJson = mapper.writeValueAsString(user);mockMvc.perform(MockMvcRequestBuilders.post(&quot;/user/save&quot;).content(userJson.getBytes()));\n\n\n其中，mapper为com.fasterxml.jackson.databind.ObjectMapper对象。\n模拟Session和Cookie：\nmockMvc.perform(MockMvcRequestBuilders.get(&quot;/index&quot;).sessionAttr(name, value));mockMvc.perform(MockMvcRequestBuilders.get(&quot;/index&quot;).cookie(new Cookie(name, value)));\n\n\n设置请求的Content-Type：\nmockMvc.perform(MockMvcRequestBuilders.get(&quot;/index&quot;).contentType(MediaType.APPLICATION_JSON_UTF8));\n\n\n设置返回格式为JSON：\nmockMvc.perform(MockMvcRequestBuilders.get(&quot;/user/&#123;id&#125;&quot;, 1).accept(MediaType.APPLICATION_JSON));\n\n\n模拟HTTP请求头：\nmockMvc.perform(MockMvcRequestBuilders.get(&quot;/user/&#123;id&#125;&quot;, 1).header(name, values));\n\n\n3.2MockMvc处理返回结果期望成功调用，即HTTP Status为200：\nmockMvc.perform(MockMvcRequestBuilders.get(&quot;/user/&#123;id&#125;&quot;, 1))    .andExpect(MockMvcResultMatchers.status().isOk());\n\n\n期望返回内容是application/json：\nmockMvc.perform(MockMvcRequestBuilders.get(&quot;/user/&#123;id&#125;&quot;, 1))    .andExpect(MockMvcResultMatchers.content().contentType(MediaType.APPLICATION_JSON));\n\n\n检查返回JSON数据中某个值的内容：\nmockMvc.perform(MockMvcRequestBuilders.get(&quot;/user/&#123;id&#125;&quot;, 1))    .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.username&quot;).value(&quot;mrbird&quot;));\n\n\n这里使用到了jsonPath，$代表了JSON的根节点。更多关于jsonPath的介绍可参考 https://github.com/json-path/JsonPath。\n判断Controller方法是否返回某视图：\nmockMvc.perform(MockMvcRequestBuilders.post(&quot;/index&quot;))    .andExpect(MockMvcResultMatchers.view().name(&quot;index.html&quot;));\n\n\n比较Model：\nmockMvc.perform(MockMvcRequestBuilders.get(&quot;/user/&#123;id&#125;&quot;, 1))    .andExpect(MockMvcResultMatchers.model().size(1))    .andExpect(MockMvcResultMatchers.model().attributeExists(&quot;password&quot;))    .andExpect(MockMvcResultMatchers.model().attribute(&quot;username&quot;, &quot;mrbird&quot;));\n\n\n比较forward或者redirect：\nmockMvc.perform(MockMvcRequestBuilders.get(&quot;/index&quot;))    .andExpect(MockMvcResultMatchers.forwardedUrl(&quot;index.html&quot;));// 或者mockMvc.perform(MockMvcRequestBuilders.get(&quot;/index&quot;))    .andExpect(MockMvcResultMatchers.redirectedUrl(&quot;index.html&quot;));\n\n\n比较返回内容，使用content()：\n// 返回内容为hellomockMvc.perform(MockMvcRequestBuilders.get(&quot;/index&quot;))    .andExpect(MockMvcResultMatchers.content().string(&quot;hello&quot;));// 返回内容是XML，并且与xmlCotent一样mockMvc.perform(MockMvcRequestBuilders.get(&quot;/index&quot;))    .andExpect(MockMvcResultMatchers.content().xml(xmlContent));// 返回内容是JSON ，并且与jsonContent一样mockMvc.perform(MockMvcRequestBuilders.get(&quot;/index&quot;))    .andExpect(MockMvcResultMatchers.content().json(jsonContent));\n\n\n输出响应结果：\nmockMvc.perform(MockMvcRequestBuilders.get(&quot;/index&quot;))    .andDo(MockMvcResultHandlers.print());\n\n\n三、 测试Service现有如下Service：\n@Repository(&quot;userService&quot;)public class UserServiceImpl extends BaseService&lt;User&gt; implements UserService &#123;    @Override    public User findByName(String userName) &#123;        Example example = new Example(User.class);        example.createCriteria().andCondition(&quot;username=&quot;, userName);        List&lt;User&gt; userList = this.selectByExample(example);        if (userList.size() != 0)            return userList.get(0);        else            return null;    &#125;&#125;\n\n\n编写一个该Service的单元测试，测试findByName方法是否有效：\n@RunWith(SpringRunner.class)@SpringBootTestpublic class UserServiceTest &#123;    @Autowired    UserService userService;    @Test    public void test() &#123;        User user = this.userService.findByName(&quot;scott&quot;);        Assert.assertEquals(&quot;用户名为scott&quot;, &quot;scott&quot;, user.getUsername());    &#125;&#125;\n\n\n运行后，JUnit没有报错说明测试通过，即UserService的findByName方法可行。\n此外，和在Controller中引用Service相比，在测试单元中对Service测试完毕后，数据能自动回滚，只需要在测试方法上加上@Transactional注解，比如:\n@Test@Transactionalpublic void test() &#123;    User user = new User();    user.setId(this.userService.getSequence(&quot;seq_user&quot;));    user.setUsername(&quot;JUnit&quot;);    user.setPasswd(&quot;123456&quot;);    user.setStatus(&quot;1&quot;);    user.setCreateTime(new Date());    this.userService.save(user);&#125;\n\n\n运行，测试通过，查看数据库发现数据并没有被插入，这样很好的避免了不必要的数据污染。\n四、 测试Controller现有如下Controller：\n@RestControllerpublic class UserController &#123;    @Autowired    UserService userService;    @GetMapping(&quot;user/&#123;userName&#125;&quot;)    public User getUserByName(@PathVariable(value = &quot;userName&quot;) String userName) &#123;        return this.userService.findByName(userName);    &#125;    @PostMapping(&quot;user/save&quot;)    public void saveUser(@RequestBody User user) &#123;        this.userService.saveUser(user);    &#125;&#125;\n\n\n现在编写一个针对于该ControllergetUserByName(@PathVariable(value = &quot;userName&quot;) String userName)方法的测试类：\n@RunWith(SpringRunner.class)@SpringBootTestpublic class UserControllerTest &#123;    private MockMvc mockMvc;        @Autowired    private WebApplicationContext wac;        @Before    public void setupMockMvc()&#123;        mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();    &#125;        @Test    public void test() throws Exception &#123;        mockMvc.perform(            MockMvcRequestBuilders.get(&quot;/user/&#123;userName&#125;&quot;, &quot;scott&quot;)            .contentType(MediaType.APPLICATION_JSON_UTF8))        .andExpect(MockMvcResultMatchers.status().isOk())        .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.username&quot;).value(&quot;scott&quot;))        .andDo(MockMvcResultHandlers.print());    &#125;&#125;\n\n\n运行后，JUnit通过，控制台输出过程如下所示：\nMockHttpServletRequest:      HTTP Method = GET      Request URI = /user/scott       Parameters = &#123;&#125;          Headers = &#123;Content-Type=[application/json;charset=UTF-8]&#125;Handler:             Type = demo.springboot.test.controller.UserController           Method = public demo.springboot.test.domain.User demo.springboot.test.controller.UserController.getUserByName(java.lang.String)Async:    Async started = false     Async result = nullResolved Exception:             Type = nullModelAndView:        View name = null             View = null            Model = nullFlashMap:       Attributes = nullMockHttpServletResponse:           Status = 200    Error message = null          Headers = &#123;Content-Type=[application/json;charset=UTF-8]&#125;     Content type = application/json;charset=UTF-8             Body = &#123;&quot;id&quot;:23,&quot;username&quot;:&quot;scott&quot;,&quot;passwd&quot;:&quot;ac3af72d9f95161a502fd326865c2f15&quot;,&quot;createTime&quot;:1514535399000,&quot;status&quot;:&quot;1&quot;&#125;    Forwarded URL = null   Redirected URL = null          Cookies = []\n\n\n继续编写一个针对于该ControllersaveUser(@RequestBody User user)方法的测试类：\n@RunWith(SpringRunner.class)@SpringBootTestpublic class UserControllerTest &#123;    private MockMvc mockMvc;        @Autowired    private WebApplicationContext wac;        @Autowired    ObjectMapper mapper;            @Before    public void setupMockMvc()&#123;        mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();    &#125;\t    @Test    @Transactional    public void test() throws Exception &#123;        User user = new User();        user.setUsername(&quot;Dopa&quot;);        user.setPasswd(&quot;ac3af72d9f95161a502fd326865c2f15&quot;);        user.setStatus(&quot;1&quot;);                String userJson = mapper.writeValueAsString(user);        mockMvc.perform(            MockMvcRequestBuilders.post(&quot;/user/save&quot;)            .contentType(MediaType.APPLICATION_JSON_UTF8)            .content(userJson.getBytes()))        .andExpect(MockMvcResultMatchers.status().isOk())        .andDo(MockMvcResultHandlers.print());    &#125;&#125;\n\n\n运行过程如下所示：\nMockHttpServletRequest:      HTTP Method = POST      Request URI = /user/save       Parameters = &#123;&#125;          Headers = &#123;Content-Type=[application/json;charset=UTF-8]&#125;Handler:             Type = demo.springboot.test.controller.UserController           Method = public void demo.springboot.test.controller.UserController.saveUser(demo.springboot.test.domain.User)Async:    Async started = false     Async result = nullResolved Exception:             Type = nullModelAndView:        View name = null             View = null            Model = nullFlashMap:       Attributes = nullMockHttpServletResponse:           Status = 200    Error message = null          Headers = &#123;&#125;     Content type = null             Body =     Forwarded URL = null   Redirected URL = null          Cookies = []\n\n\n值得注意的是，在一个完整的系统中编写测试单元时，可能需要模拟一个登录用户信息Session，MockMvc也提供了解决方案，可在初始化的时候模拟一个HttpSession：\nprivate MockMvc mockMvc;private MockHttpSession session;@Autowiredprivate WebApplicationContext wac;@Beforepublic void setupMockMvc()&#123;    mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();    session = new MockHttpSession();    User user =new User();    user.setUsername(&quot;Dopa&quot;);    user.setPasswd(&quot;ac3af72d9f95161a502fd326865c2f15&quot;);    session.setAttribute(&quot;user&quot;, user); &#125;\n\n\n源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/19.Spring-Boot-Testing\nFrom: MyBird\n","categories":["springboot"],"tags":["springboot","单元测试"]},{"title":"springcloud入门","url":"https://www.mele.cool/2020/12/02/springcloud入门/","content":"1.RestTemplate的介绍一般情况下有如下三种http客户端工具类包都可以方便的进行http服务调用:\n\nhttpClient\nokHttp\nJDK原生URLConnection\n\nspring提供了RestTemplate的工具类对上述的3种http客户端工具类进行了封装,可在spring项目中使用RestTemplate进行服务调用。\n1.1启动类注入RestTemplate\n1.2 代码中使用\n2.入门工程\n2.1 父工程依赖\n通过scope的import可以继承spring-cloud-dependencies工程中的依赖\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.bgt&lt;/groupId&gt;    &lt;artifactId&gt;springcloud&lt;/artifactId&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;modules&gt;        &lt;module&gt;user-service&lt;/module&gt;        &lt;module&gt;user-consumer&lt;/module&gt;    &lt;/modules&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;        &lt;relativePath&gt;&lt;/relativePath&gt;    &lt;/parent&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;spring-cloud.version&gt;Greenwich.SR1&lt;/spring-cloud.version&gt;        &lt;mapper.starter.version&gt;2.1.5&lt;/mapper.starter.version&gt;        &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt;    &lt;/properties&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;&lt;!--            spring-cloud &lt;scope&gt;import&lt;/scope&gt;此处配置意为本项目不仅继承springboot2.1.5.RELEASE的依赖坐标,同时也继承spring-cloud-dependencies Greenwich.SR1的依赖坐标--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;&lt;!--            通用mapper--&gt;            &lt;dependency&gt;                &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;                &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;                &lt;version&gt;$&#123;mapper.starter.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;mysql&lt;/groupId&gt;                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n2.2 user-service 生产者2.2.1依赖\n版本号在父工程中管理,子工程不需要声明版本号\n\n&lt;!--            通用mapper--&gt;            &lt;dependency&gt;                &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;                &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;            &lt;/dependency&gt;&lt;!--            mysql--&gt;            &lt;dependency&gt;                &lt;groupId&gt;mysql&lt;/groupId&gt;                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;/dependency&gt;\n2.2.2 配置文件\n2.2.3 创建实体类及数据库表2.2.4 启动类加mybatis注解\n2.2.5 编写mapper\n2.2.6 编写业务类service\n2.2.7 编写处理器controller\n2.2.8 测试\n2.3 user-consumer 消费者2.3.1 添加依赖\n2.3.2 启动类注入RestTemplate\n2.3.3 编写controller\n编写用到的user类\n\n\n2.3.4 测试\n2.4 问题\n\n上述的问题都可以通过Spring Cloud的各种组件解决。\n\n3.Eureka 注册中心\n\n\nEureka的主要功能是进行服务管理,定期检查服务状态,返回服务地址列表。\n\n3.1 搭建eureka-server工程\nEureka是服务注册中心,只做服务注册;自身并不提供服务也不消费服务。可以搭建web工程使用Eureka ,可以使用Spring Boot方式搭建。\n\n\n3.1.1 依赖\n3.1.2 启动类\n3.1.3 配置文件\n3.1.4 启动测试,能否查看到\n3.2 服务注册与发现\n目标:将user-service的服务注册到eureka并在consumer-demo中可以根据服务名称调用\n\n\n3.2.1 生产者工程user-serivce依赖\n3.2.2 生产者工程user-serivce启动器修改\n3.2.3 生产者工程user-serivce修改配置文件\n3.2.4 生产者工程user-serivce启动测试测试\n启动eureka服务,启动user-service服务,成功标准是在eureka界面可以看到user-service的服务注册成功.\n\n\n3.2.5 消费者工程user-consumer添加依赖\n3.2.6 消费者工程user-consumer启动类修改\n3.2.7 消费者工程user-consumer配置文件修改\n3.2.8 消费者工程user-consumer处理器controller修改\n3.2.9 测试3.3 Eureka Server高可用配置\n\n3.3.1 eureka-server工程1修改配置文件\n${port:10086}  表示如果提供port就用提供的port,否则使用10086\n\n\n3.3.2 修改启动项,并复制一个新的启动器,相互注册.\n \n3.3.3 启动两个启动类,查看效果\n\n3.3.4  启动user-service\n本服务会自动注册到10086 10087两个eureka-server中\n也可以在配置文件中配置注册到多台eureka-server中\n\n\n3.4 Eureka客户端与服务端配置\n3.4.1 服务提供者设置 使用ip地址\n\n3.4.2 服务提供者服务续约配置\n\n\n并非服务失效时间到了就一定会剔除,只是说时间到了表示该服务可以被剔除,具体啥时剔除需要eureka-server扫描到(默认60秒扫描一次). \n\n3.4.3 服务消费者设置拉取服务列表间隔时间\n3.4.4 eureka-server服务端设置失效剔除时间间隔\n3.4.5 eureka-server服务端设置关闭自我保护模式(开发中推荐设置)\n4.Ribbon负载均衡\n\n依赖来自于eureka.\n需求:可以使用RestTemplate访问http://user-service/user/8获取服务数据。\n\n\n4.1 启动两个user-serivce4.2 服务消费者启动类添加注解\n4.3 服务消费者controller修改\n5.hystrix熔断器(服务消费者)\n雪崩问题:\n\n5.1 开启熔断\n5.1.1 依赖\n5.1.2 服务消费者开启熔断\n5.1.3 服务消费者编写降级逻辑\n5.1.4 服务消费者默认降级逻辑\n5.1.3中针对单个方法的降级逻辑,如果方法多了,每个方法都这么写不现实,可以根据类设置默认降级回调方法\n\n\n\n5.1.5 服务消费者设置熔断器hystrix超时时间\n5.2 熔断原理\n  修改熔断器阈值:\n\n6. Feign\n6.1 使用\n6.1.1 消费者工程添加依赖\n6.1.2 修改启动类,开启feign功能\n6.1.3 编写feign客户端代码\n6.1.4 编写处理器controller\n6.1.5 测试\n6.2feign负载均衡及熔断\n6.2.1 负载均衡\n\n6.2.2 hystrix支持  熔断6.2.2.1 服务消费者修改配置文件开启feign熔断功能\n6.2.2.2 编写熔断降级类\n6.2.2.3  feign客户端指定使用降级类\n6.2.3 请求压缩6.2.4 日志级别7.Gateway 网关\n\n核心概念:\n\n\n7.1 入门工程7.1.1 依赖\n7.1.2 启动类 \n7.1.3 配置文件\n\nhttp://127.0.0.1:10010/user/8 -&gt; http://127.0.0.1:9091/user/8\n\n7.1.4 测试\n7.2 面向服务的路由(动态路由)\n\n7.3 路由前缀处理\n7.3.1 添加前缀\n\n7.3.2 去除前缀\n\n7.4 过滤器\n \n\n\n\n\n\n7.5 自定义过滤器7.5.1 自定义局部过滤器\n需求:在过滤器( MyParamGatewayFilterFactory )中将http://localhost:10010/api/user/8?name=itcast中的参数name的值获取到并输出到控制台;并且参数名是可变的,也就是不一定每次都是name ;需要可以通过配置过滤器的时候做到配置参数名。\n\n7.5.1.1 配置\n7.5.1.2 编写过滤器类\n7.5.1.3 测试\n7.5.2 自定义全局过滤器\n需求:编写全局过滤器,在过滤器中检查请求地址是否携带token参数。如果token参数的值存在则放行;如果token的参数值为空或者不存在则设置返回的状态码为:未授权也不再执行下去\n\n7.5.2.1 编写全局过滤器\n7.5.2.2 测试 \n7.6 gateway其他配置\n8.springcloud config 配置中心\nspring cloud config作用:可以通过修改在git仓库中的配置文件实现其它所有微服务的配置文件的修改。\n\n\n8.1 搭建配置中心微服务8.1.1 依赖\n8.1.2 启动类\n8.1.3 配置文件\n8.1.4 测试\n在gitee中修改了配置文件会在配置中心服务及时更新。\n\n\n8.2  获取配置中心配置\n\n 目标:改造用户微服务user-service ,配置文件信息不再由微服务项目提供,而是从配置中心获取 需求:将服务提供工程user-service的application.yml配置文件删除,修改为从配置中心config-server中获取。 实现步骤:     1.添加启动器依赖;     2.修改配置文件;     3.启动测试\n\n8.2.1 依赖\n8.2.2 删除原来配置文件application.propetes,创建bootstrap.yml\n将原来的application.yml删除;然后添加bootstrap.yml配置文件,该文件也是spring boot的默认配置文件,其内容经常配置一些项目中固定的配置项。如果是项目经常变动的应该配置到application.yml中,现在使用了配置中心则应该配置到git仓库中对于的配置文件。\n\n\n8.2.3 测试成功\n9.springcloud bus消息总线\nSpring Cloud Bus是用轻量的消息代理将分布式的节点连接起来,可以用于广播配置文件的更改或者服务的监控管理。也就是消息总线可以为微服务做监控,也可以实现应用程序之间相互通信。 Spring Cloud Bus可选的消息 理有RabbitMQ和Kafka\nSpring Cloud Bus作用:将git仓库的配置文件更新,在不重启系统的情况下实现及时同步到各个微服务。\n\n\n目标:启动RabbitMQ通过修改码云中的配置文件后发送Post请求实现及时更新用户微服务中的配置项分析需求:**在码云的git仓库中修改user-dev.yml配置文件,实现不重启user-service的情况下可以及时更新配置文件。**实现步骤:\n\n启动RabbitMQ;\n修改配置中心config-server;\n修改服务提供工程dser-service ;\n测试\n\n9.1改造配置中心9.1.1 在config-server项目的pom.xml文件中加入Spring Cloud Bus相关依赖\n9.1.2 修改配置文件\n9.3 修改服务提供工程9.3.1 添加依赖\n9.3.2 配置文件\n9.3.3 修改控制器\n9.3.4 测试git上修改完配置文件后,需要手动访问下配置中心的这个路径,才会发消息给服务获取最新配置项:\n\n\n10. springCloud综合应用\n","categories":["springCloud"],"tags":["springCloud"]},{"title":"jdk8以上提高开发效率的新特性有哪些","url":"https://www.mele.cool/2020/12/02/jdk8以上提高开发效率的新特性有哪些/","content":"1.接口的默认方法和静态方法众所周知，在接口中定义的普通方法都是抽象方法，方法前面默认都会添加public abstract，不能有方法实现，需要在接口的实现类中对方法进行具体实现。\n但是Java8开始允许在接口中定义默认方法和静态方法，对于这两种方法，可以直接在接口对其进行实现，无需再在接口实现类中进行实现。\n\n默认方法：又叫扩展方法，在方法前面需通过default修饰,不能直接通过接口调用，必须通过接口实现类的实例对象进行方法调用\n静态方法：又叫类方法，在方法前面需通过static修饰。可以直接通过接口调用。\n\n普通方法必须实现，默认方法可以选择性重写，静态方法无法重写。\n2.lambda表达式\nLambda表达式是Java8非常重要的一个新特性,其基于函数式编程的思想,支持将代码作为方法参数进行使用。可以把Lambda表达式理解为通过一种更加简洁的方式表示可传递的匿名函数。它本身没有名称,而且不像方法那样属于某一个类,但是可以有参数列表、代码体、返回值。使用了Lambda表达式之后就不需要再去编写匿名类了。\n\n2.1基础格式:(参数列表) ‐&gt; &#123;\t方法体&#125;//没有参数的Lambda表达式()‐&gt;new Student();//只有一个参数的Lambda表达式x -&gt; &#123;  System.out.println(x);  return x;&#125;//有多个参数的Lambda表达式(int x,int y)-&gt;&#123;\tSystem.out.println(x);  System.out.println(y);\treturn x+y;&#125;//上述可以进行简写，因为在Lambda中，参数列表中参数的数据类型可以交给JVM根据上下文进行推断。所以可以不用定义类型。//一个参数和仅一条语句的Lambda表达式x-&gt;3+x;//多个参数和仅一条语句的Lambda表达式(x,y) -&gt;x+y;\n2.2 Lambda表达式底层原理解析//lambda循环比较 Arrays.sort(language,(o1,o2)‐&gt;(o1.compareTo(o2)));//定义一个使用Lambda表达式的方法 public class SourceDemo &#123; \tpublic void demo()&#123; \t\tString[] language = &#123;&quot;c&quot;, &quot;c++&quot;, &quot;c#&quot;, &quot;java&quot;,&quot;python&quot;, &quot;go&quot;,&quot;hive&quot;, &quot;php&quot;&#125;; \t\tList&lt;String&gt; list = Arrays.asList(language);    list.forEach(s‐&gt; System.out.println(s));     &#125;     &#125;//将当前.java文件编译生成.class文件，执行命令后，会在当前文件夹生成对应的.class文件 javac SourceDemo.java//将.class文件进行反编译，查看文件内容 javap ‐p SourceDemo.class//  生成内容如下  Compiled from &quot;SourceDemo.java&quot;   public class com.itheima.lambda.source.SourceDemo &#123;     public com.itheima.lambda.source.SourceDemo();     public void demo();     private static void lambda$demo$0(java.lang.String);   &#125;//此时可以发现，代码中执行Lambda表达式的部分生成了一个静态私有函数。这个静态私有函数的函数干就是 Lambda表达式里面的内容。 那么对于这个静态私有函数，在JDK8内部是如何实现调用的呢？可以查看 LambdaMetafactory 类，该类下有一个 metafactory方法，lambda表达式每一次在执行的时候都会进入到这个方法中，并且为lambda表达式创建一个内 部类。//如果想查看内部类里面的内容，可以在lambda表达式执行之前，添加 System.setProperty(&quot;jdk.internal.lambda.dumpProxyClasses&quot;, &quot;D://&quot;); //这个方法会将运行时生成的内部类class文件进行输出。 当该文件生成后，可以通过 javap -c -p class文件名 查看文件中的内容//此时可以发现编译后的Lambda表达式已经被执行。\n\n综上所述，Lambda表达式在执行的时候，会调用LambdaMetafactory.metafactory动态的生成内部类，在方法 内调用 SourceDemo$&amp;Lambda$1 ，内部类里的调用方法块并不是动态生成的，只是在原class里已经编译生成了一个 静态的方法，内部类只需要调用该静态方法。 \n\n3.函数式接口\n在Java8中为了让现在有的函数能够更加友好的使用Lambda表达式，因此引入了函数式接口这个概念。其是一个 仅有一个抽象方法的普通接口。如果声明多个抽象方法则会报错。但是默认方法和静态方法在此接口中可以定义多个。\n要想自定义一个函数式接口的话，需要在接口上添加 @FunctionalInterface 。 \n在Java8的类库设计中，已经引入了几个函数式接口：Predicate、Consumer、Function、Supplier \n\n3.1 Predicate使用\nPredicate接口是Java8定义的一个函数式接口，属于java.util.function包下，内部定义一个 抽象方法test、三个默认方法and，negate，or、一个静态方法isEqual \n\nimport com.itheima.lambda.Student; import java.util.ArrayList; import java.util.List; import java.util.function.Predicate; public class MyPredicateDemo &#123;   public static List&lt;Student&gt; filter(List&lt;Student&gt; studentList, Predicate&lt;Student&gt; predicate)&#123; \t\tArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;();                                                                                         \t\tstudentList.forEach(s‐&gt;&#123; \t                                                                                      \t\tif (predicate.test(s))&#123;                                                                                        \t\t\tlist.add(s); \t  &#125;   &#125;);                                                                                               return list; &#125;  public static void main(String[] args) &#123;     List&lt;Student&gt; students = new ArrayList&lt;&gt;();     students.add(new Student(1,&quot;张三&quot;,&quot;M&quot;));     students.add(new Student(2,&quot;李四&quot;,&quot;M&quot;));     students.add(new Student(3,&quot;王五&quot;,&quot;F&quot;));     List&lt;Student&gt; result = filter(students, (s) ‐&gt; s.getSex().equals(&quot;F&quot;)); \t    System.out.println(result.toString());  &#125; &#125;\n3.2 Consumer使用\nConsumer也是JDK8提供的函数式接口，用于进行获取数据的操作，其内部定义了一个抽象方法accept、一个默 认方法andThen。\n对于accept()方法来说，它接受一个泛型T对象。如果现在需要访问类型T对象，并对其进行某些操作的话，就可以使用这个接口。 \n\nimport java.util.ArrayList;import java.util.List import java.util. function.Consumer.public class MyConsumerDemo &#123;\tpublic static void foreach(List&lt;String&gt; arrays, Consumer&lt;String&gt; consumer)&#125;\t\tarrays.forEach(s-&gt;consumer.accept (s));\t&#125;\tpublic static void main(String[] args) &#123;\t\tList&lt;string&gt; arrays = new ArrayListo&gt;();\t\tarrays.add(&quot;java&quot;);\t\tarrays. add(&quot;python&quot;);\t\tarrays.add(&quot;go&quot;);\t\tarrays.add(&quot;hive&quot;);\t\tforeach(arrays, (s)-&gt; System.out.print(s+&quot;,&quot;));\t&#125;&#125;\n3.3 Function使用\nFunction主要用于进行类型转换的操作。内部提供一个抽象方法apply、两个默认方法compose，andThen、一个 静态方法identity \n对于apply方法，它接收一个泛型T对象，并返回一个泛型R的对象\n\npackage com.example.demo.test;import java.util.function.Function;public class MyFunctionDemo &#123;    public static Integer convert(String value, Function&lt;String,Integer&gt; function)&#123;        return function.apply(value);    &#125;    public static void main(String[] args) &#123;        Integer convert = convert(&quot;666&quot;, value -&gt; Integer.valueOf(value)+222);        System.out.println(convert);    &#125;&#125;\n3.4 Supplier使用\nSupplier也是用来进行值获取操作，内部只有一个抽象方法get\n\npackage com.example.demo.test;import java.util.function.Supplier;public class MySupplierDemo &#123;    public static Integer getMin(Supplier&lt;Integer&gt; supplier)&#123;        return  supplier.get();    &#125;    public static void main(String[] args) &#123;        int[] arr = &#123;100,22,111&#125;;        Integer min1 = getMin(() -&gt; &#123;            int min = arr[0];            for (int a : arr) &#123;                if (min &gt; a) &#123;                    min = a;                &#125;            &#125;            return min;        &#125;);        System.out.println(min1);    &#125;&#125;\n3.5 类型检查**&amp;**推断\n对于Lambda表达式的类型推断，它是对Java7中的目标类型推断进行的再次扩展。在Java7中引入了 菱形操作 \n符 的概念，它可以是代码在编译时自动推断出泛型参数的类型。\n\n//全量声明 Map&lt;String,String&gt; map = new HashMap&lt;String, String&gt;(); //菱形运算符 Map&lt;String,String&gt; map1 = new HashMap&lt;&gt;();\n第二种书写代码的方式，也是我们在开发中经常使用的。不用明确声明泛型类型，代码在进行编译时，可以自动的进行类型推断。 \n那么在Java8中对于这种使用方式又进一步扩展，可以省略Lambda表达式中的所有参数类型。在编译时根据Lambda表达式的上下文信息推断出参数的正确类型。这就是所谓的类型推断。\n\n到现在为止，对于Lambda表达式都只用到了方法体里面的参数，但Lambda其实是支持使用外部定义的变量的。在下面这段代码中，在Lambda表达式内部引用了外部变量。但是当在Lambda方法体内使用外部变量时，其必须声明为final。下述代码虽然没有显示的声明，但是在Java8它自动的会对需要为final的变量进行转换。 \n\npublic void demo()&#123;   int port = 8086;   Runnable runnable = ()‐&gt; System.out.println(port); &#125;\n4. 方法引用方法引用更近一步的优化了Lambda的使用。它让代码感觉更加的自然。我们可以直接使用 :: 来简化Lambda表 达式的使用。其使用语法如下： 类名或实例名::方法名  \nstudents.sort(Comparator.comparing(Student::getId)); \n5. Stream流使用\n流操作是Java8提供一个重要新特性，它允许开发人员以声明性方式处理集合，其核心类库主要改进了对集合类的 API和新增Stream操作。Stream类中每一个方法都对应集合上的一种操作。将真正的函数式编程引入到Java中，能 让代码更加简洁，极大地简化了集合的处理操作，提高了开发的效率和生产力。 \n同时stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。在Stream**中的操作每一次都会产生新的流，内部不会像普通集合操作一样立刻获取值，而是惰性 取值，只有等到用户真正需要结果的时候才会执行。 \n\nList&lt;String&gt; result = studentList.stream()   .filter(s ‐&gt; s.getAge() &lt; 20) //过滤出年龄小于20岁的学生   .sorted(Comparator.comparing(Student::getAge)) //对结果进行排序   .map(Student::getName) // 提取出结合中的name属性   .collect(Collectors.toList());//转换成一个新的集合\n通过上述代码的执行，可以发现无需再去定义过多的冗余变量。我们可以将多个操作组成一个调用链，形成数据处理的流水线。在减少代码量的同时也更加的清晰易懂。 \n并且对于现在调用的方法，本身都是一种高层次构件，与线程模型无关。因此在并行使用中，开发者们无需再去操心线程和锁了。Stream内部都已经做好了。\nsteam流本身就是将集合的操作由外部迭代转换为了内部迭代。而内部迭代来说，它所操作的就是不是一个集合了，而是一个流。它会将所有的操作融合在流中，由其在内部进行处理，这种隐式的方式称之为内部迭代。 \n并且内部迭代支持并行处理，更利于集合操作的性能优化。其关注与对数据的计算。 \n5.1流操作详解Stream流接口中定义了许多对于集合的操作方法,总的来说可以分为两大类:中间操作和终端操作。\n\n中间操作:会返回一个流,通过这种方式可以将多个中间操作连接起来,形成一个调用链,从而转换为另外一个流。除非调用链最后存在一个终端操作,否则中间操作对流不会进行任何结果处理。\n终端操作:会返回一个具体的结果,如boolean, list, integer等。\n\n5.1.1筛选对于集合的操作，经常性的会涉及到对于集中符合条件的数据筛选，Stream中对于数据筛选两个常见的API：filter(过滤)、distinct(去重) \n//filterStream&lt;Student&gt; studentStream = studentList.stream() \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.filter(s‐&gt;s.getAge() &lt; 20); //.filter(Student::getIsPass);List&lt;Student&gt; list = studentStream.collect(Collectors.toList());//distinct 对对象进行去重的话，还需要在对象内部重写，hashCode()和equals()方法才可以实现去重。List&lt;Integer&gt; result = numberList.stream()   .filter(n ‐&gt; n % 2 == 0)   .distinct()   .collect(Collectors.toList());\n5.1..2 切片\n基于**limit()**实现数据截取,该方法会返回一个不超过给定长度的流。\n对于limit方法的实现，它会接收截取的长度，如果该值小于0，则抛出异常，否则会继续向下调用 \n\nList&lt;Integer&gt; numberList = Arrays.asList(1, 2, 3, 4, 1, 2, 3, 4); List&lt;Integer&gt; collect = numberList.stream().limit(5).collect(Collectors.toList());\n\n基于**skip()**实现数据跳过,刚才已经基于limit完成了数据截取，但是limit对于数据截取是从前往后截取几个。如果现在对结果只获取后几个怎么办呢？此时就需要使用skip()。其与limit()的使用是相辅相成的。 \n在skip方法中接收的n代表的是要跳过的元素个数，如果n小于0，抛出非法参数异常，如果n等于0，则返回当前 流。如果n小于0，才会调用makeRef()。同时指定limit参数为-1. \n\nList&lt;Integer&gt; numberList = Arrays.asList(1, 2, 3, 4, 1, 2, 3, 4); List&lt;Integer&gt; collect = numberList.stream().limit(5).skip(2).collect(Collectors.toList());\n5.1.3映射\n在对集合进行操作的时候，我们经常会从某些对象中选择性的提取某些元素的值，就像编写sql一样，指定获取表 中特定的数据列 \n#指定获取特定列  SELECT name FROM student; \n在Stream API中也提供了类似的方法，map()。它接收一个函数作为方法参数，这个函数会被应用到集合中每一个 元素上，并最终将其映射为一个新的元素。 \n\n//获取每一个学生的名字，并形成一个新的集合 List&lt;String&gt; nameList = studentList.stream()   .map(Student::getName)   .collect(Collectors.toList());//获取每一个学生名字的长度List&lt;Integer&gt; nameList = studentList.stream()  .map(Student::getName)  .map(String::length) //也可以继续向下获取每一个名称的长度   .collect(Collectors.toList());\n5.1.4匹配\n有时还需要判断集合中某些元素是否匹配对应的条件，如果有的话，在进行后续的操作。在 Stream API中也提供了相关方法供我们进行使用，如anyMatch、allMatch等。他们对应的就是&amp;&amp;和||运算符。\nanyMatch()主要用于判断流中是否至少存在一个符合条件的元素，它会返回一个boolean值，并且对于它的操作， 一般叫做短路求值 (某些操作不用操作整个流就可以得到结果:&amp;&amp;  || )\n\n//anyMatch执行时，只要流中有一个元素符合条件就会返回trueif (studentList.stream().anyMatch(s‐&gt;s.getAge()&lt;20))&#123; \t\tSystem.out.println(&quot;集合中有符合条件的学生&quot;); &#125;//allMatch会判断流中是否所有条件都符合条件，全部符合才会返回trueif (studentList.stream().allMatch(Student::getIsPass))&#123;   System.out.println(&quot;所有学生合格&quot;); &#125;else &#123;   System.out.println(&quot;有学生不合格&quot;); &#125;\n5.1.5查找\nfindany\n\n\nfifindAny用于获取流中随机的某一个元素，并且利用短路在找到结果时，立即结束。\nfifindAny对于同一数据源的多次操作会返回不同的结果。但是，如果我们的操作是串行的， 在数据较少的情况下，一般会返回第一个结果，如果在并行的情况下，那就不能确保返回的是第一个了。 \n这种设计主要是为了获取更加高效的性能\n\nOptional&lt;Student&gt; optional = studentList.stream().filter(s ‐&gt; s.getAge() &lt; 20).findAny(); if (optional.isPresent())&#123; \tSystem.out.println(optional.get()); &#125;//并行流for(int i=0;i&lt;100;i++)&#123;   Optional&lt;Student&gt; optional = studentList.parallelStream().filter(s ‐&gt; s.getAge() &lt; 20).findAny();  if (optional.isPresent())&#123;     System.out.println(optional.get());   &#125; &#125;\n\nfindFirst\n\n\nfifindFirst使用原理与fifindAny类似，但不管是在并行还是串行，指定返回流中的第一个元素。 \n\nfor(int i=0;i&lt;100;i++)&#123;   Optional&lt;Student&gt; optional = studentList     .stream()     //.parallelStream()     .filter(s ‐&gt; s.getAge() &lt; 20)     .findFirst();   if (optional.isPresent())&#123;     System.out.println(optional.get());   &#125;&#125;\n5.1.6 归约\n到现在截止，对于流的终端操作，我们返回的有boolean、Optional和List。但是在集合操作中，我们经常会涉及 对元素进行统计计算之类的操作，如求和、求最大值、最小值等，从而返回不同的数据结果。 \n\n5.1.6.1基于**reduce()**进行累积求和//第一个参数声明为初始值，第二个参数接收一个lambda表达式，代表当前流中的两 个元素，它会反复相加每一个元素，直到流被归约成一个最终结果Integer reduce = numbers.stream().reduce(0, (a, b) ‐&gt; a + b);//优化:Integer类中提供了sum方法，用于对两个数求和，这里我们可 以直接基于lambda方法调用的形式来使用Integer reduce = numbers.stream().reduce(0, Integer::sum);//继续优化:reduce方法还有一个重载方法，不需要初始化值，会返回一个 Optional对象Optional&lt;Integer&gt; optional = numbers.stream().reduce(Integer::sum);\n5.1.6.2最大值最小值//最大值Optional&lt;Integer&gt; optional = numbers.stream().reduce(Integer::max)//优化Optional&lt;Integer&gt; optional = numbers.stream().max(Integer::compareTo);//最小值Optional&lt;Integer&gt; min = numbers.stream().min(Integer::compareTo);\n5.2构建流\n难道Stream只能在集合基础上才能操作么？当然不是，我们还可以基于值、数组甚至文件来构建流，完成流操作。\n\n5.2.1基于值创建流\n在Stream中提供了一个静态方法of，它可以接收任意数量参数，显式的创建一个流。并且会根据传入的参数类 型，构建不同泛型的流。\n其内部就是基于Arrays中的stream方法将传入的多个参数转换为数组，然后创建流，并遍历数组，将每一个元素放入流中。\n\nStream&lt;String&gt; stringStream = Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;); Stream&lt;Object&gt; stream = Stream.of(&quot;1&quot;, &quot;2&quot;, 3,true,new St());\n5.2.2基于数组创建流Integer[] numbers = new Integer[]&#123;1,2,3,4,5,6&#125;;Stream&lt;Integer&gt; integerStream = Arrays.stream(numbers);\n5.2.3基于文件创建流\n在Java中 提供了Files类，该类中提供了一些对于文件操作的相关方法。可以看下Files类中部分方法\n在该类中部分方法返回值就是Stream，如：newDirectoryStream、list、lines等。 \n\n\n5.3收集器\n对于数据的返回，我们返回的都是一些简单的数据类型。那现在我们要做一些复杂的数据返回，应该怎么做呢？ 比方说返回一个Map或者Map。就需要通过收集器来实现了\n其内部主要核心是通过Collectors完成更加复杂的计算转换，从而获取到最终结果。并且Collectors内部提供了非常多的常用静态方法，直接拿来就可以了。比方说：toList。 \n\n//根据年龄进行分组Map&lt;Integer, List&lt;Student&gt;&gt; map = studentList.stream().collect(Collectors.groupingBy(Student::getAge));\n5.3.1 通过**counting()**统计集合总数Long collect = studentList.stream().collect(Collectors.counting());//简写long count = studentList.stream().count();\n5.3.2 通过maxBy()**与minBy()**获取最大值最小值//获取年龄最大的学生 Optional&lt;Student&gt; optional = studentList.stream().collect(Collectors.maxBy(Comparator.comparing(Student::getAge)));//优化Optional&lt;Student&gt; studentOptional = studentList.stream().max(Comparator.comparing(Student::getAge));//获取年龄最小的学生 Optional&lt;Student&gt; studentOptional = studentList.stream().min(Comparator.comparing(Student::getAge));\n5.3.3 通过**summingInt()**进行数据汇总//获取年龄总和Integer collect = studentList.stream().collect(Collectors.summingInt(Student::getAge));//简化int sum = studentList.stream().mapToInt(Student::getAge).sum();\n5.3.4 通过**averagingInt()**进行平均值获取Double collect = studentList.stream().collect(Collectors.averagingInt(Student::getAge));//另外一种 这种方式虽然代码写多了一些，但是可以防止空值的出现。OptionalDouble average = studentList.stream().mapToDouble(Student::getAge).average(); if (average.isPresent())&#123;   double asDouble = average.getAsDouble();   System.out.println(asDouble); &#125;\n5.3.5复杂结果返回\n到此截止，已经通过收集器完成了汇总、求和、求最大最小值、求平均值的操作。但是值得注意的是，这些操作每 一次都是返回单独的一个值，但是日常开发中，经常需要获取多种内容，那这种需求应该如何完成？Collectors也 提供了相关静态方法进行解决，这三个方法可以，返回的都是收集器。其内部已经包含了多种结果内容 \n上述方法返回了IntSummaryStatistics类，其内部提供了相关getter方法用于获取汇总值、总和、最大值最小值等 方法，直接调用即可 \n对于另外的summarizingDouble()和summarizingLong()使用方式都是相同的。只不过他们适用于收集属性数据类 型为double和long而已。 \n\nIntSummaryStatistics collect = studentList.stream().collect(Collectors.summarizingInt(Student::getAge));long count = collect.getCount(); long sum = collect.getSum(); int max = collect.getMax(); int min = collect.getMin(); double average = collect.getAverage();\n5.3.6通过**joining()**进行数据拼接String collect = studentList.stream().map(Student::getName).collect(Collectors.joining());String collect = studentList.stream().map(Student::getName).collect(Collectors.joining(&quot;,&quot;));\n5.3.7 分组//一级分组 根据年龄分组Map&lt;Integer, List&lt;Student&gt;&gt; map = studentList.stream().collect(Collectors.groupingBy(Student::getAge))//根据年龄 是否通过进行多级分组Map&lt;Integer, Map&lt;String, List&lt;Student&gt;&gt;&gt; collect = studentList.stream().collect(Collectors.groupingBy(Student::getAge, Collectors.groupingBy(student ‐&gt; &#123;   if (student.getIsPass()) &#123;     return &quot;pass&quot;;   &#125; else &#123;     return &quot;not pass&quot;;   &#125; &#125;)));//多级分组变形 //根据年龄进行分组，获取并汇总人数 Map&lt;Integer, Long&gt; collect = studentList.stream().collect(Collectors.groupingBy(Student::getAge, Collectors.counting())); //根据年龄与是否及格进行分组，并汇总人数Map&lt;Integer, Map&lt;Boolean, Long&gt;&gt; collect = studentList.stream().collect(Collectors.groupingBy(Student::getAge, Collectors.groupingBy(Student::getIsPass, Collectors.counting())));//根据年龄与是否及格进行分组，并获取每组中分数最高的学生Map&lt;Integer, Map&lt;Boolean, Student&gt;&gt; collect = studentList.stream().collect( Collectors.groupingBy(Student::getAge,                                                                                                \t\tCollectors.groupingBy(Student::getIsPass,                                                                                                                      \t\t\tCollectors.collectingAndThen(                                                                                                                        \t\t\t\tCollectors.maxBy(                                                                                                                          \t\t\t\t\t\tComparator.comparing(Student::getScore)), Optional::get))));\n5.3.8 自定义收集器\n根据源码，Collector接口需要三个参数。T：流中要收集的元素类型、A：累加器的类型、R：收集的结果类型。 \n如想自定义收集器，需要实现Collector接口中的五个方法：supplier、accumulator、fifinisher、combiner、 \ncharacteristics \n\nsupplier：用于创建一个容器，在调用它时，需要创建一个空的累加器实例，供后续方法使用。 \n\naccumulator：基于supplier中创建的累加容器，进行累加操作。 \n\nfifinisher：当遍历完流后，在其内部完成最终转换，返回一个最终结果。 \n\ncombiner：用于在并发情况下，将每个线程的容器进行合并。 \n\ncharacteristics：用于定义收集器行为，如是否可以并行或使用哪些优化。其本身是一个枚举，内部有三个值，分别为： \nCONCURRENT：表明收集器是并行的且只会存在一个中间容器。 \nUNORDERED：表明结果不受流中顺序影响，收集是无序的。 \nIDENTITY_FINISH：表明累积器的结果将会直接作为归约的最终结果，跳过fifinisher()。 \n\n\n\n自定义收集器，返回所有合格的学员:\n\n使用自定义收集器 :\n\n6.数据并行化\n为了让数据处理更加高效，Java8对于Stream也提供了并行的操作方式，在Java7之前如果要对数据并行处理，需要开发人员做的事情很多，如数据如何进行分块、开启多少个线程、哪个线程负责哪部分数据、出现线程竞争怎么办等等的问题。 \nJava8对于数据并行化处理的实现非常简单，直接调用一个parallelStream()就可以开启并行化处理。\n\n并行：多个任务在同一时间点发生，并由不同的cpu进行处理，不互相抢占资源\n并发：多个任务在同一时间点内同时发生了，但由同一个cpu进行处理，互相抢占资源\n\n当在大量数据处理上，数据并行化可以大量缩短任务的执行时间，将一个数据分解成多个部分，然后并行处理，最后将多个结果汇总，得到最终结果。 \nint sum = numbers.parallelStream().mapToInt(i ‐&gt; i).sum(); \n当将stream()切换为parallelStream()后，则完成了串行转换为并行的实现。 \n\n6.1并行流原理对于并行流，其在底层实现中，是沿用了Java7提供的fork/join分解合并框架进行实现。fork根据cpu核数进行数据分块，join对各个fork进行合并。实现过程如下所示：\n\n6.2并行流注意事项对于并行流，一定不要陷入一个误区：并行一定比串行快。并行在不同的情况下它不一定是比串行快的。影响并行流性能主要存在5个因素： \n1）数据大小：输入数据的大小，直接影响了并行处理的性能。因为在并行内部实现中涉及到了fork/join操作，它本身就存在性能上的开销。因此只有当数据量很大，使用并行处理才有意义。 \n2）源数据结构：fork时会对源数据进行分割，数据源的特性直接影响了fork的性能。 \n\nArrayList、数组或IntStream.range，可分解性最佳，因为他们都支持随机读取，因此可以被任意分割。 \nHashSet、TreeSet，可分解性一般，其虽然可被分解，但因为其内部数据结构，很难被平均分解。 \nLinkedList、Streams.iterate、BufferedReader.lines，可分解性极差，因为他们长度未知，无法确定在哪里进行分割。 \n\n3）装箱拆箱 \n\n尽量使用基本数据类型，避免装箱拆箱。 \n\n4）CPU核数 \n\nfork的产生数量是与可用CPU核数相关，可用的核数越多，获取的性能提升就会越大。 \n\n5）单元处理开销 \n\n花在流中每个元素的时间越长，并行操作带来的性能提升就会越明显。 \n\n6.3结论*根据性能测试可知，对于简单操作，如果环境机是多核的话，建议使用Stream并行，同时在不考虑核数的情况下，普通for循环性能要明显高于Stream串行，相差两倍左右。**\n对于复杂操作，推荐使用Stream API操作。 \n7.异步编程CompletableFuture\n在现在软件开发的环境下，经常需要考虑如何能够设计出性能更加优异的系统。就像上面提到的数据并行化，就 是充分利用多核处理器结合并行操作来让代码执行效率更加优异。第二种方式就是让功能方法能够并行执行(异步编程CompletableFuture)。 \n\n7.1Future介绍有的同学会说，对于任务并行需求，直接通过多线程实现不就可以了， 要注意，对于多线程的实现，java提 供了三种方式：继承Thread类、实现Runnable接口和实现Callable接口。但是业务代码在执行时会考虑执行顺序 的问题，直接基于这些方式实现多线程会出现两个问题： \n1）要想控制线程执行顺序，会通过join()等待线程结束，那这样的话又回归到了阻塞式调用的思路上，违背了并行的需求。 另外还可以通过wait()、notify()、notifyAll()结合状态变量实现，但实现起来过于复杂。 \n2）线程执行完之后，要想获取线程执行结果，还要用过共享变量或线程间通信等方式来获取，同样过于复杂。 为了解决上述问题，Java5中推出了Future，其初衷就是用于构建复杂并行操作。内部方法在返回时，不是返回一个值，而是返回Future对象。 其本质是在执行主业务的同时，异步的执行其他分业务，从而利用原本需要同步执行时的等待时间去执行其他的业 务，当需要获取其结果时，再进行获取。 \n在Future接口中有五个抽象方法： \n\ncancel()：取消任务, 取消成功返回true；入参mayInterruptIfRunning表示是否允许取消正在执行中的任务。 \nisCancelled()：返回布尔值，代表是否取消成功。\nisDone()：返回布尔值，代表是否执行完毕。 \nget()：返回Future对象，获取执行结果，如果任务没有完成会阻塞到任务完成再返回。 \nget(long timeout, TimeUnit unit)：获取执行结果并设置超时时间，如果超时则抛出TimeoutException \n\n7.2CompletableFutureCompletableFuture是Java1.8提供的一个新类，其实现了Future与CompletionStage两个接口。提供了诸多API扩展功能，可以通过Stream形式简化异步编程的复杂度，同时提供通过回调方式处理计算结果。\n7.2.1 异步任务创建在CompletableFuture中提供了四个静态方法用于创建异步任务 \n//根据源码可知，runAsync()分为一个参数和两个参数，并且其内部都会调用asyncRunStage().//在该方法内部会创建异步任务，并把任务放入线程池中。并且runAsync()是没有返回值的。//根据源码可知，当传入Executor会使用指定线程池执行，如果没有传入则使用默认ForkJoinPool.commonPool()执 行，值得注意的是，commonPool中都是守护线程，主线程执行完，子线程也就over了。因此建议当任务非常耗 时，使用自定义线程池。1.runAsync(Runnable runnable) 2.runAsync(Runnable runnable,Executor executor) //根据源码可知，supplyAsync()分为一个参数和两个参数，并且其内部都会调用asyncSupplyStage().  //现在可知，其实supplyAsync()与runAsync()内部原理类似，但supplyAsync()有返回值。3.supplyAsync(Supplier&lt;U&gt; supplier) 4.supplyAsync(Supplier&lt;U&gt; supplier,Executor executor)  \n使用示例:\n\n7.2.2 异步计算结果触发回调\n当异步任务结束或者抛出异常时，还要根据结果来完成特定的操作，对于这种需求CompletableFuture也提供了方法进行实现 \n\n7.2.2.1whenComplete()**与whenCompleteAsync()**whenComplete是在当前任务线程中继续执行指定的特定处理，而whenCompleteAsync会将指定的特定交给线程池另开启一个线程来执行。\n\n7.2.2.2 exceptionally()\nexceptionally()与上述两个方法类似，都是用于当异步任务结束后，执行特定处理，但不同的是，上述两个方法即 可以处理正常的返回结果也可以处理异常，而exceptionally()只对异常进行处理，且其使用的是主线程。\n\n\n7.2.3 多任务依赖执行7.2.3.1 thenApply()\n该方法会接收一个Function，用于声明后续要执行的业务，其中T代表上一个方法的执行结果，fn代表当前任务的 结果数据类型，最终其会映射到CompletableFuture中的结果数据类型。 \n\n\n根据运行结果可以看到，此处通过thenApply()串接了两个任务，第二个方法会在第一个方法执行完成后触发，且第二个方法的执行依赖于第一个方法的执行结果。 \n7.2.3.2 handle()\nhandle()的使用效果与thenApply()类似，但不同的是thenApply()只能处理任务的正常返回结果，一旦出现异常则 无法进行后续处理。而handle()即可以处理正常结果，也可以处理异常结果。\n当第一个任务出现异常后，第二个任务会对该异常进行后续的处理，完成串性操作。\n\n\n7.2.3.3 thenAccept()\n当将多个任务连接起来执行时，有时最终是不需要返回结果，CompletableFuture中也提供了方法实现。 thenAccept()使用与上述方法类似，接收任务执行结果，并使用，但其没有结果返回。 \n\n\n7.2.3.4  thenRun()\nthenRun()与thenAccept()使用基本相同，都是不会进行结果返回，但不同的是，thenRun()不关心方法是否有结 果，只要它完成，就会触发其执行。\n\n\n7.2.4 两任务合并执行7.2.4.1 两个任务全部完成触发7.2.4.1.1 thenCombine()\n当两个异步任务都执行完毕后，它可以将两个任务进行合并，获取到两个任务的执行结果，进行合并处理，最后会有返回值。 \n内部会判断当前要执行的函数是否为null，或者任务有没有执行完。如果为true，则抛出空指针异常。接着会构建 一个新的任务，将任务放入栈中，线程池会为其分配线程让其执行。 \n\n\n7.2.4.1.2 thenAcceptBoth()\nthenAcceptBoth()使用与thenCombine()类似，当两个任务执行完，获取两个任务的结果进行特定处理，但 thenAcceptBoth()没有返回值 \n\n\n7.2.4.1.3 runAfterBoth()\n当两个任务执行完毕，触发特定任务处理，但不要两个异步任务结果，且不会进行值返回。\n\n\n7.2.4.2 两个任务任意一个完成触发7.2.4.2.1 applyToEither()\n当两个任务异步任务执行，谁先执行完，就以谁的结果为准，完成后续的业务处理，并且会进行结果值返回。\n\n\n7.2.4.2.2 acceptEither()\nacceptEither()的使用效果与applyToEither()类似，但acceptEither()没有返回值\n\n\n7.2.4.2.3 runAfterEither()\n当两个任务执行，只要有一个任务执行完，则触发特定处理执行，无需使用异步任务的执行结果，且特定处理不会进行值的返回。\n\n\n7.2.5 多任务组合执行7.2.5.1 allOf()\n当一个特定业务处理任务的执行需要一组异步任务完成后才能执行的话，就可以通过allOf()实现。适用场景：假设现在有一个Z任务，它的执行需要[A,B,C,D,E,F]这一组异步任务全部执行完才能触发。 \n\n\n7.2.5.2 ）anyOf()\n使用anyOf()时，当一组异步任务中，只要有一个执行完毕，则会被触发，利用该特性可以用来获取最快的那个线程结果。 \n\n\n8.Optional\n为了防止空指针异常的出现，Java8中引入了一个新类Optional，对于它之前我们已经进行了简单的实现。其本质 就是通过Optional类对值进行封装， 当有值的时候，会把该值封装到Optional类中。如果没有值的话，则会在该 类封装一个Empty \n\n8.1 创建optional对象//直接返回一个空的Optional实例，内部不会存在任何值。Optional&lt;Student&gt; studentOptional = Optional.empty(); //返回一个存在值的Optional对象，并且该值不允许null的存在。如果调用该方法时传入参数 是null，则立刻抛出NullPointerException，而不是等到你用这个对象时才抛出，相当于进行了立即检查。Optional&lt;Student&gt; studentOptional = Optional.of(student);//ofNullable()同样也会返回一个存在值的Optional对象，但是它和of()最大的不同在于，它会对传入 的值进行判断，如果传入的值为null，其会调用empty()返回一个不包含内容的Optional，如果不为null，则会调用 of()返回一个包含内容的OptionalOptional&lt;Student&gt; studentOptional = Optional.ofNullable(student);\n8.2基于optional对象获取值\nOptional类中提供了两个方法用于判断Optional是否有值，分别是isPresent()和ifPresent(Consumer&lt;? super T&gt; consumer)**。其一般与ofNullable()搭配使用**，因为of()在创建时已经完成了判断，而empty()只是单纯了实例化了 一个Optional对象。 \n\n\n**isPresent()**内部非常简单，就是判断这个值是否为null。 \nOptional&lt;Student&gt; studentOptional = Optional.ofNullable(student); if (studentOptional.isPresent())&#123; //存在   System.out.println(&quot;student存在&quot;); &#125;else &#123;   System.out.println(&quot;student不存在&quot;); &#125;\n\n\n**ifPresent()**方法在执行时，接收一个consumer函数式接口，如果value不为null，则通过consumer中的 \naccept方法获取该值。 \nOptional&lt;Student&gt; studentOptional = Optional.ofNullable(student); studentOptional.ifPresent(s‐&gt; System.out.println(&quot;学生存在&quot;));\n\nget()\n\nget()的使用非常简单，但不安全，因为其在获取值的时候，如果值存在，则直接返回封装在Optional中的值，如 果不存在，则抛出NoSuchElementException。因此它的使用前提是已经确定Optional中有值，否则没有使用意义。\n\n\n\nif (studentOptional.isPresent())&#123; \tStudent result = studentOptional.get(); &#125;\n\norElseThrow()\n\n\n该方法与get()类似，都是用于取值，但是当Optional中没有值时，get()会直接抛出NoSuchElementException， 这样的话，就存在了一定的局限性，因为有时可能需要抛出自定义异常。此时就可以使用orElseThrow()，它在取值时，如果Optional中没有值时，可以抛出自定义异常。 \n\n\n\n\n\nmap()\n\nif (studentOptional.isPresent())&#123;\t\tOptional&lt;String&gt; nameOptional = studentOptional.map(Student::getName);\t&#125;\n\nflflatMap()\n//Student类添加Job属性 private Optional&lt;Job&gt; job; //Job类添加Company属性 private Optional&lt;ComPany&gt; comPany;\n\n用于多层调用，同时对于结 果它不会形成多个Optional，而是将结果处理成最终的一个类型的Optional。但是通过flflatMap获取的返回值必须是Optional类型。而map则没有这个限制。\n\n\n\nOptional&lt;String&gt; nameOptional = studentOptional.flatMap(Student::getJob).flatMap(Job::getCompany).map(Company::getName);\n\nfifilter()\n\n\n会根据传入的条件进行判断，如果匹配则返回一个Optional对象并包含对应的值，否则返回一个空值的Optional \n\nOptional&lt;Company&gt; company = companyOptional.filter(c ‐&gt; &quot;itheima&quot;.equals(c.getName()));\n\norElse()\n\n\n在取值的时候，如果值不存在，有时我们会考虑返回一个默认值。该需求就可以通过orElse()实现。 其内部会判断值是否为null，如果不为null，则返回该值，如果为null，则返回传入的默认值。 \n\n\n\norElseGet()\n\n\norElseGet()也是用于当Optional中没有值时，返回默认值的方法。但是它与orElse()的区别在于，它是延迟加载 的。只有当Optional中没有值是才会被调用。\n在使用时，更加推荐使用orElseGet()，因为它使用延迟调用所以性能更加优异。 \n\n\n9.日期时间新方式\nSimpleDateFormat本身是线程不安全的，在多线程环境下，如果多个线程使用同一个类解析日期，最后的结果是 无法预期的。同时继承了它的DateFormat类也不是线程安全的。 \nDateTimeFormatter 该类是不可变和线程的。该类中提供了很多方法用于替换SimpleDateFormat。基于DateTimeFormatter改造\n\n\nLocalDate介绍 根据源码可知，该类是一个不可变，线程安全的类。其内部了提供了若干用于操作日期的方法\nLocalTime介绍 LocalTime类可以用来操作时间\nLocalDateTime介绍 LocalDateTime类可以用来操作日期+时间。\n\n10.jdk11新特性1）变量类型推断在JS中，不管类型是什么，我们都是使用var来进行变量声明的。但是之前对于Java的使用，都会提到它是强类型语言，变量声明需要定义特定类型。但是在JDK11中对JDK8的类型推断思路又得以延伸，使用JS的方式，通过var定义局部变量，它会根据右边的表达式推断变量类型 \nvar text = &quot;hello itheima&quot;; sout(text);\n2）新增字符串方法\n3）新增创建集合的方式JDK11提供了通过of()和copyOf()创建集合的方式，但是创建的集合长度不可变，不能进行任何修改操作，of()会直接创建，而copyOf()首先会判断传入的集合是否为不可变集合，是的话直接返回，不是的话，调用of()创建新集合并返回。 \nvar list = List.of(&quot;hello&quot;,&quot;itheima&quot;); var arrayList = new ArrayList&lt;String&gt;(); var list2 = List.copyOf(arrayList); \n4）Files类增强在Files类中新增两个方法：writeString和readString。可以把String内容写入文件或者把整个文件以String读出 \nFiles.writeString( Path.of(&quot;./&quot;, &quot;demo.txt&quot;), &quot;hello,itheima&quot;, &quot;utf‐8&quot;); String info = Files.readString(Paths.get(&quot;./demo.txt&quot;), &quot;utf‐8&quot;); \n\n\n5）HTTP Client Api平时我们要去访问HTTP资源，大多数时间我们都是通过第三方完成的，虽然在JDK标准类库中有HttpURLConnection，但是也不太好用。 在JDK9就提出了HTTP Client Api，经过9，10两个版本的改进，在11中正式发布。其同时支持同步请求和异步请 求。\nvar request = HttpRequest.newBuilder().uri(URI.create(&quot;http://www.itcast.cn&quot;)) .POST() .build(); var client = HttpClient.newHttpClient(); // 同步 HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response.body()); // 异步 client.sendAsync(request, HttpResponse.BodyHandlers.ofString()) .thenApply(HttpResponse::body) .thenAccept(System.out::println);\n6）更方便的编译运行#之前 javac Demo.java java Demo #现在 java Demo.java ","categories":["java"],"tags":["jdk8 - java"]},{"title":"多线程及调优","url":"https://www.mele.cool/2020/12/02/多线程及调优/","content":"1.多线程 J.U.C1.1 线程池1.1.1线程的状态:\n\nNEW：刚刚创建，没做任何操作 \n\nThread thread = new Thread(); System.out.println(thread.getState()); \n\nRUNNABLE：调用run，可以执行，但不代表一定在执行（RUNNING,READY） \n\nthread.start(); System.out.println(thread.getState());\n\nBLOCKED：抢不到锁 \n\npublic static void main(String[] args) throws InterruptedException &#123;  \t\t//这种对象作为锁对象系统消耗最低        final byte[] lock = new byte[0];        Thread thread1 = new Thread(new Runnable() &#123;            public void run() &#123;                synchronized (lock) &#123;                    try &#123;                        Thread.sleep(3000);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;);        thread1.start();        Thread thread2 = new Thread(new Runnable() &#123;            public void run() &#123;                synchronized (lock) &#123;                &#125;            &#125;        &#125;);        thread2.start();        Thread.sleep(1000);        System.out.println(thread1.getState());//TIMED_WAITING        System.out.println(thread2.getState());//BLOCKED    &#125;\n\nWAITING\n\npublic static void main(String[] args) throws InterruptedException &#123;       Thread thread2 = new Thread(new Runnable() &#123;           public void run() &#123;               LockSupport.park();           &#125;       &#125;);       thread2.start();       Thread.sleep(500);       System.out.println(thread2.getState());       LockSupport.unpark(thread2);       Thread.sleep(500);       System.out.println(thread2.getState());   &#125;\n\nTIMED_WAITING\n\nThread thread3 = new Thread(new Runnable() &#123;           public void run() &#123;               try &#123;                   Thread.sleep(10000);               &#125; catch (InterruptedException e) &#123;                   e.printStackTrace();               &#125;           &#125;       &#125;);       thread3.start();       Thread.sleep(500);       System.out.println(thread3.getState());\n\nTERMINATED\n\n//等待1s后再来看Thread thread = new Thread(new Runnable() &#123;    @Override    public void run() &#123;        System.out.println(&quot;aaa&quot;);    &#125;&#125;);thread.start();Thread.sleep(1000);System.out.println(thread.getState());\n1.1.2常用线程池类结构\n可以通过idea查看到 （查看：ScheduledThreadPoolExecutor，ForkJoinPool类图） \n\n\n\n最常用的是ThreadPoolExecutor \n调度用ScheduledThreadPoolExecutor,完美取代Timer\n任务拆分合并用ForkJoinPool \nExecutors是工具类，协助你创建线程池的 \n\n1.1.3 线程池工作机制及状态\n在线程池的编程模式下，任务是提交给整个线程池，而不是直接提交给某个线程，线程池在拿到任务后，就在内部协调空闲的线程，如果有，则将任务交给某个空闲的线程。一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。 \n\n线程池状态:\n\n\nRUNNING：初始化状态是RUNNING。线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0。RUNNING状态下，能够接收新任务，以及对已添加的任务进行处理。 \n\nSHUTDOWN：SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN\n\nSTOP：不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。调用线程池的shutdownNow()接口时，线程池由(RUNNING 或 SHUTDOWN ) -&gt; STOP \n注意：运行中的任务还会打印，直到结束，因为调的是Thread.interrupt\n\nTIDYING：所有的任务已终止，队列中的”任务数量”为0，线程池会变为TIDYING。线程池变为TIDYING状态时，会执行钩子函数terminated()，可以通过重载terminated()函数来实现自定义行为\npackage com.example.demo.test;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;//源码中ThreadPoolExecutor的terminated方法是个空方法,如果需要在线程池结束时实现自己的业务逻辑,改写线程池类MyExecutorService可重写此方法.//自定义类，重写terminated方法 public class MyExecutorService extends ThreadPoolExecutor &#123;    public MyExecutorService(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);    &#125;    @Override    protected void terminated() &#123;        super.terminated();        System.out.println(&quot;treminated&quot;);    &#125;        //调用 shutdownNow， ternimated方法被调用打印     public static void main(String[] args) throws InterruptedException &#123;        MyExecutorService service = new MyExecutorService(1, 2, 10000, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(5));        service.shutdownNow();    &#125;&#125;\n\n\nTERMINATED：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED \n\n\n1.1.4 线程池结构\n\n添加任务，如果线程池中线程数没达到coreSize，直接创建新线程执行 \n达到core，放入queue \nqueue已满，未达到maxSize继续创建线程 \n达到maxSize(最大为Integer.max)，根据reject策略处理 \n超时后，非核心线程被释放，下降到coreSize \n\n源码解析:\n\n核心线程与非核心线程有区别吗?答案:没有。被销毁的线程和创建的先后无关。即便是第一个被创建的核心线程,仍然有可能被销毁验证:看源码,每个works在runWork的时候去getTask,在getTask内部,并没有针对性的区分当前work是否是核心线程或者类似的标记。只要判断works数量超出core,就会调用pollo),否则take()\n1.1.5 Executors工具以上构造函数比较多，为了方便使用，提供了一个Executors工具类 \n实际开发建议使用上面ThreadPoolExecutor构造函数\n\n1）newCachedThreadPool() ： 弹性线程数 \n2）newFixedThreadPool(int nThreads) ： 固定线程数 \n3）newSingleThreadExecutor() : 单一线程数 \n4）newScheduledThreadPool(int corePoolSize) ： 可调度，常用于定时 \n\n1.2 锁\n锁是一种互斥的机制，在多线程环境中实现对资源的协调与控制，凡是有资源被多线程共享，涉及到你改我改的情况就要考虑锁的加持。 \n\n1.2.1 锁的实现方式.1）synchronized//synchronized包裹的代码段执行完会自动释放锁,但是lock需要手动释放,所以如果使用lock时中间有try catch需要在finnaly中手动释放锁,否则会一直占用锁public synchronized void inc() \n2）LockLock lock = new ReentrantLock(); public void inc() &#123; \tlock.lock(); \t//... \tlock.unlock(); &#125;\n以上两种方式性能太差.\n1.2.2 锁的分类1.2.2.1 乐观锁/悲观锁乐观锁顾名思义，很乐观的认为每次读取数据的时候总是认为没人动过，所以不去加锁。但是在更新的时候回去对比一下原来的值，看有没有被别人更改过。适用于读多写少的场景。 \n\nmysql中类比version号更新 update xxx set a=aaa where id=xx and version=1 \njava中的atomic包属于乐观锁实现，即CAS（下节会详细介绍） \n\n悲观锁在每次读取数据的时候都认为其他人会修改数据，所以读取数据的时候也加锁，这样别人想拿的时候就会阻塞，直到这个线程释放锁，这就影响了并发性能。适合写操作比较多的场景。 \n\nmysql中类比for select xxx for update; update update xx set a = aaa \n案例中synchronized实现就是悲观锁（1.6之后优化为锁升级机制），悲观锁书写不当很容易影响性能（性能部分会讲到） \n\n1.2.2.2 独享锁**/**共享锁独享锁是指该锁一次只能被一个线程所持有，而共享锁是指该锁可被多个线程所持有。 \nsynchronized,ReentrantLock,ReentrantReadWriteLock的writelock都是独享锁.\n\n案例一：ReentrantLock，独享锁\n\nimport java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class PrivateLock &#123;    Lock lock = new ReentrantLock();    long start = System.currentTimeMillis();    void read() &#123;        lock.lock();        try &#123;            Thread.sleep(100);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;        System.out.println(&quot;read time = &quot; + (System.currentTimeMillis() - start));    &#125;    public static void main(String[] args) &#123;        final PrivateLock lock = new PrivateLock();        for (int i = 0; i &lt; 10; i++) &#123;            new Thread(new Runnable() &#123;                public void run() &#123;                    lock.read();                &#125;            &#125;).start();        &#125;    &#125;&#125;//结果分析：每个线程结束的时间点逐个上升，锁被独享，一个用完下一个，依次获取锁\n\n案例二：ReadWriteLock，read共享，write独享\n\nimport java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantReadWriteLock;public class SharedLock &#123;    ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();    Lock lock = readWriteLock.readLock();    long start = System.currentTimeMillis();    void read() &#123;        lock.lock();        try &#123;            Thread.sleep(100);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;        System.out.println(&quot;end time = &quot; + (System.currentTimeMillis() - start));    &#125;    public static void main(String[] args) &#123;        final SharedLock lock = new SharedLock();        for (int i = 0; i &lt; 10; i++) &#123;            new Thread(new Runnable() &#123;                public void run() &#123;                    lock.read();                &#125;            &#125;).start();        &#125;    &#125;&#125;//结果分析：每个线程独自跑，各在100ms左右，证明是共享的\n\n案例三：同样是上例，换成writeLock \n\nLock lock = readWriteLock.writeLock();//结果分析：恢复到了1s时长，变为独享\n小结:\n\n读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。 \n独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。 \n\n1.2.2.3分段锁\n从Map一家子说起…. \nHashMap是线程不安全的，在多线程环境下，使用HashMap进行put操作时，可能会引起死循环，导致CPU利用 率接近100%，所以在并发情况下不能使用HashMap。 \n于是有了HashTable，HashTable是线程安全的。但是HashTable线程安全的策略实在不怎么高明，将get/put等所 有相关操作都整成了synchronized的。\n那有没有办法做到线程安全，又不这么粗暴呢？基于分段锁的ConcurrentHashMap诞生… \n\nConcurrentHashMap使用Segment（分段锁）技术，将数据分成一段一段的存储，Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，Segment数组中每一个元素一把锁，每一个Segment元素存储的是HashEntry数组+链表，这个和HashMap的数据存储结构一样。当访问其中一个段数据被某个线程加锁的时候，其他段的数据也能被其他线程访问，这就使得ConcurrentHashMap不仅保证了线程安全，而且提高了性能。 \n但是这也引来一个负面影响：ConcurrentHashMap 定位一个元素的过程需要进行两次Hash操作，第一次 Hash定位到 Segment，第二次 Hash 定位到元素所在的链表。所以 Hash 的过程比普通的 HashMap 要长。\n备注：JDK1.8ConcurrentHashMap中抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。 \n1.2.2.4 可重入锁可重入锁指的获取到锁后，如果同步块内需要再次获取同一把锁的时候，直接放行，而不是等待。其意义在于防止死锁。前面使用的synchronized 和ReentrantLock 都是可重入锁。 \n实现原理是通过为每个锁关联一个请求计数器和一个占有它的线程。如果同一个线程再次请求这个锁，计数器将递增，线程退出同步块，计数器值将递减。直到计数器为0锁被释放。 \n场景见于父类和子类的锁的重入（调super方法），以及多个加锁方法的嵌套调用\n案例一：父子可重入 \npublic class ParentLock &#123;    byte[] lock = new byte[0];    public void f1() &#123;        synchronized (lock) &#123;            System.out.println(&quot;f1 from parent&quot;);        &#125;    &#125;&#125;\npublic class SonLock extends ParentLock &#123;    public void f1() &#123;        synchronized (super.lock) &#123;            super.f1();            System.out.println(&quot;f1 from son&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        SonLock lock = new SonLock();        lock.f1();    &#125;&#125;\n案例二：内嵌方法可重入\npublic class NestedLock &#123;    public synchronized void f1() &#123;        System.out.println(&quot;f1&quot;);    &#125;    public synchronized void f2() &#123;        f1();        System.out.println(&quot;f2&quot;);    &#125;    public static void main(String[] args) &#123;        NestedLock lock = new NestedLock(); //可以正常打印 f1,f2         lock.f2();    &#125;&#125;\n案例三：不可重入锁的典型错误，不要这么做！！！ \npublic class BadLock &#123;    Lock lock = new Lock();    public void f1() &#123;        System.out.println(&quot;f1&quot;);        lock.lock();        f2();        lock.unlock();    &#125;    public void f2() &#123;        lock.lock();        System.out.println(&quot;f2&quot;);        lock.unlock();    &#125;    public static void main(String[] args) &#123;        BadLock badLock = new BadLock();        //理论上，会打印 f1 和 f2 实际上，这个错误的设计会导致卡死在f1         badLock.f1();    &#125;    //自定义的锁，现实中不要这么做！！！     class Lock &#123;        private boolean isLocked = false;        public synchronized void lock() &#123;            try &#123;                //想要拿锁，一直判断标记，如果被占就wait等待                 while (isLocked) &#123;                    wait();                &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            //一旦被唤醒，退出while了，自己拿到锁，将标记改为true（已占用）             isLocked = true;        &#125;        public synchronized void unlock() &#123;            //占用标记改成false             isLocked = false;            //同时唤醒等待锁的线程             notify();        &#125;    &#125;&#125;\n1.2.2.5 公平锁**/**非公平锁AQS既能实现公平锁,也能实现非公平锁.\n概念:\n常见于AQS，公平锁就是在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，直到按照FIFO的规则从队列中取到自己。\n非公平锁与公平锁基本类似，只是在放入队列前先判断当前锁是否被线程持有。如果锁空闲，那么他可以直接抢占，而不需要判断当前队列中是否有等待线程。只有锁被占用的话，才会进入排队。 \n优缺点： \n公平锁的优点是等待锁的线程不会饿死，进入队列规规矩矩的排队，迟早会轮到。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。 \n非公平锁的性能要高于公平锁，因为线程有几率不阻塞直接获得锁。ReentrantLock默认使用非公平锁就是基于性能考量。但是非公平锁的缺点是可能引发队列中的线程始终拿不到锁，一直排队被饿死。 \n编码方式： \n很简单，ReentrantLock支持创建公平锁和非公平锁（默认），想要实现公平锁，使用new ReentrantLock(true)。 \n背后原理： \nAQS，后面还会详细讲到。AQS中有一个state标识锁的占用情况，一个队列存储等待线程。 state=0表示锁空闲。如果是公平锁，那就看看队列有没有线程在等，有的话不参与竞争乖乖追加到尾部。如果是非公平锁，那就直接参与竞争，不管队列有没有等待者。 \nstate&gt;0表示有线程占着锁，这时候无论公平与非公平，都直接去排队（想抢也没有） \n备注： \n因为ReentrantLock是可以定义公平非公平锁，次数。所以是*&gt;0而不是简单的0和1* ,而**synchronized只能是非公平锁 .**\n1.2.2.6 锁升级java中每个对象都可作为锁，锁有四种级别，按照量级从轻到重分为：无锁、偏向锁、轻量级锁、重量级锁。 \n如何理解呢？A占了锁，B就要阻塞等。但是，在操作系统中，阻塞就要存储当前线程状态，唤醒就要再恢复，这个过程是要消耗时间的… \n如果A使用锁的时间远远小于B被阻塞和挂起的执行时间，那么我们将B挂起阻塞就相当的不合算。 \n于是出现自旋：自旋指的是锁已经被其他线程占用时，当前线程不会被挂起，而是在不停的试图获取锁（可以理解为不停的循环），每循环一次表示一次自旋过程。显然这种操作会消耗CPU时间，但是相比线程下文切换时间要少的时候，自旋划算。而偏向锁、轻量锁、重量锁就是围绕如何使得cpu的占用更划算而展开的。\n\n举个生活的例子，假设公司只有一个会议室（共享资源） \n偏向锁： 前期公司只有1个团队，那么什么时候开会都能满足，就不需要询问和查看会议室的占用情况，直接进入使用状态。会议室门口挂了个牌子写着A使用，A默认不需要预约（ThreadID=A） \n轻量级锁： 随着业务发展，扩充为2个团队，B团队肯定不会同意A无法无天，于是当AB同时需要开会时，两者竞争，谁抢到谁算谁的。偏向锁升级为轻量级锁，但是未抢到者在门口会不停敲门询问（自旋，循环），开完没有？开完没有？ \n重量级锁： 后来发现，这种不停敲门的方式很烦，A可能不理不睬，但是B要不停的闹腾。于是锁再次升级。如果会议室被A占用，那么B团队直接闭嘴，在门口安静的等待（wait进入阻塞），直到A用完后会通知B（notify）。\n\n注意点：\n\n上面几种锁都是JVM自己内部实现，我们不需要干预，但是可以配置jvm参数开启/关闭自旋锁、偏向锁。 \n锁可以升级，但是不能反向降级：偏向锁→轻量级锁→重量级锁 \n无锁争用的时候使用偏向锁，第二个线程到了升级为轻量级锁进行竞争，更多线程时，进入重量级锁阻塞\n\n\n\n\n锁\n优点\n缺点\n适用场景\n\n\n\n偏向锁\n加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距\n若线程间存在锁竞争，会带来额外的锁撤销的消耗\n只有一个线程访问同步块或者同步方法\n\n\n轻量级锁\n竞争的线程不会阻塞,提高了程序的响应速度\n若线程长时间竞争不到锁,自旋会消耗CPU性能\n线程交替执行同步块或者同步方法,追求响应时间,锁占用时间很短,阻塞还不如自旋的场景\n\n\n重量级锁\n线程竞争不使用自旋,不会消耗CPU\n线程阻塞,响应时间缓慢,在多线程下,频繁的获取释放锁,会带来巨大的性能消耗\n追求吞吐量,锁占用时间较长\n\n\n1.2.2.7互斥锁**/**读写锁\n典型的互斥锁：synchronized，ReentrantLock，读写锁：ReadWriteLock 前面都用过了 \n互斥锁属于独享锁，读写锁里的写锁属于独享锁，而读锁属于共享锁 \n\n案例:互斥锁用不好可能失效,看一个典型的锁不住现象:\npublic class ObjectLock &#123;    public static Integer i = 0;    public void inc() &#123;        synchronized (this) &#123;            int j = i;            try &#123;                Thread.sleep(100);                j++;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            i = j;        &#125;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        for (int i = 0; i &lt; 10; i++) &#123;            new Thread(new Runnable() &#123;                public void run() &#123;                    //重点！把锁的new操作放在外面才能锁住.                    new ObjectLock().inc();                &#125;            &#125;).start();        &#125;        Thread.sleep(3000);        //理论上10才对。可是....         System.out.println(ObjectLock.i);    &#125;&#125;\n结果分析：每个线程内都是new对象，所以this不是同一把锁，结果锁不住，输出1 \n\nthis，换成static的 i 变量试试？ \n换成ObjectLock.class 试试？ \n换成String.class \n去掉synchronized块，外部方法上加 static synchronized \n以上都能得到10\n\n1.2.3 AQS关于信号量:https://blog.csdn.net/J080624/article/details/85625350\n概念:\n首先搞清楚，AbstractQuenedSynchronizer抽象的队列式同步器，是一个抽象类，这个类在 java.util.concurrent.locks包。除了java自带的synchronized关键字之外，jdk提供的另外一种锁机制。如果需要自己实现锁的逻辑，可以考虑使用AQS，非常的便捷。 \n\n 场景案例 \n用AQS自己实现一个锁，最大允许指定数量的线程并行运作。其他排队等候\nimport java.util.concurrent.locks.AbstractQueuedSynchronizer;public class MyLock extends AbstractQueuedSynchronizer &#123;    public MyLock(int count) &#123;        setState(count);    &#125;    @Override    protected int tryAcquireShared(int arg) &#123;        for (; ; ) &#123;            int current = getState();            int newCount = current ‐arg;            if (newCount &lt; 0 || compareAndSetState(current, newCount)) &#123;                return newCount;            &#125;        &#125;    &#125;    @Override    protected boolean tryReleaseShared(int arg) &#123;        for (; ; ) &#123;            int current = getState();            int newState = current + arg;            if (compareAndSetState(current, newState)) &#123;                return true;            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        final MyLock lock = new MyLock(3);        for (int i = 0; i &lt; 30; i++) &#123;            new Thread(new Runnable() &#123;                public void run() &#123;                    lock.acquireShared(1);                    try &#123;                        Thread.currentThread().sleep(1000);                        System.out.println(&quot;ok&quot;);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125; finally &#123;                        lock.releaseShared(1);                    &#125;                &#125;            &#125;).start();        &#125;    &#125;&#125;\n验证结果：虽然30个一次性start，但是会每1s输出3个ok，达到了并发控制 \n1.3 原子操作概念:\n原子（atom）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。类比于数据库事务，redis的multi。 \nCAS:\nCompare And Set（或Compare And Swap），翻译过来就是比较并替换，CAS操作包含三个操作数——内存位置（V）、预期原值（A）、新值(B)。从第一视角来看，理解为：我认为位置 V 应该是 A，如果是A，则将 B 放到这个位置；否则，不要更改，只告诉我这个位置现在的值即可。 \n计数器问题发生归根结底是取值和运算后的赋值中间，发生了插队现象，他们不是原子的操作。前面的计数器使用加锁方式实现了正确计数，下面，基于CAS的原子类上场…. \nimport java.util.concurrent.atomic.AtomicInteger;public class AtomicCounter &#123;    private static AtomicInteger i = new AtomicInteger(0);    public int get() &#123;        return i.get();    &#125;    public void inc() &#123;        try &#123;            Thread.sleep(100);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        i.incrementAndGet();    &#125;    public static void main(String[] args) throws InterruptedException &#123;        final AtomicCounter counter = new AtomicCounter();        for (int i = 0; i &lt; 10; i++) &#123;            new Thread(new Runnable() &#123;                public void run() &#123;                    counter.inc();                &#125;            &#125;).start();        &#125;        Thread.sleep(3000);//同样可以正确输出10         System.out.println(counter.i.get());    &#125;&#125;\n上面展示了AtomicInteger,关于atomic包,还有很多其他类型:\n基本类型\n\nAtomicBoolean:以原子更新的方式更新boolean\nAtomicInteger:以原子更新的方式更新Integer;\nAtomicLong:以原子更新的方式更新Long;\n\n引用类型\n\n AtomicReference:原子更新引用类型\nAtomicReferenceFieldUpdater :原子更新引用类型的字段\nAtomicMarkableReference :原子更新带有标志位的引用类型\n\n数组\n\nAtomicintegerArray:原子更新整型数组里的元素。\nAtomicLongArray:原子更新长整型数组里的元素。\nAtomicReferenceArray:原子更新引用类型数组里的元素。\n\n字段\n\nAtomicIntegerFieldUpdater:原子更新整型的字段的更新器。\nAtomicLongFieldUpdater:原子更新长整型字段的更新器。\nAtomicStampedReference:原子更新带有版本号的引用类型。\n\n使用atomic要注意原子性的边界，把握不好会起不到应有的效果，原子性被破坏。 \n案例：原子性被破坏现象\nimport java.util.concurrent.atomic.AtomicInteger;public class BadAtomic &#123;    AtomicInteger i = new AtomicInteger(0);    static int j = 0;    public void badInc() &#123;        int k = i.incrementAndGet();        try &#123;            Thread.sleep(new Random().nextInt(100));        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        j = k;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        BadAtomic atomic = new BadAtomic();        for (int i = 0; i &lt; 10; i++) &#123;            new Thread(()‐ &gt; &#123;atomic.badInc(); &#125;).start();        &#125; Thread.sleep(3000);        System.out.println(atomic.j);    &#125;&#125;\n\n结果分析： \n每次都不一样，总之不是10 \n原因:多线程下,赋值给k没问题,k肯定是递增的,但是在j=k这一步之前的耗时操作,可能被别的线程插队,导致给j赋值的结果改变.\n在badInc上加synchronized，问题解决 \n\n1.4 threadLocal 概念 \nThreadLocal类并不是用来解决多线程环境下的共享变量问题，而是用来提供线程内部的共享变量。在多线程环境下，可以保证各个线程之间的变量互相隔离、相互独立。 \n 使用 \nThreadLocal实例一般定义为private static类型的，在一个线程内，该变量共享一份，类似上下文作用，可以用来上下传递信息。\npublic class ThreadLocalDemo implements Runnable &#123;    private static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;&gt;();    public void run() &#123;        for (int i = 0; i &lt; 3; i++) &#123;            threadLocal.set(i);            System.out.println(Thread.currentThread().getName() + &quot;,value=&quot; + threadLocal.get());        &#125;    &#125;    public static void main(String[] args) &#123;        ThreadLocalDemo demo = new ThreadLocalDemo();        new Thread(demo).start();        new Thread(demo).start();    &#125;&#125;\n应用场景 \n\n数据库连接，session管理 \n下面的基于日志平台的访问链路追踪中，会用到 \n\n注意！ \nThreadLocal如果指向了同一个引用，会打破隔离而失效。 \n案例：隔离失败了！\nimport java.util.HashMap;import java.util.Map;public class BadLocal &#123;    public static void main(String[] args) &#123;        ThreadLocal&lt;Map&gt; local = new ThreadLocal();        Map map = new HashMap();        new Thread(()‐ &gt; &#123;                //在线程设置后，过段时间取name                 // 猜一猜结果？                 map.put(&quot;name&quot;, &quot;i am &quot; + Thread.currentThread().getName()); local.set(map);        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + local.get().get(&quot;name&quot;));        //do something...         try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + local.get().get(&quot;name&quot;)); &#125;).start();        new Thread(()‐ &gt; &#123;                // 在线程中赋值name                map.put(&quot;name&quot;, &quot;i am &quot; + Thread.currentThread().getName());        local.set(map); &#125;).start();    &#125;&#125;\n\n\n1.5 Fork/Join概念 \nForkJoin是由JDK1.7后提供多线并发处理框架。ForkJoinPool由Java大师Doug Lea主持编写，处理逻辑大概分为两步。\n1.任务分割：Fork（分岔），先把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割。\n2.合并结果：join，分割后的子任务被多个线程执行后，再合并结果，得到最终的完整输出。 \n组成 \n\nForkJoinTask：主要提供fork和join两个方法用于任务拆分与合并；多数使用RecursiveAction（无返回值的任务）和RecursiveTask（需要返回值）来实现compute方法\nForkJoinPool：调度ForkJoinTask的线程池； \nForkJoinWorkerThread：Thread的子类，存放于线程池中的工作线程（Worker）； \nWorkQueue：任务队列，用于保存任务； \n\n基本使用 \n一个典型的例子：计算1-1000的和\nimport java.util.concurrent.*;public class SumTask &#123;    private static final Integer MAX = 100;    static class SubTask extends RecursiveTask&lt;Integer&gt; &#123;        // 子任务开始计算的值         private Integer start;        // 子任务结束计算的值        private Integer end;        public SubTask(Integer start, Integer end) &#123;            this.start = start;            this.end = end;        &#125;        @Override        protected Integer compute() &#123;            if (end ‐start&lt;MAX)&#123;                //小于边界，开始计算                 System.out.println(&quot;start = &quot; + start + &quot;;end = &quot; + end);                Integer totalValue = 0;                for (int index = this.start; index &lt;= this.end; index++) &#123;                    totalValue += index;                &#125;                return totalValue;            &#125;else&#123;                //否则，中间劈开继续拆分                 SubTask subTask1 = new SubTask(start, (start + end) / 2);                subTask1.fork();                SubTask subTask2 = new SubTask((start + end) / 2 + 1, end);                subTask2.fork();                return subTask1.join() + subTask2.join();            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        ForkJoinPool pool = new ForkJoinPool();        Future&lt;Integer&gt; taskFuture = pool.submit(new SubTask(1, 1000));        try &#123;            Integer result = taskFuture.get();            System.out.println(&quot;result = &quot; + result);        &#125; catch (InterruptedException | ExecutionException e) &#123;            e.printStackTrace(System.out);        &#125;    &#125;&#125;\n设计思想 \n\n普通线程池内部有两个重要集合：工作线程集合，和任务队列。 \nForkJoinPool也类似，工作集合里放的是特殊线程ForkJoinWorkerThread，任务队列里放的是特殊任务ForkJoinTask \n不同之处在于，普通线程池只有一个队列。而ForkJoinPool的工作线程ForkJoinWorkerThread每个线程内都绑定一个双端队列。\n在fork的时候，也就是任务拆分，将拆分的task会被当前线程放到自己的队列中。 \n队列中的任务被线程执行时，有两种模式，默认是同步模式（asyncMode==false）从队尾取任务（LIFO） \n窃取：当自己队列中执行完后，工作线程会到其他队列的队首获取任务（FIFO），取到后如果任务再次fork，拆分会被放入当前线程的队列，依次扩张 \n\n注意点 \n使用ForkJoin将相同的计算任务通过多线程执行。但是在使用中需要注意： \n\n注意任务切分的粒度，也就是fork的界限。并非越小越好 \n判断要不要使用ForkJoin。任务量不是太大的话，串行可能优于并行。因为多线程会涉及到上下文的切换\n\n1.6 Volatile基本概念 \n回顾Java 内存模型中的可见性、原子性和有序性： \n\n可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的 \n原子性，指的是这个操作是原子不可拆分的，不允许别的线程中间插队操作 \n有序性指的是你写的代码的顺序要和最终执行的指令保持一致。因为在Java内存模型中，允许编译器和处理器 \n\n对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 volatile要解决的就是可见性和有序性问题。 \n使用方式 \n先看一个经典案例：\npublic class VolatileTest extends Thread &#123;    private static boolean flag = true;    public void run() &#123;        while (flag) ;        System.out.println(&quot;finish&quot;);    &#125;    public static void main(String[] args) throws Exception &#123;        new VolatileTest().start();        Thread.sleep(2000);        flag = false;    &#125;&#125;\n\n给flag加上 volatile再试试…… \n\n原理:\nJava内存模型分为主内存和线程工作内存两大类。 \n\n主内存：多个线程共享的内存。方法区和堆属于主内存区域。 \n线程工作内存：每个线程独享的内存。虚拟机栈、本地方法栈、程序计数器属于线程独享的工作内存。 \n\nJava内存模型规定，所有变量都需要存储在主内存中，线程需要时，在自己的工作内存保存变量的副本，线程对变量的所有操作都在工作内存中进行，执行结束后再同步到主内存中去。这里必然会存在时间差，在这个时间差内，该线程对副本的操作，对于其他线程是不见的，从而造成了可见性问题。 \n但是，当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。\n同时，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议。每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期，一旦发现过期就会将当前处理器的缓存行设置成无效状态，强制从主内存读取，这就保障了可见性。 \n而volatile变量，通过内存屏障（JMM课程）可以禁止指令重排。从而实现指令的有序性。 \n注意！ \nvolatile不能保证锁的原子性。 \n案例：给前面的计数器案例里加上volatile试试 \npublic class BadVolatile &#123;    private static volatile int i = 0;    public int get() &#123;        return i;    &#125;    public void inc() &#123;        int j = get();        try &#123;            Thread.sleep(100);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        i = j + 1;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        final BadVolatile counter = new BadVolatile();        for (int i = 0; i &lt; 10; i++) &#123;            new Thread(new Runnable() &#123;                public void run() &#123;                    counter.inc();                &#125;            &#125;).start();        &#125;        Thread.sleep(3000);        //理论上10才对。可是....         System.out.println(counter.i);    &#125;&#125;//达不到目的。说明原子性无法保障。\n\n\n1.7 ConcurrentHashMap使用:\nnew创建即可：\npublic static void main(String[]args)throws InterruptedException&#123;        //定义ConcurrentHashMap        Map map=new ConcurrentHashMap();        for(int i=0;i&lt; 10;i++)&#123;            new Thread(new Runnable()&#123;                @Override                public void run()&#123;                //多线程下的put可以放心使用                 map.put(UUID.randomUUID().toString(),&quot;1&quot;);                &#125;            &#125;).start();        &#125;        Thread.sleep(3000);        System.out.println(map);&#125;\n 实现原理 \n1.7是分段锁，上面阐述过，1.8采用的是cas + synchronized 操作，具体看代码：\n\n注意！ \n注意正确理解ConcurrentHashMap线程安全这个问题。看一个典型案例：\npackage com.example.demo.test;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;public class BadConcurrent &#123;    public static void main(String[] args) throws InterruptedException &#123;        Map&lt;String, Integer&gt; map = new ConcurrentHashMap();        map.put(&quot;val&quot;, 0);        for (int i = 0; i &lt; 10; i++) &#123;            new Thread(() -&gt; &#123;                int v = map.get(&quot;val&quot;);                v++;                try &#123;                    Thread.currentThread().sleep(100);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                map.put(&quot;val&quot;, v);            &#125;).start();        &#125;        Thread.sleep(3000);        System.out.println(map);//&#123;val=1&#125;    &#125;&#125;\n\n\n1.8 并发容器java中的集合类非常丰富（ArrayList，HashMap之类），在单线程下用的顺风顺水，但这些集合类都是非线程安全的，即在多线程的环境下，都需要其他额外的手段来保证数据的正确性。常见手段有两种： \n\n自己通过synchronized关键字将所有使用到非线程安全的容器代码全部同步执行 \nVector、Stack、HashTable、Collections.synchronized等同步容器法，在早期的jdk中用的比较多，实现方 式和上面几乎一样，而且多步操作时如果外面不额外加一层synchronized，依然锁不住。实际效果还不如上面\n\n并发容器清单:\n1.ConcurrentHashMap \n对应：HashMap目标：代替Hashtable、synchronizedMap，使用最多，前面详细介绍过 \n原理：JDK7中采用Segment分段锁，JDK8中采用CAS+synchronized \n2.CopyOnWriteArrayList \n对应：ArrayList \n目标：代替Vector、synchronizedList \n原理：高并发往往是读多写少的特性，读操作不加锁，而对写操作加Lock独享锁，先复制一份新的集合，在新的集合上面修改，然后将新集合赋值给旧的引用，并通过volatile 保证其可见性。 \n查看源码：volatile array，lock加锁，数组复制 \n3.CopyOnWriteArraySet \n对应：HashSet \n目标：代替synchronizedSet \n原理：与CopyOnWriteArrayList实现原理类似。 \n4.ConcurrentSkipListMap \n对应：TreeMap \n目标：代替synchronizedSortedMap(TreeMap) \n原理：基于Skip list（跳表）来代替平衡树，按照分层key上下链接指针来实现。 \n附加：跳表 \n5.ConcurrentSkipListSet \n对应：TreeSet \n目标：代替synchronizedSortedSet(TreeSet) \n原理：内部基于ConcurrentSkipListMap实现，原理一致 \n6.ConcurrentLinkedQueue \n对应：LinkedList \n对应：无界线程安全队列 \n原理：通过队首队尾指针，以及Node类元素的next实现FIFO队列\n7.BlockingQueue \n对应：Queue \n特点：拓展了Queue，增加了可阻塞的插入和获取等操作 \n原理：通过ReentrantLock实现线程安全，通过Condition实现阻塞和唤醒 \n实现类：\n\nLinkedBlockingQueue：基于链表实现的可阻塞的FIFO队列 \nArrayBlockingQueue：基于数组实现的可阻塞的FIFO队列 \nPriorityBlockingQueue：按优先级排序的队列 \n\n2.性能调优2.1锁优化Synchronized优化synchronized使用起来非常简单，但是需要注意的是synchronized加锁的是什么维度\n对象级别： \npublic synchronized void test()&#123; // TODO &#125;public void test()&#123; synchronized (this) &#123; // TODO &#125; &#125; \n类级别: \npublic static synchronized void test()&#123; // TODO &#125;public void test()&#123; synchronized (TestSynchronized.class) &#123; // TODO &#125; &#125; \n案例：看一个加锁粒度的案例\nimport java.util.concurrent.atomic.AtomicLong;public class BadSync implements Runnable &#123;    long start = System.currentTimeMillis();    AtomicLong atomicLong = new AtomicLong(0);    volatile int i = 0;    public void inc() &#123;        i++;    &#125;    @Override    public synchronized void run() &#123;        try &#123;            Thread.sleep(100);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        inc();        atomicLong.getAndAdd(System.currentTimeMillis() ‐ start);    &#125;    public static void main(String[] args) throws InterruptedException &#123;        BadSync sync = new BadSync();        for (int i = 0; i &lt; 5; i++) &#123;            new Thread(sync).start();        &#125;        Thread.sleep(3000);        System.out.println(&quot;最终计数：i=&quot; + sync.i);        System.out.println(&quot;最终耗时：time=&quot; + sync.atomicLong.get());    &#125;&#125;\n看一下最后的结果和耗时 \n\n将synchronized换到inc方法上，再试试最后的结果和耗时 \n结论是什么？ \n\nLock锁优化看一个小需求：电商系统中记录首页被用户浏览的次数，以及最后一次操作的时间（含读或写）。\nimport java.util.HashMap; import java.util.Map; import java.util.concurrent.atomic.AtomicLong; import java.util.concurrent.locks.ReentrantLock; public class TotalLock &#123; //类创建的时间 final long start = System.currentTimeMillis(); //总耗时 AtomicLong totalTime = new AtomicLong(0); //缓存变量 private Map&lt;String,Long&gt; map = new HashMap()&#123;&#123;put(&quot;count&quot;,0L);&#125;&#125;; ReentrantLock lock = new ReentrantLock(); //查看map被写入了多少次 public Map read()&#123; lock.lock(); try &#123;Thread.currentThread().sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;long end = System.currentTimeMillis(); //最后操作完成的时间 map.put(&quot;time&quot;,end); lock.unlock(); System.out.println(Thread.currentThread().getName()+&quot;,read=&quot;+(end‐start)); totalTime.addAndGet(end ‐ start); return map; &#125;//写入 public Map write()&#123; lock.lock(); try &#123;Thread.currentThread().sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;//写入计数 map.put(&quot;count&quot;,map.get(&quot;count&quot;)+1); long end = System.currentTimeMillis(); map.put(&quot;time&quot;,end); lock.unlock(); System.out.println(Thread.currentThread().getName()+&quot;,write=&quot;+(end‐start)); totalTime.addAndGet(end ‐ start); return map; &#125;public static void main(String[] args) throws InterruptedException &#123;TotalLock count = new TotalLock(); //读for (int i = 0; i &lt; 4; i++) &#123; new Thread(()‐&gt;&#123; count.read(); &#125;).start(); &#125;//写for (int i = 0; i &lt; 1; i++) &#123; new Thread(()‐&gt;&#123; count.write(); &#125;).start(); &#125;Thread.sleep(3000); System.out.println(count.map); System.out.println(&quot;读写总共耗时：&quot;+count.totalTime.get()); &#125; &#125; \n仔细看读的时间变化和执行的总时间，思考一下，从业务和技术角度有没有可优化空间？ \n仔细分析业务：查看次数这里其实是可以并行读取的，我们关注的业务是写入次数，也就是count，至于读取发生 的时间time的写入操作，只是一个单步put，每次覆盖，不需要原子性保障，对这个加互斥锁没有必要。 改成读写锁试试……\nimport java.util.HashMap; import java.util.Map; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.atomic.AtomicLong; import java.util.concurrent.locks.ReentrantReadWriteLock; public class ReadAndWrite &#123; //类创建的时间 final long start = System.currentTimeMillis(); //总耗时 AtomicLong totalTime = new AtomicLong(0); //缓存变量，注意！因为read并发，这里换成ConcurrentHashMap private Map&lt;String,Long&gt; map = new ConcurrentHashMap()&#123;&#123;put(&quot;count&quot;,0L);&#125;&#125;; ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); //查看map被写入了多少次 public Map read()&#123; lock.readLock().lock(); try &#123;Thread.currentThread().sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;long end = System.currentTimeMillis(); //最后操作完成的时间 map.put(&quot;time&quot;,end); lock.readLock().unlock(); System.out.println(Thread.currentThread().getName()+&quot;,read=&quot;+(end‐start)); totalTime.addAndGet(end ‐ start); return map; &#125;//写入 public Map write()&#123; lock.writeLock().lock(); try &#123;Thread.currentThread().sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;//写入计数 map.put(&quot;count&quot;,map.get(&quot;count&quot;)+1); long end = System.currentTimeMillis(); map.put(&quot;time&quot;,end); lock.writeLock().unlock(); System.out.println(Thread.currentThread().getName()+&quot;,write=&quot;+(end‐start)); totalTime.addAndGet(end ‐ start); return map; &#125;public static void main(String[] args) throws InterruptedException &#123;ReadAndWrite rw = new ReadAndWrite(); //读for (int i = 0; i &lt; 4; i++) &#123; new Thread(()‐&gt;&#123; rw.read(); &#125;).start(); &#125;//写for (int i = 0; i &lt; 1; i++) &#123; new Thread(()‐&gt;&#123; rw.write(); &#125;).start(); &#125;Thread.sleep(3000); System.out.println(rw.map); System.out.println(&quot;读写总共耗时：&quot;+rw.totalTime.get()); &#125; &#125; \n再来看读的时间变化和总执行时间。 \n当read远大于write时，这个差距会更明显 （改成9:1试试……） \nCAS乐观锁优化回顾上面的计数器，我们用synchronized实现了准确计数，本节我们看执行时间，追究性能问题。 \n案例一：直接加synchronized锁\npublic class NormalSync implements Runnable&#123; Long start = System.currentTimeMillis(); int i=0; public synchronized void run() &#123; int j = i; //实际业务中可能会有一堆的耗时操作，这里等待100ms模拟 try &#123;//做一系列操作 Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;//业务结束后，增加计数 i = j+1; System.out.println(Thread.currentThread().getId()+ &quot; ok,time=&quot;+(System.currentTimeMillis() ‐ start)); &#125;public static void main(String[] args) throws InterruptedException &#123; NormalSync test = new NormalSync(); new Thread(test).start(); new Thread(test).start(); Thread.currentThread().sleep(1000); System.out.println(&quot;last value=&quot;+test.i); &#125; &#125; \n线程二最终耗时会在200ms+，总耗时300ms，原因是悲观锁卡在了read后的耗时操作上，但是保证了最终结果是2\n案例二：基于CAS思想，compare再set\nimport sun.misc.Unsafe; import java.lang.reflect.Field; public class CasSync implements Runnable&#123; long start = System.currentTimeMillis(); int i=0; public void run() &#123; int j = i; try &#123;Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;//CAS处理，在这里理解思想，实际中不推荐大家使用！ try &#123;Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); f.setAccessible(true); Unsafe unsafe = (Unsafe) f.get(null); long offset = unsafe.objectFieldOffset(CasSync.class.getDeclaredField(&quot;i&quot;)); while (!unsafe.compareAndSwapInt(this,offset,j,j+1))&#123; j = i; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;//实际开发中，要用atomic包，或者while+synchronized自旋 // synchronized (this)&#123; // //注意这里！ // while (j != i)&#123; // j = i; // &#125; // i = j+1; // &#125; System.out.println(Thread.currentThread().getName()+ &quot; ok,time=&quot;+(System.currentTimeMillis() ‐ start)); &#125;public static void main(String[] args) throws InterruptedException &#123; CasSync test = new CasSync(); new Thread(test).start(); new Thread(test).start(); Thread.currentThread().sleep(1000); System.out.println(&quot;last value=&quot;+test.i); &#125; &#125;\n线程一、二均在100ms+，总耗时200ms，最终结果还是2 \n一些经验 \n\n减少锁的时间 \n\n不需要同步执行的代码，能不放在同步快里面执行就不要放在同步快内，可以让锁尽快释放 \n\n减少锁的粒度 \n\n将物理上的一个锁，拆成逻辑上的多个锁，增加并行度，从而降低锁竞争，典型如分段锁 \n\n锁的粒度 \n\n拆锁的粒度不能无限拆，最多可以将一个锁拆为当前cup数量相等 \n\n减少加减锁的次数 \n\n假如有一个循环，循环内的操作需要加锁，我们应该把锁放到循环外面，否则每次进出循环，都要加锁 \n\n使用读写锁 \n\n业务细分，读操作加读锁，可以并发读，写操作使用写锁，只能单线程写，参考计数器案例 \n\n善用volatile \n\nvolatile的控制比synchronized更轻量化，在某些变量上可以加以运用，如单例模式中 \n2.2 线程池参数调优2.3 协程2.4 并发容器选择2.5 上下文切换优化","categories":["java"],"tags":["多线程 - java"]},{"title":"Hello World","url":"https://www.mele.cool/2020/12/02/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server$ hexo server\nMore info: Server\nGenerate static files$ hexo generate\nMore info: Generating\nDeploy to remote sites$ hexo deploy\nMore info: Deployment\n","categories":["hello world"],"tags":["入门"]}]