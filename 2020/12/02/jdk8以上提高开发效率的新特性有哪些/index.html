<!DOCTYPE html>
<html  lang="zh-CN" >

<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#fff" id="theme-color">
  <meta name="description" content="米乐博客,拿来主义的搬运工,搬着搬着就是自己的了.">
  <link rel="icon" href="https://i.loli.net/2021/01/27/IrkEAwO1ujK6Z9y.png">
  <title>jdk8以上提高开发效率的新特性有哪些</title>
  
  
  <meta property="og:title" content="jdk8以上提高开发效率的新特性有哪些">
  
  
  <meta property="og:url" content="https://www.mele.cool/2020/12/02/jdk8%E4%BB%A5%E4%B8%8A%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B/index.html">
  
  
  <meta property="og:img" content="https://i.loli.net/2021/01/27/IrkEAwO1ujK6Z9y.png">
  
  
  <meta property="og:img" content="米乐博客,拿来主义的搬运工,搬着搬着就是自己的了.">
  
  
  <meta property="og:type" content="article">
  <meta property="og:article:published_time" content="2020-12-02">
  <meta property="og:article:modified_time" content="2020-12-05">
  <meta property="og:article:author" content="blydd">
  
  
  <meta property="og:article:tag" content="jdk8 - java">
  
  
  
  
  <!-- 百度统计代码 -->
<script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?52aed7fa581354c5e14562bad1a1def2";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
 <!-- 百度统计代码 --> 
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
    var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
      }
    };
    setDarkmode();
  </script>
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
  </script>
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  
  <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.js" as="script">
  <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.css" as="style" >
  
  
  <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  
  
  
<link rel="stylesheet" href="/css/main.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">

  
  
<link rel="stylesheet" href="/js/lib/lightbox/baguetteBox.min.css">

  
  
  
  
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <div class="wrapper">
    
    <nav class="navbar">
  <div class="navbar-logo">
    <span class="navbar-logo-main">
      
      <img class="navbar-logo-img" src="https://i.loli.net/2021/01/27/IrkEAwO1ujK6Z9y.png" alt="logo">
      
      <span class="navbar-logo-dsc">mele blog</span>
    </span>
  </div>
  <div class="navbar-menu">
    
    <a href="/" class="navbar-menu-item">
    
    首页
    
    </a>
    
    <a href="/archives" class="navbar-menu-item">
    
    归档
    
    </a>
    
    <a href="/tags" class="navbar-menu-item">
    
    标签
    
    </a>
    
    <a href="/categories" class="navbar-menu-item">
    
    分类
    
    </a>
    
    <a href="/about" class="navbar-menu-item">
    
    关于
    
    </a>
    
    <a href="/links" class="navbar-menu-item">
    
    友链
    
    </a>
    
    <a class="navbar-menu-item darknavbar" id="dark"><i class="iconfont icon-weather"></i></a>
    <a class="navbar-menu-item searchnavbar" id="search"><i class="iconfont icon-search" style="font-size: 1.2rem; font-weight: 400;"></i></a>
  </div>
</nav>
    
    <div id="local-search" style="display: none;">
      <input class="navbar-menu-item" id="search-input" placeholder="请输入搜索内容...">
      <div id="search-content"></div>
    </div>
    
    <div class="section-wrap">
      <div class="container">
        <div class="columns">
          <main class="main-column">
<article class="card card-content">
  <header>
    <h1 class="post-title">
      jdk8以上提高开发效率的新特性有哪些
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2020-12-02T14:56:17.000Z">
      <i class="iconfont icon-calendar" style="margin-right: 2px;"></i>
      <span>2020-12-02</span>
    </time>
    
    <span class="dot"></span>
    
    <a href="/categories/java/" class="post-meta-link">java</a>
    
    
    
    <span class="dot"></span>
    <span>10.2k 字</span>
    
  </div>
  
  <div class="post-meta post-show-meta" style="margin-top: -10px;">
    <div style="display: flex; align-items: center;">
      <i class="iconfont icon-biaoqian" style="margin-right: 2px; font-size: 1.15rem;"></i>
      
      
        <a href="/tags/jdk8-java/" class="post-meta-link">jdk8 - java</a>
      
    </div>
  </div>
  
  </header>
  <div id="section" class="post-content">
    <h1 id="1-接口的默认方法和静态方法"><a href="#1-接口的默认方法和静态方法" class="headerlink" title="1.接口的默认方法和静态方法"></a>1.接口的默认方法和静态方法</h1><p><strong>众所周知，在接口中定义的普通方法都是抽象方法，方法前面默认都会添加public abstract，不能有方法实现，需要在接口的实现类中对方法进行具体实现。</strong></p>
<p>但是<strong>Java8开始允许在接口中定义默认方法和静态方法</strong>，对于这两种方法，可以直接在接口对其进行实现，无需再在接口实现类中进行实现。</p>
<ul>
<li>默认方法：又叫扩展方法，在方法前面需通过default修饰,不能直接通过接口调用，必须通过接口实现类的实例对象进行方法调用</li>
<li>静态方法：又叫类方法，在方法前面需通过static修饰。可以直接通过接口调用。</li>
</ul>
<p><strong>普通方法必须实现，默认方法可以选择性重写，静态方法无法重写。</strong></p>
<h1 id="2-lambda表达式"><a href="#2-lambda表达式" class="headerlink" title="2.lambda表达式"></a>2.lambda表达式</h1><blockquote>
<p><strong>Lambda表达式是Java8非常重要的一个新特性,其基于函数式编程的思想,支持将代码作为方法参数进行使用</strong>。可以把Lambda表达式理解为通过一种更加简洁的方式表示可传递的匿名函数。<br>它本身没有名称,而且不像方法那样属于某一个类,但是可以有参数列表、代码体、返回值。使用了Lambda表达式之后就不需要再去编写匿名类了。</p>
</blockquote>
<h2 id="2-1基础格式"><a href="#2-1基础格式" class="headerlink" title="2.1基础格式:"></a>2.1基础格式:</h2><pre class="highlight"><span class="line">(参数列表) ‐&gt; &#123;</span><br><span class="line">	方法体</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有参数的Lambda表达式</span></span><br><span class="line">()‐&gt;<span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//只有一个参数的Lambda表达式</span></span><br><span class="line">x -&gt; &#123;</span><br><span class="line">  System.out.println(x);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有多个参数的Lambda表达式</span></span><br><span class="line">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)-&gt;&#123;</span><br><span class="line">	System.out.println(x);</span><br><span class="line">  System.out.println(y);</span><br><span class="line">	<span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上述可以进行简写，因为在Lambda中，参数列表中参数的数据类型可以交给JVM根据上下文进行推断。所以可以不用定义类型。</span></span><br><span class="line"><span class="comment">//一个参数和仅一条语句的Lambda表达式</span></span><br><span class="line">x-&gt;<span class="number">3</span>+x;</span><br><span class="line"><span class="comment">//多个参数和仅一条语句的Lambda表达式</span></span><br><span class="line">(x,y) -&gt;x+y;</span><br></pre>
<h2 id="2-2-Lambda表达式底层原理解析"><a href="#2-2-Lambda表达式底层原理解析" class="headerlink" title="2.2 Lambda表达式底层原理解析"></a>2.2 <strong>Lambda</strong>表达式底层原理解析</h2><pre class="highlight"><span class="line"><span class="comment">//lambda循环比较 </span></span><br><span class="line">Arrays.sort(language,(o1,o2)‐&gt;(o1.compareTo(o2)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个使用Lambda表达式的方法 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceDemo</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span>&#123; </span><br><span class="line">		String[] language = &#123;<span class="string">&quot;c&quot;</span>, <span class="string">&quot;c++&quot;</span>, <span class="string">&quot;c#&quot;</span>, <span class="string">&quot;java&quot;</span>,<span class="string">&quot;python&quot;</span>, <span class="string">&quot;go&quot;</span>,<span class="string">&quot;hive&quot;</span>, <span class="string">&quot;php&quot;</span>&#125;; </span><br><span class="line">		List&lt;String&gt; list = Arrays.asList(language);</span><br><span class="line">    list.forEach(s‐&gt; System.out.println(s)); </span><br><span class="line">    &#125; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//将当前.java文件编译生成.class文件，执行命令后，会在当前文件夹生成对应的.class文件 </span></span><br><span class="line">javac SourceDemo.java</span><br><span class="line"><span class="comment">//将.class文件进行反编译，查看文件内容 </span></span><br><span class="line">javap ‐p SourceDemo.class</span><br><span class="line"><span class="comment">//  生成内容如下</span></span><br><span class="line">  Compiled from <span class="string">&quot;SourceDemo.java&quot;</span> </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">itheima</span>.<span class="title">lambda</span>.<span class="title">source</span>.<span class="title">SourceDemo</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> com.itheima.lambda.source.SourceDemo(); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> lambda$demo$<span class="number">0</span>(java.lang.String); </span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//此时可以发现，代码中执行Lambda表达式的部分生成了一个静态私有函数。这个静态私有函数的函数干就是 Lambda表达式里面的内容。 那么对于这个静态私有函数，在JDK8内部是如何实现调用的呢？可以查看 LambdaMetafactory 类，该类下有一个 metafactory方法，lambda表达式每一次在执行的时候都会进入到这个方法中，并且为lambda表达式创建一个内 部类。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想查看内部类里面的内容，可以在lambda表达式执行之前，添加 </span></span><br><span class="line">System.setProperty(<span class="string">&quot;jdk.internal.lambda.dumpProxyClasses&quot;</span>, <span class="string">&quot;D://&quot;</span>); </span><br><span class="line"><span class="comment">//这个方法会将运行时生成的内部类class文件进行输出。 当该文件生成后，可以通过 javap -c -p class文件名 查看文件中的内容</span></span><br><span class="line"><span class="comment">//此时可以发现编译后的Lambda表达式已经被执行。</span></span><br></pre>
<blockquote>
<p>综上所述，Lambda表达式在执行的时候，会调用LambdaMetafactory.metafactory动态的生成内部类，在方法 内调用 SourceDemo$&amp;Lambda$1 ，内部类里的调用方法块并不是动态生成的，只是在原class里已经编译生成了一个 静态的方法，内部类只需要调用该静态方法。 </p>
</blockquote>
<h1 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3.函数式接口"></a>3.函数式接口</h1><blockquote>
<p>在Java8中为了让现在有的函数能够更加友好的使用Lambda表达式，因此引入了<strong>函数式接口</strong>这个概念。其是<strong>一个 仅有一个抽象方法的普通接口</strong>。如果声明多个抽象方法则会报错。但是默认方法和静态方法在此接口中可以定义多个。</p>
<p>要想自定义一个函数式接口的话，需要在<strong>接口上添加 @FunctionalInterface</strong> 。 </p>
<p>在Java8的类库设计中，已经引入了几个函数式接口：Predicate、Consumer、Function、Supplier </p>
</blockquote>
<h2 id="3-1-Predicate使用"><a href="#3-1-Predicate使用" class="headerlink" title="3.1 Predicate使用"></a>3.1 <strong>Predicate</strong>使用</h2><blockquote>
<p>Predicate接口是Java8定义的一个函数式接口，属于<strong>java.util.function</strong>包下，<strong>内部定义一个 抽象方法test、三个默认方法and，negate，or、一个静态方法isEqual</strong> </p>
</blockquote>
<pre class="highlight"><span class="line"><span class="keyword">import</span> com.itheima.lambda.Student; </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList; </span><br><span class="line"><span class="keyword">import</span> java.util.List; </span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPredicateDemo</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Student&gt; <span class="title">filter</span><span class="params">(List&lt;Student&gt; studentList, Predicate&lt;Student&gt; predicate)</span></span>&#123; 		ArrayList&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();                                                                                         		studentList.forEach(s‐&gt;&#123; 	                                                                                      		<span class="keyword">if</span> (predicate.test(s))&#123;                                                                                        			list.add(s); </span><br><span class="line">	  &#125; </span><br><span class="line">  &#125;); </span><br><span class="line">                                                                                              <span class="keyword">return</span> list; </span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">    students.add(<span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;M&quot;</span>)); </span><br><span class="line">    students.add(<span class="keyword">new</span> Student(<span class="number">2</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;M&quot;</span>)); </span><br><span class="line">    students.add(<span class="keyword">new</span> Student(<span class="number">3</span>,<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;F&quot;</span>)); </span><br><span class="line">    List&lt;Student&gt; result = filter(students, (s) ‐&gt; s.getSex().equals(<span class="string">&quot;F&quot;</span>)); 	</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre>
<h2 id="3-2-Consumer使用"><a href="#3-2-Consumer使用" class="headerlink" title="3.2 Consumer使用"></a>3.2 <strong>Consumer</strong>使用</h2><blockquote>
<p>Consumer也是JDK8提供的函数式接口，用于进行<strong>获取数据</strong>的操作，其内部定义了一个抽象方法accept、一个默 认方法andThen。</p>
<p>对于accept()方法来说，它接受一个泛型T对象。如果现在需要访问类型T对象，并对其进行某些操作的话，就可以使用这个接口。 </p>
</blockquote>
<pre class="highlight"><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List <span class="keyword">import</span> java.util. function.Consumer.</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumerDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foreach</span><span class="params">(List&lt;String&gt; arrays, Consumer&lt;String&gt; consumer)</span>&#125;</span></span><br><span class="line"><span class="function">		arrays.<span class="title">forEach</span><span class="params">(s-&gt;consumer.accept (s)</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;string&gt; arrays = <span class="keyword">new</span> ArrayListo&gt;();</span><br><span class="line">		arrays.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">		arrays. add(<span class="string">&quot;python&quot;</span>);</span><br><span class="line">		arrays.add(<span class="string">&quot;go&quot;</span>);</span><br><span class="line">		arrays.add(<span class="string">&quot;hive&quot;</span>);</span><br><span class="line">		foreach(arrays, (s)-&gt; System.out.print(s+<span class="string">&quot;,&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre>
<h2 id="3-3-Function使用"><a href="#3-3-Function使用" class="headerlink" title="3.3 Function使用"></a>3.3 <strong>Function</strong>使用</h2><blockquote>
<p>Function主要用于进行类型转换的操作。内部提供一个抽象方法apply、两个默认方法compose，andThen、一个 静态方法identity </p>
<p>对于apply方法，它接收一个泛型T对象，并返回一个泛型R的对象</p>
</blockquote>
<pre class="highlight"><span class="line"><span class="keyword">package</span> com.example.demo.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFunctionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">convert</span><span class="params">(String value, Function&lt;String,Integer&gt; function)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function.apply(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer convert = convert(<span class="string">&quot;666&quot;</span>, value -&gt; Integer.valueOf(value)+<span class="number">222</span>);</span><br><span class="line">        System.out.println(convert);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre>
<h2 id="3-4-Supplier使用"><a href="#3-4-Supplier使用" class="headerlink" title="3.4 Supplier使用"></a>3.4 <strong>Supplier</strong>使用</h2><blockquote>
<p>Supplier也是用来进行值获取操作，内部只有一个抽象方法get</p>
</blockquote>
<pre class="highlight"><span class="line"><span class="keyword">package</span> com.example.demo.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySupplierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">getMin</span><span class="params">(Supplier&lt;Integer&gt; supplier)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">100</span>,<span class="number">22</span>,<span class="number">111</span>&#125;;</span><br><span class="line">        Integer min1 = getMin(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> min = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (min &gt; a) &#123;</span><br><span class="line">                    min = a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(min1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre>
<h2 id="3-5-类型检查-amp-推断"><a href="#3-5-类型检查-amp-推断" class="headerlink" title="3.5 类型检查**&amp;**推断"></a>3.5 类型检查**&amp;**推断</h2><blockquote>
<p>对于Lambda表达式的类型推断，它是对Java7中的目标类型推断进行的再次扩展。在Java7中引入了 菱形操作 </p>
<p>符 的概念，它可以是代码在编译时自动推断出泛型参数的类型。</p>
</blockquote>
<pre class="highlight"><span class="line"><span class="comment">//全量声明 </span></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;(); </span><br><span class="line"><span class="comment">//菱形运算符 </span></span><br><span class="line">Map&lt;String,String&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre>
<p>第二种书写代码的方式，也是我们在开发中经常使用的。不用明确声明泛型类型，代码在进行编译时，可以自动的进行类型推断。 </p>
<p>那么在Java8中对于这种使用方式又进一步扩展，可以省略Lambda表达式中的所有参数类型。在编译时根据Lambda表达式的上下文信息推断出参数的正确类型。这就是所谓的类型推断。</p>
<blockquote>
<p>到现在为止，对于Lambda表达式都只用到了方法体里面的参数，但Lambda其实是支持使用外部定义的变量的。在下面这段代码中，在Lambda表达式内部引用了外部变量。但是当在Lambda方法体内使用外部变量时，其必须声明为final。下述代码虽然没有显示的声明，但是在Java8它自动的会对需要为final的变量进行转换。 </p>
</blockquote>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> port = <span class="number">8086</span>; </span><br><span class="line">  Runnable runnable = ()‐&gt; System.out.println(port); </span><br><span class="line">&#125;</span><br></pre>
<h1 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4. 方法引用"></a>4. 方法引用</h1><p>方法引用更近一步的优化了Lambda的使用。它让代码感觉更加的自然。我们可以直接使用 :: 来简化Lambda表 达式的使用。其使用语法如下： 类名或实例名::方法名  </p>
<pre class="highlight"><span class="line">students.sort(Comparator.comparing(Student::getId)); </span><br></pre>
<h1 id="5-Stream流使用"><a href="#5-Stream流使用" class="headerlink" title="5. Stream流使用"></a><strong>5. Stream</strong>流使用</h1><blockquote>
<p>流操作是Java8提供一个重要新特性，它允许开发人员以声明性方式处理集合，其<strong>核心类库主要改进了对集合类的 API和新增Stream操作</strong>。Stream类中每一个方法都对应集合上的一种操作。将真正的函数式编程引入到Java中，能 让代码更加简洁，极大地简化了集合的处理操作，提高了开发的效率和生产力。 </p>
<p>同时<strong>stream</strong>不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，<strong>Java</strong>容器或<strong>I/O</strong> channel<strong>等。在</strong>Stream**中的操作每一次都会产生新的流，内部不会像普通集合操作一样立刻获取值，而是惰性 取值，只有等到用户真正需要结果的时候才会执行。 </p>
</blockquote>
<pre class="highlight"><span class="line">List&lt;String&gt; result = studentList.stream() </span><br><span class="line">  .filter(s ‐&gt; s.getAge() &lt; <span class="number">20</span>) <span class="comment">//过滤出年龄小于20岁的学生 </span></span><br><span class="line">  .sorted(Comparator.comparing(Student::getAge)) <span class="comment">//对结果进行排序 </span></span><br><span class="line">  .map(Student::getName) <span class="comment">// 提取出结合中的name属性 </span></span><br><span class="line">  .collect(Collectors.toList());<span class="comment">//转换成一个新的集合</span></span><br></pre>
<p>通过上述代码的执行，可以发现<strong>无需再去定义过多的冗余变量</strong>。我们可以将多个操作组成一个调用链，形成数据处理的流水线。在减少代码量的同时也更加的清晰易懂。 </p>
<p>并且对于现在调用的方法，本身都是一种高层次构件，与线程模型无关。因此在并行使用中，<strong>开发者们无需再去操心线程和锁了。Stream内部都已经做好了。</strong></p>
<p>steam流本身就是将集合的操作由外部迭代转换为了内部迭代。而内部迭代来说，它所操作的就是不是一个集合了，而是一个流。它会将所有的操作融合在流中，由其在内部进行处理，这种隐式的方式称之为内部迭代。 </p>
<p><strong>并且内部迭代支持并行处理，更利于集合操作的性能优化。其关注与对数据的计算。</strong> </p>
<h2 id="5-1流操作详解"><a href="#5-1流操作详解" class="headerlink" title="5.1流操作详解"></a>5.1流操作详解</h2><p>Stream流接口中定义了许多对于集合的操作方法,总的来说可以分为两大类:中间操作和终端操作。</p>
<ul>
<li>中间操作:会返回一个流,通过这种方式可以将多个中间操作连接起来,形成一个调用链,从而转换为另外一个流。除非调用链最后存在一个终端操作,否则中间操作对流不会进行任何结果处理。</li>
<li>终端操作:会返回一个具体的结果,如boolean, list, integer等。</li>
</ul>
<h3 id="5-1-1筛选"><a href="#5-1-1筛选" class="headerlink" title="5.1.1筛选"></a>5.1.1筛选</h3><p>对于集合的操作，经常性的会涉及到对于集中符合条件的数据筛选，Stream中对于数据筛选两个常见的API：filter(过滤)、distinct(去重) </p>
<pre class="highlight"><span class="line"><span class="comment">//filter</span></span><br><span class="line">Stream&lt;Student&gt; studentStream = studentList.stream() </span><br><span class="line">																.filter(s‐&gt;s.getAge() &lt; <span class="number">20</span>); <span class="comment">//.filter(Student::getIsPass);</span></span><br><span class="line">List&lt;Student&gt; list = studentStream.collect(Collectors.toList());</span><br><span class="line"><span class="comment">//distinct 对对象进行去重的话，还需要在对象内部重写，hashCode()和equals()方法才可以实现去重。</span></span><br><span class="line">List&lt;Integer&gt; result = numberList.stream() </span><br><span class="line">  .filter(n ‐&gt; n % <span class="number">2</span> == <span class="number">0</span>) </span><br><span class="line">  .distinct() </span><br><span class="line">  .collect(Collectors.toList());</span><br></pre>
<h3 id="5-1-2-切片"><a href="#5-1-2-切片" class="headerlink" title="5.1..2 切片"></a>5.1..2 切片</h3><blockquote>
<p>基于**limit()**实现数据截取,该方法会返回一个不超过给定长度的流。</p>
<p>对于limit方法的实现，它会接收截取的长度，如果该值小于0，则抛出异常，否则会继续向下调用 </p>
</blockquote>
<pre class="highlight"><span class="line">List&lt;Integer&gt; numberList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line">List&lt;Integer&gt; collect = numberList.stream().limit(<span class="number">5</span>).collect(Collectors.toList());</span><br></pre>
<blockquote>
<p>基于**skip()**实现数据跳过,刚才已经基于limit完成了数据截取，但是limit对于数据截取是从前往后截取几个。如果现在对结果只获取后几个怎么办呢？此时就需要使用skip()。其与limit()的使用是相辅相成的。 </p>
<p>在skip方法中接收的n代表的是要跳过的元素个数，如果n小于0，抛出非法参数异常，如果n等于0，则返回当前 流。如果n小于0，才会调用makeRef()。同时指定limit参数为-1. </p>
</blockquote>
<pre class="highlight"><span class="line">List&lt;Integer&gt; numberList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line">List&lt;Integer&gt; collect = numberList.stream().limit(<span class="number">5</span>).skip(<span class="number">2</span>).collect(Collectors.toList());</span><br></pre>
<h3 id="5-1-3映射"><a href="#5-1-3映射" class="headerlink" title="5.1.3映射"></a>5.1.3映射</h3><blockquote>
<p>在对集合进行操作的时候，我们经常会从某些对象中选择性的提取某些元素的值，就像编写sql一样，指定获取表 中特定的数据列 </p>
<p>#指定获取特定列  SELECT name FROM student; </p>
<p>在Stream API中也提供了类似的方法，map()。它接收一个函数作为方法参数，这个函数会被应用到集合中每一个 元素上，并最终将其映射为一个新的元素。 </p>
</blockquote>
<pre class="highlight"><span class="line"><span class="comment">//获取每一个学生的名字，并形成一个新的集合 </span></span><br><span class="line">List&lt;String&gt; nameList = studentList.stream() </span><br><span class="line">  .map(Student::getName) </span><br><span class="line">  .collect(Collectors.toList());</span><br><span class="line"><span class="comment">//获取每一个学生名字的长度</span></span><br><span class="line">List&lt;Integer&gt; nameList = studentList.stream()</span><br><span class="line">  .map(Student::getName)</span><br><span class="line">  .map(String::length) <span class="comment">//也可以继续向下获取每一个名称的长度 </span></span><br><span class="line">  .collect(Collectors.toList());</span><br></pre>
<h3 id="5-1-4匹配"><a href="#5-1-4匹配" class="headerlink" title="5.1.4匹配"></a>5.1.4匹配</h3><blockquote>
<p>有时还需要判断集合中某些元素是否匹配对应的条件，如果有的话，在进行后续的操作。在 Stream API中也提供了相关方法供我们进行使用，如anyMatch、allMatch等。他们对应的就是&amp;&amp;和||运算符。</p>
<p>anyMatch()主要用于判断流中是否至少存在一个符合条件的元素，它会返回一个boolean值，并且对于它的操作， 一般叫做短路求值 (某些操作不用操作整个流就可以得到结果:&amp;&amp;  || )</p>
</blockquote>
<pre class="highlight"><span class="line"><span class="comment">//anyMatch执行时，只要流中有一个元素符合条件就会返回true</span></span><br><span class="line"><span class="keyword">if</span> (studentList.stream().anyMatch(s‐&gt;s.getAge()&lt;<span class="number">20</span>))&#123; </span><br><span class="line">		System.out.println(<span class="string">&quot;集合中有符合条件的学生&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//allMatch会判断流中是否所有条件都符合条件，全部符合才会返回true</span></span><br><span class="line"><span class="keyword">if</span> (studentList.stream().allMatch(Student::getIsPass))&#123; </span><br><span class="line">  System.out.println(<span class="string">&quot;所有学生合格&quot;</span>); </span><br><span class="line">&#125;<span class="keyword">else</span> &#123; </span><br><span class="line">  System.out.println(<span class="string">&quot;有学生不合格&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre>
<h3 id="5-1-5查找"><a href="#5-1-5查找" class="headerlink" title="5.1.5查找"></a>5.1.5查找</h3><ul>
<li>findany</li>
</ul>
<blockquote>
<p>fifindAny用于获取流中随机的某一个元素，并且利用短路在找到结果时，立即结束。</p>
<p>fifindAny对于同一数据源的多次操作会返回不同的结果。但是，如果我们的操作是串行的， 在数据较少的情况下，一般会返回第一个结果，如果在并行的情况下，那就不能确保返回的是第一个了。 </p>
<p>这种设计主要是为了获取更加高效的性能</p>
</blockquote>
<pre class="highlight"><span class="line">Optional&lt;Student&gt; optional = studentList.stream().filter(s ‐&gt; s.getAge() &lt; <span class="number">20</span>).findAny(); </span><br><span class="line"><span class="keyword">if</span> (optional.isPresent())&#123; </span><br><span class="line">	System.out.println(optional.get()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并行流</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123; </span><br><span class="line">  Optional&lt;Student&gt; optional = studentList.parallelStream().filter(s ‐&gt; s.getAge() &lt; <span class="number">20</span>).findAny();</span><br><span class="line">  <span class="keyword">if</span> (optional.isPresent())&#123; </span><br><span class="line">    System.out.println(optional.get()); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre>
<ul>
<li>findFirst</li>
</ul>
<blockquote>
<p>fifindFirst使用原理与fifindAny类似，但不管是在并行还是串行，指定返回流中的第一个元素。 </p>
</blockquote>
<pre class="highlight"><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123; </span><br><span class="line">  Optional&lt;Student&gt; optional = studentList </span><br><span class="line">    .stream() </span><br><span class="line">    <span class="comment">//.parallelStream() </span></span><br><span class="line">    .filter(s ‐&gt; s.getAge() &lt; <span class="number">20</span>) </span><br><span class="line">    .findFirst(); </span><br><span class="line">  <span class="keyword">if</span> (optional.isPresent())&#123; </span><br><span class="line">    System.out.println(optional.get()); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre>
<h3 id="5-1-6-归约"><a href="#5-1-6-归约" class="headerlink" title="5.1.6 归约"></a>5.1.6 归约</h3><blockquote>
<p>到现在截止，对于流的终端操作，我们返回的有boolean、Optional和List。但是在集合操作中，我们经常会涉及 对元素进行统计计算之类的操作，如求和、求最大值、最小值等，从而返回不同的数据结果。 </p>
</blockquote>
<h4 id="5-1-6-1基于-reduce-进行累积求和"><a href="#5-1-6-1基于-reduce-进行累积求和" class="headerlink" title="5.1.6.1基于**reduce()**进行累积求和"></a>5.1.6.1基于**reduce()**进行累积求和</h4><pre class="highlight"><span class="line"><span class="comment">//第一个参数声明为初始值，第二个参数接收一个lambda表达式，代表当前流中的两 个元素，它会反复相加每一个元素，直到流被归约成一个最终结果</span></span><br><span class="line">Integer reduce = numbers.stream().reduce(<span class="number">0</span>, (a, b) ‐&gt; a + b);</span><br><span class="line"><span class="comment">//优化:Integer类中提供了sum方法，用于对两个数求和，这里我们可 以直接基于lambda方法调用的形式来使用</span></span><br><span class="line">Integer reduce = numbers.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="comment">//继续优化:reduce方法还有一个重载方法，不需要初始化值，会返回一个 Optional对象</span></span><br><span class="line">Optional&lt;Integer&gt; optional = numbers.stream().reduce(Integer::sum);</span><br></pre>
<h4 id="5-1-6-2最大值最小值"><a href="#5-1-6-2最大值最小值" class="headerlink" title="5.1.6.2最大值最小值"></a>5.1.6.2最大值最小值</h4><pre class="highlight"><span class="line"><span class="comment">//最大值</span></span><br><span class="line">Optional&lt;Integer&gt; optional = numbers.stream().reduce(Integer::max)</span><br><span class="line"><span class="comment">//优化</span></span><br><span class="line">Optional&lt;Integer&gt; optional = numbers.stream().max(Integer::compareTo);</span><br><span class="line"><span class="comment">//最小值</span></span><br><span class="line">Optional&lt;Integer&gt; min = numbers.stream().min(Integer::compareTo);</span><br></pre>
<h2 id="5-2构建流"><a href="#5-2构建流" class="headerlink" title="5.2构建流"></a>5.2构建流</h2><blockquote>
<p>难道Stream只能在集合基础上才能操作么？当然不是，我们还可以基于值、数组甚至文件来构建流，完成流操作。</p>
</blockquote>
<h3 id="5-2-1基于值创建流"><a href="#5-2-1基于值创建流" class="headerlink" title="5.2.1基于值创建流"></a>5.2.1基于值创建流</h3><blockquote>
<p>在Stream中提供了一个静态方法of，它可以接收任意数量参数，显式的创建一个流。并且会根据传入的参数类 型，构建不同泛型的流。</p>
<p>其内部就是基于Arrays中的stream方法将传入的多个参数转换为数组，然后创建流，并遍历数组，将每一个元素放入流中。</p>
</blockquote>
<pre class="highlight"><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>); </span><br><span class="line">Stream&lt;Object&gt; stream = Stream.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">3</span>,<span class="keyword">true</span>,<span class="keyword">new</span> St());</span><br></pre>
<h3 id="5-2-2基于数组创建流"><a href="#5-2-2基于数组创建流" class="headerlink" title="5.2.2基于数组创建流"></a>5.2.2基于数组创建流</h3><pre class="highlight"><span class="line">Integer[] numbers = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; integerStream = Arrays.stream(numbers);</span><br></pre>
<h3 id="5-2-3基于文件创建流"><a href="#5-2-3基于文件创建流" class="headerlink" title="5.2.3基于文件创建流"></a>5.2.3基于文件创建流</h3><blockquote>
<p>在Java中 提供了Files类，该类中提供了一些对于文件操作的相关方法。可以看下Files类中部分方法</p>
<p>在该类中部分方法返回值就是Stream，如：newDirectoryStream、list、lines等。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201002221915020.png" alt="image-20201002221915020" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201002221915020.png" class="lozad post-image"></p>
<h2 id="5-3收集器"><a href="#5-3收集器" class="headerlink" title="5.3收集器"></a>5.3收集器</h2><blockquote>
<p>对于数据的返回，我们返回的都是一些简单的数据类型。那现在我们要做一些复杂的数据返回，应该怎么做呢？ 比方说返回一个Map或者Map。就需要通过收集器来实现了</p>
<p>其内部主要核心是通过Collectors完成更加复杂的计算转换，从而获取到最终结果。并且Collectors内部提供了非常多的常用静态方法，直接拿来就可以了。比方说：toList。 </p>
</blockquote>
<pre class="highlight"><span class="line"><span class="comment">//根据年龄进行分组</span></span><br><span class="line">Map&lt;Integer, List&lt;Student&gt;&gt; map = studentList.stream().collect(Collectors.groupingBy(Student::getAge));</span><br></pre>
<h3 id="5-3-1-通过-counting-统计集合总数"><a href="#5-3-1-通过-counting-统计集合总数" class="headerlink" title="5.3.1 通过**counting()**统计集合总数"></a>5.3.1 通过**counting()**统计集合总数</h3><pre class="highlight"><span class="line">Long collect = studentList.stream().collect(Collectors.counting());</span><br><span class="line"><span class="comment">//简写</span></span><br><span class="line"><span class="keyword">long</span> count = studentList.stream().count();</span><br></pre>
<h3 id="5-3-2-通过maxBy-与minBy-获取最大值最小值"><a href="#5-3-2-通过maxBy-与minBy-获取最大值最小值" class="headerlink" title="5.3.2 通过maxBy()**与minBy()**获取最大值最小值"></a>5.3.2 通过<strong>maxBy()**与</strong>minBy()**获取最大值最小值</h3><pre class="highlight"><span class="line"><span class="comment">//获取年龄最大的学生 </span></span><br><span class="line">Optional&lt;Student&gt; optional = studentList.stream().collect(Collectors.maxBy(Comparator.comparing(Student::getAge)));</span><br><span class="line"><span class="comment">//优化</span></span><br><span class="line">Optional&lt;Student&gt; studentOptional = studentList.stream().max(Comparator.comparing(Student::getAge));</span><br><span class="line"><span class="comment">//获取年龄最小的学生 </span></span><br><span class="line">Optional&lt;Student&gt; studentOptional = studentList.stream().min(Comparator.comparing(Student::getAge));</span><br></pre>
<h3 id="5-3-3-通过-summingInt-进行数据汇总"><a href="#5-3-3-通过-summingInt-进行数据汇总" class="headerlink" title="5.3.3 通过**summingInt()**进行数据汇总"></a>5.3.3 通过**summingInt()**进行数据汇总</h3><pre class="highlight"><span class="line"><span class="comment">//获取年龄总和</span></span><br><span class="line">Integer collect = studentList.stream().collect(Collectors.summingInt(Student::getAge));</span><br><span class="line"><span class="comment">//简化</span></span><br><span class="line"><span class="keyword">int</span> sum = studentList.stream().mapToInt(Student::getAge).sum();</span><br></pre>
<h3 id="5-3-4-通过-averagingInt-进行平均值获取"><a href="#5-3-4-通过-averagingInt-进行平均值获取" class="headerlink" title="5.3.4 通过**averagingInt()**进行平均值获取"></a>5.3.4 通过**averagingInt()**进行平均值获取</h3><pre class="highlight"><span class="line">Double collect = studentList.stream().collect(Collectors.averagingInt(Student::getAge));</span><br><span class="line"><span class="comment">//另外一种 这种方式虽然代码写多了一些，但是可以防止空值的出现。</span></span><br><span class="line">OptionalDouble average = studentList.stream().mapToDouble(Student::getAge).average(); </span><br><span class="line"><span class="keyword">if</span> (average.isPresent())&#123; </span><br><span class="line">  <span class="keyword">double</span> asDouble = average.getAsDouble(); </span><br><span class="line">  System.out.println(asDouble); </span><br><span class="line">&#125;</span><br></pre>
<h3 id="5-3-5复杂结果返回"><a href="#5-3-5复杂结果返回" class="headerlink" title="5.3.5复杂结果返回"></a>5.3.5复杂结果返回</h3><blockquote>
<p>到此截止，已经通过收集器完成了汇总、求和、求最大最小值、求平均值的操作。但是值得注意的是，这些操作每 一次都是返回单独的一个值，但是日常开发中，经常需要获取多种内容，那这种需求应该如何完成？Collectors也 提供了相关静态方法进行解决，这三个方法可以，返回的都是收集器。其内部已经包含了多种结果内容 </p>
<p>上述方法返回了IntSummaryStatistics类，其内部提供了相关getter方法用于获取汇总值、总和、最大值最小值等 方法，直接调用即可 </p>
<p>对于另外的summarizingDouble()和summarizingLong()使用方式都是相同的。只不过他们适用于收集属性数据类 型为double和long而已。 </p>
</blockquote>
<pre class="highlight"><span class="line">IntSummaryStatistics collect = studentList.stream().collect(Collectors.summarizingInt(Student::getAge));</span><br><span class="line"><span class="keyword">long</span> count = collect.getCount(); </span><br><span class="line"><span class="keyword">long</span> sum = collect.getSum(); </span><br><span class="line"><span class="keyword">int</span> max = collect.getMax(); </span><br><span class="line"><span class="keyword">int</span> min = collect.getMin(); </span><br><span class="line"><span class="keyword">double</span> average = collect.getAverage();</span><br></pre>
<h3 id="5-3-6通过-joining-进行数据拼接"><a href="#5-3-6通过-joining-进行数据拼接" class="headerlink" title="5.3.6通过**joining()**进行数据拼接"></a>5.3.6通过**joining()**进行数据拼接</h3><pre class="highlight"><span class="line">String collect = studentList.stream().map(Student::getName).collect(Collectors.joining());</span><br><span class="line">String collect = studentList.stream().map(Student::getName).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br></pre>
<h3 id="5-3-7-分组"><a href="#5-3-7-分组" class="headerlink" title="5.3.7 分组"></a>5.3.7 分组</h3><pre class="highlight"><span class="line"><span class="comment">//一级分组 根据年龄分组</span></span><br><span class="line">Map&lt;Integer, List&lt;Student&gt;&gt; map = studentList.stream().collect(Collectors.groupingBy(Student::getAge))</span><br><span class="line"><span class="comment">//根据年龄 是否通过进行多级分组</span></span><br><span class="line">Map&lt;Integer, Map&lt;String, List&lt;Student&gt;&gt;&gt; collect = studentList.stream().collect(Collectors.groupingBy(Student::getAge, Collectors.groupingBy(student ‐&gt; &#123; </span><br><span class="line">  <span class="keyword">if</span> (student.getIsPass()) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;pass&quot;</span>; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;not pass&quot;</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;)));</span><br><span class="line"><span class="comment">//多级分组变形 </span></span><br><span class="line"><span class="comment">//根据年龄进行分组，获取并汇总人数 </span></span><br><span class="line">Map&lt;Integer, Long&gt; collect = studentList.stream().collect(Collectors.groupingBy(Student::getAge, Collectors.counting())); </span><br><span class="line"><span class="comment">//根据年龄与是否及格进行分组，并汇总人数</span></span><br><span class="line">Map&lt;Integer, Map&lt;Boolean, Long&gt;&gt; collect = studentList.stream().collect(Collectors.groupingBy(Student::getAge, Collectors.groupingBy(Student::getIsPass, Collectors.counting())));</span><br><span class="line"><span class="comment">//根据年龄与是否及格进行分组，并获取每组中分数最高的学生</span></span><br><span class="line">Map&lt;Integer, Map&lt;Boolean, Student&gt;&gt; collect = studentList.stream().collect( Collectors.groupingBy(Student::getAge, </span><br><span class="line">                                                                                               		Collectors.groupingBy(Student::getIsPass, </span><br><span class="line">                                                                                                                     			Collectors.collectingAndThen( </span><br><span class="line">                                                                                                                       				Collectors.maxBy( </span><br><span class="line">                                                                                                                         						Comparator.comparing(Student::getScore)), Optional::get))));</span><br></pre>
<h3 id="5-3-8-自定义收集器"><a href="#5-3-8-自定义收集器" class="headerlink" title="5.3.8 自定义收集器"></a>5.3.8 自定义收集器</h3><blockquote>
<p>根据源码，Collector接口需要三个参数。T：流中要收集的元素类型、A：累加器的类型、R：收集的结果类型。 </p>
<p>如想自定义收集器，需要实现Collector接口中的五个方法：supplier、accumulator、fifinisher、combiner、 </p>
<p>characteristics </p>
<ul>
<li><p>supplier：用于创建一个容器，在调用它时，需要创建一个空的累加器实例，供后续方法使用。 </p>
</li>
<li><p>accumulator：基于supplier中创建的累加容器，进行累加操作。 </p>
</li>
<li><p>fifinisher：当遍历完流后，在其内部完成最终转换，返回一个最终结果。 </p>
</li>
<li><p>combiner：用于在并发情况下，将每个线程的容器进行合并。 </p>
</li>
<li><p>characteristics：用于定义收集器行为，如是否可以并行或使用哪些优化。其本身是一个枚举，内部有三个值，分别为： </p>
<p>CONCURRENT：表明收集器是并行的且只会存在一个中间容器。 </p>
<p>UNORDERED：表明结果不受流中顺序影响，收集是无序的。 </p>
<p>IDENTITY_FINISH：表明累积器的结果将会直接作为归约的最终结果，跳过fifinisher()。 </p>
</li>
</ul>
</blockquote>
<p>自定义收集器，返回所有合格的学员:</p>
<p><img src="http://mele.cool/image-20201002225245978.png" alt="image-20201002225245978" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201002225245978.png" class="lozad post-image"></p>
<p>使用自定义收集器 :</p>
<p><img src="http://mele.cool/image-20201002225308032.png" alt="image-20201002225308032" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201002225308032.png" class="lozad post-image"></p>
<h1 id="6-数据并行化"><a href="#6-数据并行化" class="headerlink" title="6.数据并行化"></a>6.数据并行化</h1><blockquote>
<p>为了让数据处理更加高效，Java8对于Stream也提供了并行的操作方式，在Java7之前如果要对数据并行处理，需要开发人员做的事情很多，如数据如何进行分块、开启多少个线程、哪个线程负责哪部分数据、出现线程竞争怎么办等等的问题。 </p>
<p>Java8对于数据并行化处理的实现非常简单，直接调用一个parallelStream()就可以开启并行化处理。</p>
<ul>
<li>并行：多个任务在同一时间点发生，并由不同的cpu进行处理，不互相抢占资源</li>
<li>并发：多个任务在同一时间点内同时发生了，但由同一个cpu进行处理，互相抢占资源</li>
</ul>
<p>当在大量数据处理上，数据并行化可以大量缩短任务的执行时间，将一个数据分解成多个部分，然后并行处理，最后将多个结果汇总，得到最终结果。 </p>
<p>int sum = numbers.parallelStream().mapToInt(i ‐&gt; i).sum(); </p>
<p>当将stream()切换为parallelStream()后，则完成了串行转换为并行的实现。 </p>
</blockquote>
<h2 id="6-1并行流原理"><a href="#6-1并行流原理" class="headerlink" title="6.1并行流原理"></a>6.1并行流原理</h2><p>对于并行流，其在底层实现中，是沿用了Java7提供的fork/join分解合并框架进行实现。fork根据<strong>cpu</strong>核数进行数据分块，join对各个fork进行合并。实现过程如下所示：</p>
<p><img src="http://mele.cool/image-20201002225809916.png" alt="image-20201002225809916" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201002225809916.png" class="lozad post-image"></p>
<h2 id="6-2并行流注意事项"><a href="#6-2并行流注意事项" class="headerlink" title="6.2并行流注意事项"></a>6.2并行流注意事项</h2><p>对于并行流，一定不要陷入一个误区：并行一定比串行快。并行在不同的情况下它不一定是比串行快的。影响并行流性能主要存在5个因素： </p>
<p><strong>1）数据大小：</strong>输入数据的大小，直接影响了并行处理的性能。因为在并行内部实现中涉及到了fork/join操作，它本身就存在性能上的开销。因此<strong>只有当数据量很大，使用并行处理才有意义。</strong> </p>
<p><strong>2）源数据结构</strong>：fork时会对源数据进行分割，数据源的特性直接影响了fork的性能。 </p>
<ul>
<li>ArrayList、数组或IntStream.range，可分解性最佳，因为他们都支持随机读取，因此可以被任意分割。 </li>
<li>HashSet、TreeSet，可分解性一般，其虽然可被分解，但因为其内部数据结构，很难被平均分解。 </li>
<li>LinkedList、Streams.iterate、BufferedReader.lines，可分解性极差，因为他们长度未知，无法确定在哪里进行分割。 </li>
</ul>
<p><strong>3）装箱拆箱</strong> </p>
<ul>
<li><strong>尽量使用基本数据类型，避免装箱拆箱。</strong> </li>
</ul>
<p><strong>4）CPU核数</strong> </p>
<ul>
<li>fork的产生数量是与可用CPU核数相关，可<strong>用的核数越多，获取的性能提升就会越大。</strong> </li>
</ul>
<p><strong>5）单元处理开销</strong> </p>
<ul>
<li><strong>花在流中每个元素的时间越长，并行操作带来的性能提升就会越明显</strong>。 </li>
</ul>
<h2 id="6-3结论"><a href="#6-3结论" class="headerlink" title="6.3结论"></a>6.3结论</h2><p>*<em>根据性能测试可知，对于简单操作，如果环境机是多核的话，建议使用Stream并行，同时在不考虑核数的情况</em>下，普通for循环性能要明显高于Stream串行，相差两倍左右。**</p>
<p><strong>对于复杂操作，推荐使用Stream API操作。</strong> </p>
<h1 id="7-异步编程CompletableFuture"><a href="#7-异步编程CompletableFuture" class="headerlink" title="7.异步编程CompletableFuture"></a>7.异步编程CompletableFuture</h1><blockquote>
<p>在现在软件开发的环境下，经常需要考虑如何能够设计出性能更加优异的系统。就像上面提到的数据并行化，就 是充分利用多核处理器结合并行操作来让代码执行效率更加优异。第二种方式就是让功能方法能够并行执行(异步编程CompletableFuture)。 </p>
</blockquote>
<h2 id="7-1Future介绍"><a href="#7-1Future介绍" class="headerlink" title="7.1Future介绍"></a>7.1Future介绍</h2><p>有的同学会说，对于任务并行需求，直接通过多线程实现不就可以了， 要注意，对于多线程的实现，java提 供了三种方式：继承Thread类、实现Runnable接口和实现Callable接口。但是业务代码在执行时会考虑执行顺序 的问题，直接基于这些方式实现多线程会出现两个问题： </p>
<p>1）要想控制线程执行顺序，会通过join()等待线程结束，那这样的话又回归到了阻塞式调用的思路上，违背了并行的需求。 另外还可以通过wait()、notify()、notifyAll()结合状态变量实现，但实现起来过于复杂。 </p>
<p>2）线程执行完之后，要想获取线程执行结果，还要用过共享变量或线程间通信等方式来获取，同样过于复杂。 为了解决上述问题，Java5中推出了<strong>Future</strong>，其初衷就是用于构建复杂并行操作。内部方法在返回时，不是返回一个值，而是返回Future对象。 其本质是在执行主业务的同时，异步的执行其他分业务，从而利用原本需要同步执行时的等待时间去执行其他的业 务，当需要获取其结果时，再进行获取。 </p>
<p><strong>在Future接口中有五个抽象方法：</strong> </p>
<ol>
<li>cancel()：取消任务, 取消成功返回true；入参mayInterruptIfRunning表示是否允许取消正在执行中的任务。 </li>
<li>isCancelled()：返回布尔值，代表是否取消成功。</li>
<li>isDone()：返回布尔值，代表是否执行完毕。 </li>
<li>get()：返回Future对象，获取执行结果，如果任务没有完成会阻塞到任务完成再返回。 </li>
<li>get(long timeout, TimeUnit unit)：获取执行结果并设置超时时间，如果超时则抛出TimeoutException </li>
</ol>
<h2 id="7-2CompletableFuture"><a href="#7-2CompletableFuture" class="headerlink" title="7.2CompletableFuture"></a>7.2CompletableFuture</h2><p>CompletableFuture是Java1.8提供的一个新类，其实现了Future与CompletionStage两个接口。提供了诸多API扩展功能，可以通过Stream形式简化异步编程的复杂度，同时提供通过回调方式处理计算结果。</p>
<h3 id="7-2-1-异步任务创建"><a href="#7-2-1-异步任务创建" class="headerlink" title="7.2.1 异步任务创建"></a>7.2.1 异步任务创建</h3><p>在CompletableFuture中提供了四个静态方法用于创建异步任务 </p>
<pre class="highlight"><span class="line"><span class="comment">//根据源码可知，runAsync()分为一个参数和两个参数，并且其内部都会调用asyncRunStage().</span></span><br><span class="line"><span class="comment">//在该方法内部会创建异步任务，并把任务放入线程池中。并且runAsync()是没有返回值的。</span></span><br><span class="line"><span class="comment">//根据源码可知，当传入Executor会使用指定线程池执行，如果没有传入则使用默认ForkJoinPool.commonPool()执 行，值得注意的是，commonPool中都是守护线程，主线程执行完，子线程也就over了。因此建议当任务非常耗 时，使用自定义线程池。</span></span><br><span class="line"><span class="number">1.</span>runAsync(Runnable runnable) </span><br><span class="line"><span class="number">2.</span>runAsync(Runnable runnable,Executor executor) </span><br><span class="line"><span class="comment">//根据源码可知，supplyAsync()分为一个参数和两个参数，并且其内部都会调用asyncSupplyStage().</span></span><br><span class="line">  <span class="comment">//现在可知，其实supplyAsync()与runAsync()内部原理类似，但supplyAsync()有返回值。</span></span><br><span class="line"><span class="number">3.</span>supplyAsync(Supplier&lt;U&gt; supplier) </span><br><span class="line"><span class="number">4.</span>supplyAsync(Supplier&lt;U&gt; supplier,Executor executor)</span><br><span class="line">  </span><br></pre>
<p>使用示例:</p>
<p><img src="http://mele.cool/image-20201002232340066.png" alt="image-20201002232340066" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201002232340066.png" class="lozad post-image"></p>
<h3 id="7-2-2-异步计算结果触发回调"><a href="#7-2-2-异步计算结果触发回调" class="headerlink" title="7.2.2 异步计算结果触发回调"></a>7.2.2 异步计算结果触发回调</h3><blockquote>
<p>当异步任务结束或者抛出异常时，还要根据结果来完成特定的操作，对于这种需求CompletableFuture也提供了方法进行实现 </p>
</blockquote>
<h4 id="7-2-2-1whenComplete-与whenCompleteAsync"><a href="#7-2-2-1whenComplete-与whenCompleteAsync" class="headerlink" title="7.2.2.1whenComplete()**与whenCompleteAsync()**"></a><strong>7.2.2.1whenComplete()**与</strong>whenCompleteAsync()**</h4><p>whenComplete是在当前任务线程中继续执行指定的特定处理，而whenCompleteAsync会将指定的特定交给线程池另开启一个线程来执行。</p>
<p><img src="http://mele.cool/image-20201003162011657.png" alt="image-20201003162011657" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201003162011657.png" class="lozad post-image"></p>
<h4 id="7-2-2-2-exceptionally"><a href="#7-2-2-2-exceptionally" class="headerlink" title="7.2.2.2 exceptionally()"></a>7.2.2.2 <strong>exceptionally()</strong></h4><blockquote>
<p>exceptionally()与上述两个方法类似，都是用于当异步任务结束后，执行特定处理，但不同的是，上述两个方法即 可以处理正常的返回结果也可以处理异常，而exceptionally()只对异常进行处理，且其使用的是主线程。</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003162122297.png" alt="image-20201003162122297" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201003162122297.png" class="lozad post-image"></p>
<h3 id="7-2-3-多任务依赖执行"><a href="#7-2-3-多任务依赖执行" class="headerlink" title="7.2.3 多任务依赖执行"></a>7.2.3 多任务依赖执行</h3><h4 id="7-2-3-1-thenApply"><a href="#7-2-3-1-thenApply" class="headerlink" title="7.2.3.1 thenApply()"></a>7.2.3.1 <strong>thenApply()</strong></h4><blockquote>
<p>该方法会接收一个Function，用于声明后续要执行的业务，其中T代表上一个方法的执行结果，fn代表当前任务的 结果数据类型，最终其会映射到CompletableFuture中的结果数据类型。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003162440304.png" alt="image-20201003162440304" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201003162440304.png" class="lozad post-image"></p>
<p>根据运行结果可以看到，此处通过thenApply()串接了两个任务，第二个方法会在第一个方法执行完成后触发，且第二个方法的执行依赖于第一个方法的执行结果。 </p>
<h4 id="7-2-3-2-handle"><a href="#7-2-3-2-handle" class="headerlink" title="7.2.3.2 handle()"></a>7.2.3.2 <strong>handle()</strong></h4><blockquote>
<p>handle()的使用效果与thenApply()类似，但不同的是thenApply()只能处理任务的正常返回结果，一旦出现异常则 无法进行后续处理。而handle()即可以处理正常结果，也可以处理异常结果。</p>
<p>当第一个任务出现异常后，第二个任务会对该异常进行后续的处理，完成串性操作。</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003162616742.png" alt="image-20201003162616742" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201003162616742.png" class="lozad post-image"></p>
<h4 id="7-2-3-3-thenAccept"><a href="#7-2-3-3-thenAccept" class="headerlink" title="7.2.3.3 thenAccept()"></a>7.2.3.3 <strong>thenAccept()</strong></h4><blockquote>
<p>当将多个任务连接起来执行时，有时最终是不需要返回结果，CompletableFuture中也提供了方法实现。 thenAccept()使用与上述方法类似，接收任务执行结果，并使用，但其没有结果返回。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003162744285.png" alt="image-20201003162744285" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201003162744285.png" class="lozad post-image"></p>
<h4 id="7-2-3-4-thenRun"><a href="#7-2-3-4-thenRun" class="headerlink" title="7.2.3.4  thenRun()"></a>7.2.3.4  <strong>thenRun()</strong></h4><blockquote>
<p>thenRun()与thenAccept()使用基本相同，都是不会进行结果返回，但不同的是，thenRun()不关心方法是否有结 果，只要它完成，就会触发其执行。</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003162822708.png" alt="image-20201003162822708" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201003162822708.png" class="lozad post-image"></p>
<h3 id="7-2-4-两任务合并执行"><a href="#7-2-4-两任务合并执行" class="headerlink" title="7.2.4 两任务合并执行"></a>7.2.4 两任务合并执行</h3><h4 id="7-2-4-1-两个任务全部完成触发"><a href="#7-2-4-1-两个任务全部完成触发" class="headerlink" title="7.2.4.1 两个任务全部完成触发"></a>7.2.4.1 两个任务全部完成触发</h4><h5 id="7-2-4-1-1-thenCombine"><a href="#7-2-4-1-1-thenCombine" class="headerlink" title="7.2.4.1.1 thenCombine()"></a>7.2.4.1.1 <strong>thenCombine()</strong></h5><blockquote>
<p>当两个异步任务都执行完毕后，它可以将两个任务进行合并，获取到两个任务的执行结果，进行合并处理，最后会有返回值。 </p>
<p>内部会判断当前要执行的函数是否为null，或者任务有没有执行完。如果为true，则抛出空指针异常。接着会构建 一个新的任务，将任务放入栈中，线程池会为其分配线程让其执行。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163113414.png" alt="image-20201003163113414" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201003163113414.png" class="lozad post-image"></p>
<h5 id="7-2-4-1-2-thenAcceptBoth"><a href="#7-2-4-1-2-thenAcceptBoth" class="headerlink" title="7.2.4.1.2 thenAcceptBoth()"></a>7.2.4.1.2 <strong>thenAcceptBoth()</strong></h5><blockquote>
<p>thenAcceptBoth()使用与thenCombine()类似，当两个任务执行完，获取两个任务的结果进行特定处理，但 thenAcceptBoth()没有返回值 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163229028.png" alt="image-20201003163229028" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201003163229028.png" class="lozad post-image"></p>
<h5 id="7-2-4-1-3-runAfterBoth"><a href="#7-2-4-1-3-runAfterBoth" class="headerlink" title="7.2.4.1.3 runAfterBoth()"></a>7.2.4.1.3 <strong>runAfterBoth()</strong></h5><blockquote>
<p>当两个任务执行完毕，触发特定任务处理，但不要两个异步任务结果，且不会进行值返回。</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163318219.png" alt="image-20201003163318219" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201003163318219.png" class="lozad post-image"></p>
<h4 id="7-2-4-2-两个任务任意一个完成触发"><a href="#7-2-4-2-两个任务任意一个完成触发" class="headerlink" title="7.2.4.2 两个任务任意一个完成触发"></a>7.2.4.2 两个任务任意一个完成触发</h4><h5 id="7-2-4-2-1-applyToEither"><a href="#7-2-4-2-1-applyToEither" class="headerlink" title="7.2.4.2.1 applyToEither()"></a>7.2.4.2.1 <strong>applyToEither()</strong></h5><blockquote>
<p>当两个任务异步任务执行，谁先执行完，就以谁的结果为准，完成后续的业务处理，并且会进行结果值返回。</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163436119.png" alt="image-20201003163436119" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201003163436119.png" class="lozad post-image"></p>
<h5 id="7-2-4-2-2-acceptEither"><a href="#7-2-4-2-2-acceptEither" class="headerlink" title="7.2.4.2.2 acceptEither()"></a>7.2.4.2.2 <strong>acceptEither()</strong></h5><blockquote>
<p>acceptEither()的使用效果与applyToEither()类似，但acceptEither()没有返回值</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163527665.png" alt="image-20201003163527665" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201003163527665.png" class="lozad post-image"></p>
<h5 id="7-2-4-2-3-runAfterEither"><a href="#7-2-4-2-3-runAfterEither" class="headerlink" title="7.2.4.2.3 runAfterEither()"></a>7.2.4.2.3 <strong>runAfterEither()</strong></h5><blockquote>
<p>当两个任务执行，只要有一个任务执行完，则触发特定处理执行，无需使用异步任务的执行结果，且特定处理不会进行值的返回。</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163634259.png" alt="image-20201003163634259" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201003163634259.png" class="lozad post-image"></p>
<h3 id="7-2-5-多任务组合执行"><a href="#7-2-5-多任务组合执行" class="headerlink" title="7.2.5 多任务组合执行"></a>7.2.5 多任务组合执行</h3><h4 id="7-2-5-1-allOf"><a href="#7-2-5-1-allOf" class="headerlink" title="7.2.5.1 allOf()"></a>7.2.5.1 <strong>allOf()</strong></h4><blockquote>
<p>当一个特定业务处理任务的执行需要一组异步任务完成后才能执行的话，就可以通过allOf()实现。适用场景：假设现在有一个Z任务，它的执行需要[A,B,C,D,E,F]这一组异步任务全部执行完才能触发。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163858821.png" alt="image-20201003163858821" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201003163858821.png" class="lozad post-image"></p>
<h4 id="7-2-5-2-）anyOf"><a href="#7-2-5-2-）anyOf" class="headerlink" title="7.2.5.2 ）anyOf()"></a>7.2.5.2 ）<strong>anyOf()</strong></h4><blockquote>
<p>使用anyOf()时，当一组异步任务中，只要有一个执行完毕，则会被触发，利用该特性可以用来获取最快的那个线程结果。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003164020818.png" alt="image-20201003164020818" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201003164020818.png" class="lozad post-image"></p>
<h1 id="8-Optional"><a href="#8-Optional" class="headerlink" title="8.Optional"></a>8.Optional</h1><blockquote>
<p>为了防止空指针异常的出现，Java8中引入了一个新类Optional，对于它之前我们已经进行了简单的实现。其本质 就是通过Optional类对值进行封装， 当有值的时候，会把该值封装到Optional类中。如果没有值的话，则会在该 类封装一个Empty </p>
</blockquote>
<h2 id="8-1-创建optional对象"><a href="#8-1-创建optional对象" class="headerlink" title="8.1 创建optional对象"></a>8.1 创建optional对象</h2><pre class="highlight"><span class="line"><span class="comment">//直接返回一个空的Optional实例，内部不会存在任何值。</span></span><br><span class="line">Optional&lt;Student&gt; studentOptional = Optional.empty(); </span><br><span class="line"><span class="comment">//返回一个存在值的Optional对象，并且该值不允许null的存在。如果调用该方法时传入参数 是null，则立刻抛出NullPointerException，而不是等到你用这个对象时才抛出，相当于进行了立即检查。</span></span><br><span class="line">Optional&lt;Student&gt; studentOptional = Optional.of(student);</span><br><span class="line"><span class="comment">//ofNullable()同样也会返回一个存在值的Optional对象，但是它和of()最大的不同在于，它会对传入 的值进行判断，如果传入的值为null，其会调用empty()返回一个不包含内容的Optional，如果不为null，则会调用 of()返回一个包含内容的Optional</span></span><br><span class="line">Optional&lt;Student&gt; studentOptional = Optional.ofNullable(student);</span><br></pre>
<h2 id="8-2基于optional对象获取值"><a href="#8-2基于optional对象获取值" class="headerlink" title="8.2基于optional对象获取值"></a>8.2基于optional对象获取值</h2><blockquote>
<p>Optional类中提供了两个方法用于判断Optional是否有值，分别是i<strong>sPresent()和ifPresent(Consumer&lt;? super T&gt; consumer)**。</strong>其一般与ofNullable()搭配使用**，因为of()在创建时已经完成了判断，而empty()只是单纯了实例化了 一个Optional对象。 </p>
</blockquote>
<ul>
<li><p>**isPresent()**内部非常简单，就是判断这个值是否为null。 </p>
<pre class="highlight"><span class="line">Optional&lt;Student&gt; studentOptional = Optional.ofNullable(student); </span><br><span class="line"><span class="keyword">if</span> (studentOptional.isPresent())&#123; <span class="comment">//存在 </span></span><br><span class="line">  System.out.println(<span class="string">&quot;student存在&quot;</span>); </span><br><span class="line">&#125;<span class="keyword">else</span> &#123; </span><br><span class="line">  System.out.println(<span class="string">&quot;student不存在&quot;</span>); </span><br><span class="line">&#125;</span><br></pre>

</li>
<li><p>**ifPresent()**方法在执行时，接收一个consumer函数式接口，如果value不为null，则通过consumer中的 </p>
<p>accept方法获取该值。 </p>
<pre class="highlight"><span class="line">Optional&lt;Student&gt; studentOptional = Optional.ofNullable(student); studentOptional.ifPresent(s‐&gt; System.out.println(<span class="string">&quot;学生存在&quot;</span>));</span><br></pre>
<ul>
<li><p><strong>get()</strong></p>
<blockquote>
<p>get()的使用非常简单，但不安全，因为其在获取值的时候，如果值存在，则直接返回封装在Optional中的值，如 果不存在，则抛出NoSuchElementException。因此它的使用前提是已经确定Optional中有值，否则没有使用意义。</p>
</blockquote>
</li>
</ul>
<pre class="highlight"><span class="line"><span class="keyword">if</span> (studentOptional.isPresent())&#123; </span><br><span class="line">	Student result = studentOptional.get(); </span><br><span class="line">&#125;</span><br></pre>
<ul>
<li><strong>orElseThrow()</strong></li>
</ul>
<blockquote>
<p>该方法与get()类似，都是用于取值，但是当Optional中没有值时，get()会直接抛出NoSuchElementException， 这样的话，就存在了一定的局限性，因为有时可能需要抛出自定义异常。此时就可以使用orElseThrow()，它在取值时，如果Optional中没有值时，可以抛出自定义异常。 </p>
</blockquote>
</li>
</ul>
<p><img src="http://mele.cool/image-20201003165624398.png" alt="image-20201003165624398" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201003165624398.png" class="lozad post-image"></p>
<ul>
<li><strong>map()</strong></li>
</ul>
<pre class="highlight"><span class="line"><span class="keyword">if</span> (studentOptional.isPresent())&#123;</span><br><span class="line">		Optional&lt;String&gt; nameOptional = studentOptional.map(Student::getName);</span><br><span class="line">	&#125;</span><br></pre>
<ul>
<li><p><strong>flflatMap()</strong></p>
<pre class="highlight"><span class="line"><span class="comment">//Student类添加Job属性 </span></span><br><span class="line"><span class="keyword">private</span> Optional&lt;Job&gt; job; </span><br><span class="line"><span class="comment">//Job类添加Company属性 </span></span><br><span class="line"><span class="keyword">private</span> Optional&lt;ComPany&gt; comPany;</span><br></pre>
<blockquote>
<p><strong>用于多层调用</strong>，同时对于结 果它不会形成多个Optional，而是将结果处理成最终的一个类型的Optional。但是通过flflatMap获取的返回值必须是Optional类型。而map则没有这个限制。</p>
</blockquote>
</li>
</ul>
<pre class="highlight"><span class="line">Optional&lt;String&gt; nameOptional = studentOptional.flatMap(Student::getJob).flatMap(Job::getCompany).map(Company::getName);</span><br></pre>
<ul>
<li><strong>fifilter()</strong></li>
</ul>
<blockquote>
<p>会根据传入的条件进行判断，如果匹配则返回一个Optional对象并包含对应的值，否则返回一个空值的Optional </p>
</blockquote>
<pre class="highlight"><span class="line">Optional&lt;Company&gt; company = companyOptional.filter(c ‐&gt; <span class="string">&quot;itheima&quot;</span>.equals(c.getName()));</span><br></pre>
<ul>
<li><strong>orElse()</strong></li>
</ul>
<blockquote>
<p>在取值的时候，如果值不存在，有时我们会考虑返回一个默认值。该需求就可以通过orElse()实现。 其内部会判断值是否为null，如果不为null，则返回该值，如果为null，则返回传入的默认值。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003170351987.png" alt="image-20201003170351987" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201003170351987.png" class="lozad post-image"></p>
<ul>
<li><strong>orElseGet()</strong></li>
</ul>
<blockquote>
<p>orElseGet()也是用于当Optional中没有值时，返回默认值的方法。但是它与orElse()的区别在于，它是延迟加载 的。只有当Optional中没有值是才会被调用。</p>
<p><strong>在使用时，更加推荐使用orElseGet()，因为它使用延迟调用所以性能更加优异。</strong> </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003170559116.png" alt="image-20201003170559116" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201003170559116.png" class="lozad post-image"></p>
<h1 id="9-日期时间新方式"><a href="#9-日期时间新方式" class="headerlink" title="9.日期时间新方式"></a>9.日期时间新方式</h1><blockquote>
<p>SimpleDateFormat本身是线程不安全的，在多线程环境下，如果多个线程使用同一个类解析日期，最后的结果是 无法预期的。同时继承了它的DateFormat类也不是线程安全的。 </p>
<p><strong>DateTimeFormatter</strong> 该类是不可变和线程的。该类中提供了很多方法用于替换SimpleDateFormat。基于DateTimeFormatter改造</p>
</blockquote>
<ul>
<li><strong>LocalDate</strong>介绍 根据源码可知，该类是一个不可变，线程安全的类。其内部了提供了若干用于操作日期的方法</li>
<li><strong>LocalTime</strong>介绍 LocalTime类可以用来操作时间</li>
<li><strong>LocalDateTime</strong>介绍 LocalDateTime类可以用来操作日期+时间。</li>
</ul>
<h1 id="10-jdk11新特性"><a href="#10-jdk11新特性" class="headerlink" title="10.jdk11新特性"></a>10.jdk11新特性</h1><h2 id="1）变量类型推断"><a href="#1）变量类型推断" class="headerlink" title="1）变量类型推断"></a>1）变量类型推断</h2><p>在JS中，不管类型是什么，我们都是使用var来进行变量声明的。但是之前对于Java的使用，都会提到它是强类型语言，变量声明需要定义特定类型。但是在JDK11中对JDK8的类型推断思路又得以延伸，使用JS的方式，通过var定义局部变量，它会根据右边的表达式推断变量类型 </p>
<pre class="highlight"><span class="line"><span class="keyword">var</span> text = <span class="string">&quot;hello itheima&quot;</span>; </span><br><span class="line">sout(text);</span><br></pre>
<h2 id="2）新增字符串方法"><a href="#2）新增字符串方法" class="headerlink" title="2）新增字符串方法"></a>2）新增字符串方法</h2><p><img src="http://mele.cool/image-20201003191743832.png" alt="image-20201003191743832" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://mele.cool/image-20201003191743832.png" class="lozad post-image"></p>
<h2 id="3）新增创建集合的方式"><a href="#3）新增创建集合的方式" class="headerlink" title="3）新增创建集合的方式"></a>3）新增创建集合的方式</h2><p>JDK11提供了通过of()和copyOf()创建集合的方式，但是创建的集合长度不可变，不能进行任何修改操作，of()会直接创建，而copyOf()首先会判断传入的集合是否为不可变集合，是的话直接返回，不是的话，调用of()创建新集合并返回。 </p>
<pre class="highlight"><span class="line"><span class="keyword">var</span> list = List.of(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;itheima&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;(); </span><br><span class="line"><span class="keyword">var</span> list2 = List.copyOf(arrayList); </span><br></pre>
<h2 id="4）Files类增强"><a href="#4）Files类增强" class="headerlink" title="4）Files类增强"></a>4）Files类增强</h2><p>在Files类中新增两个方法：writeString和readString。可以把String内容写入文件或者把整个文件以String读出 </p>
<pre class="highlight"><span class="line">Files.writeString( Path.of(<span class="string">&quot;./&quot;</span>, <span class="string">&quot;demo.txt&quot;</span>), <span class="string">&quot;hello,itheima&quot;</span>, <span class="string">&quot;utf‐8&quot;</span>); </span><br><span class="line"></span><br><span class="line">String info = Files.readString(Paths.get(<span class="string">&quot;./demo.txt&quot;</span>), <span class="string">&quot;utf‐8&quot;</span>); </span><br></pre>


<h2 id="5）HTTP-Client-Api"><a href="#5）HTTP-Client-Api" class="headerlink" title="5）HTTP Client Api"></a>5）HTTP Client Api</h2><p>平时我们要去访问HTTP资源，大多数时间我们都是通过第三方完成的，虽然在JDK标准类库中有HttpURLConnection，但是也不太好用。 在JDK9就提出了HTTP Client Api，经过9，10两个版本的改进，在11中正式发布。其同时支持同步请求和异步请 求。</p>
<pre class="highlight"><span class="line"><span class="keyword">var</span> request = HttpRequest.newBuilder()</span><br><span class="line">.uri(URI.create(<span class="string">&quot;http://www.itcast.cn&quot;</span>)) </span><br><span class="line">.POST() </span><br><span class="line">.build(); </span><br><span class="line"><span class="keyword">var</span> client = HttpClient.newHttpClient(); </span><br><span class="line"><span class="comment">// 同步 </span></span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response.body()); </span><br><span class="line"><span class="comment">// 异步 </span></span><br><span class="line">client.sendAsync(request, HttpResponse.BodyHandlers.ofString()) </span><br><span class="line">.thenApply(HttpResponse::body) </span><br><span class="line">.thenAccept(System.out::println);</span><br></pre>
<h2 id="6）更方便的编译运行"><a href="#6）更方便的编译运行" class="headerlink" title="6）更方便的编译运行"></a>6）更方便的编译运行</h2><pre class="highlight"><span class="line"><span class="meta">#</span><span class="bash">之前</span> </span><br><span class="line">javac Demo.java </span><br><span class="line">java Demo </span><br><span class="line"><span class="meta">#</span><span class="bash">现在</span> </span><br><span class="line">java Demo.java </span><br></pre>
  </div>
  <div>
  
  <div class="post-note note-warning copyright" style="margin-top: 42px">
    <p><span style="font-weight: bold;">作者：</span><a target="_blank" rel="nofollow noopener noreferrer" href="https://www.mele.cool/about">blydd</a></p>
    <p><span style="font-weight: bold;">文章链接：</span><a target="_blank" rel="nofollow noopener noreferrer" href="https://www.mele.cool/2020/12/02/jdk8%E4%BB%A5%E4%B8%8A%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B/">https://www.mele.cool/2020/12/02/jdk8%E4%BB%A5%E4%B8%8A%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B/</a></p>
    <p><span style="font-weight: bold;">版权声明：</span>本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0 协议</a>。转载请注明出处！</p>
  </div>
  
  </div>
</article>
<div class="nav">
  
  <div class="nav-item-prev">
    <a href="/2020/12/02/springcloud入门/" class="nav-link">
      <i class="iconfont icon-left nav-prev-icon"></i>
      <div>
        <div class="nav-label">上一篇</div>
        
        <div class="nav-title">springcloud入门 </div>
        
      </div>
    </a>
  </div>
  
  
  <div class="nav-item-next">
    <a href="/2020/12/02/多线程及调优/" class="nav-link">
      <div>
        <div class="nav-label">下一篇</div>
        
        <div class="nav-title">多线程及调优 </div>
        
      </div>
      <i class="iconfont icon-right nav-next-icon"></i>
    </a>
  </div>
  
</div>

<div class="card card-content toc-card" id="mobiletoc">
  <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">1.接口的默认方法和静态方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">2.lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E5%9F%BA%E7%A1%80%E6%A0%BC%E5%BC%8F"><span class="toc-text">2.1基础格式:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-text">2.2 Lambda表达式底层原理解析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Predicate%E4%BD%BF%E7%94%A8"><span class="toc-text">3.1 Predicate使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Consumer%E4%BD%BF%E7%94%A8"><span class="toc-text">3.2 Consumer使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Function%E4%BD%BF%E7%94%A8"><span class="toc-text">3.3 Function使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Supplier%E4%BD%BF%E7%94%A8"><span class="toc-text">3.4 Supplier使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5-amp-%E6%8E%A8%E6%96%AD"><span class="toc-text">3.5 类型检查**&amp;**推断</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">4. 方法引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Stream%E6%B5%81%E4%BD%BF%E7%94%A8"><span class="toc-text">5. Stream流使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E6%B5%81%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3"><span class="toc-text">5.1流操作详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1%E7%AD%9B%E9%80%89"><span class="toc-text">5.1.1筛选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E5%88%87%E7%89%87"><span class="toc-text">5.1..2 切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3%E6%98%A0%E5%B0%84"><span class="toc-text">5.1.3映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4%E5%8C%B9%E9%85%8D"><span class="toc-text">5.1.4匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-5%E6%9F%A5%E6%89%BE"><span class="toc-text">5.1.5查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-6-%E5%BD%92%E7%BA%A6"><span class="toc-text">5.1.6 归约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-6-1%E5%9F%BA%E4%BA%8E-reduce-%E8%BF%9B%E8%A1%8C%E7%B4%AF%E7%A7%AF%E6%B1%82%E5%92%8C"><span class="toc-text">5.1.6.1基于**reduce()**进行累积求和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-6-2%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-text">5.1.6.2最大值最小值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E6%9E%84%E5%BB%BA%E6%B5%81"><span class="toc-text">5.2构建流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1%E5%9F%BA%E4%BA%8E%E5%80%BC%E5%88%9B%E5%BB%BA%E6%B5%81"><span class="toc-text">5.2.1基于值创建流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E6%B5%81"><span class="toc-text">5.2.2基于数组创建流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E6%B5%81"><span class="toc-text">5.2.3基于文件创建流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">5.3收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E9%80%9A%E8%BF%87-counting-%E7%BB%9F%E8%AE%A1%E9%9B%86%E5%90%88%E6%80%BB%E6%95%B0"><span class="toc-text">5.3.1 通过**counting()**统计集合总数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E9%80%9A%E8%BF%87maxBy-%E4%B8%8EminBy-%E8%8E%B7%E5%8F%96%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-text">5.3.2 通过maxBy()**与minBy()**获取最大值最小值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-%E9%80%9A%E8%BF%87-summingInt-%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%B1%87%E6%80%BB"><span class="toc-text">5.3.3 通过**summingInt()**进行数据汇总</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-4-%E9%80%9A%E8%BF%87-averagingInt-%E8%BF%9B%E8%A1%8C%E5%B9%B3%E5%9D%87%E5%80%BC%E8%8E%B7%E5%8F%96"><span class="toc-text">5.3.4 通过**averagingInt()**进行平均值获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-5%E5%A4%8D%E6%9D%82%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E"><span class="toc-text">5.3.5复杂结果返回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-6%E9%80%9A%E8%BF%87-joining-%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%8B%BC%E6%8E%A5"><span class="toc-text">5.3.6通过**joining()**进行数据拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-7-%E5%88%86%E7%BB%84"><span class="toc-text">5.3.7 分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-8-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">5.3.8 自定义收集器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C%E5%8C%96"><span class="toc-text">6.数据并行化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E5%B9%B6%E8%A1%8C%E6%B5%81%E5%8E%9F%E7%90%86"><span class="toc-text">6.1并行流原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E5%B9%B6%E8%A1%8C%E6%B5%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">6.2并行流注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E7%BB%93%E8%AE%BA"><span class="toc-text">6.3结论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8BCompletableFuture"><span class="toc-text">7.异步编程CompletableFuture</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1Future%E4%BB%8B%E7%BB%8D"><span class="toc-text">7.1Future介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2CompletableFuture"><span class="toc-text">7.2CompletableFuture</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA"><span class="toc-text">7.2.1 异步任务创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C%E8%A7%A6%E5%8F%91%E5%9B%9E%E8%B0%83"><span class="toc-text">7.2.2 异步计算结果触发回调</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-1whenComplete-%E4%B8%8EwhenCompleteAsync"><span class="toc-text">7.2.2.1whenComplete()**与whenCompleteAsync()**</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-2-exceptionally"><span class="toc-text">7.2.2.2 exceptionally()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%BE%9D%E8%B5%96%E6%89%A7%E8%A1%8C"><span class="toc-text">7.2.3 多任务依赖执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-1-thenApply"><span class="toc-text">7.2.3.1 thenApply()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-2-handle"><span class="toc-text">7.2.3.2 handle()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-3-thenAccept"><span class="toc-text">7.2.3.3 thenAccept()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-4-thenRun"><span class="toc-text">7.2.3.4  thenRun()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-4-%E4%B8%A4%E4%BB%BB%E5%8A%A1%E5%90%88%E5%B9%B6%E6%89%A7%E8%A1%8C"><span class="toc-text">7.2.4 两任务合并执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-4-1-%E4%B8%A4%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%85%A8%E9%83%A8%E5%AE%8C%E6%88%90%E8%A7%A6%E5%8F%91"><span class="toc-text">7.2.4.1 两个任务全部完成触发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-1-1-thenCombine"><span class="toc-text">7.2.4.1.1 thenCombine()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-1-2-thenAcceptBoth"><span class="toc-text">7.2.4.1.2 thenAcceptBoth()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-1-3-runAfterBoth"><span class="toc-text">7.2.4.1.3 runAfterBoth()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-4-2-%E4%B8%A4%E4%B8%AA%E4%BB%BB%E5%8A%A1%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%88%90%E8%A7%A6%E5%8F%91"><span class="toc-text">7.2.4.2 两个任务任意一个完成触发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-2-1-applyToEither"><span class="toc-text">7.2.4.2.1 applyToEither()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-2-2-acceptEither"><span class="toc-text">7.2.4.2.2 acceptEither()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-2-3-runAfterEither"><span class="toc-text">7.2.4.2.3 runAfterEither()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-5-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BB%84%E5%90%88%E6%89%A7%E8%A1%8C"><span class="toc-text">7.2.5 多任务组合执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-5-1-allOf"><span class="toc-text">7.2.5.1 allOf()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-5-2-%EF%BC%89anyOf"><span class="toc-text">7.2.5.2 ）anyOf()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Optional"><span class="toc-text">8.Optional</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%88%9B%E5%BB%BAoptional%E5%AF%B9%E8%B1%A1"><span class="toc-text">8.1 创建optional对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2%E5%9F%BA%E4%BA%8Eoptional%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E5%80%BC"><span class="toc-text">8.2基于optional对象获取值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E6%96%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">9.日期时间新方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-jdk11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">10.jdk11新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%89%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-text">1）变量类型推断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%89%E6%96%B0%E5%A2%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95"><span class="toc-text">2）新增字符串方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%89%E6%96%B0%E5%A2%9E%E5%88%9B%E5%BB%BA%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">3）新增创建集合的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%BC%89Files%E7%B1%BB%E5%A2%9E%E5%BC%BA"><span class="toc-text">4）Files类增强</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%BC%89HTTP-Client-Api"><span class="toc-text">5）HTTP Client Api</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%EF%BC%89%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C"><span class="toc-text">6）更方便的编译运行</span></a></li></ol></li></ol>
</div></main>
          <aside class="left-column">
            
            <div class="card card-author">
              
<img src="https://i.loli.net/2021/01/27/IrkEAwO1ujK6Z9y.png" class="author-img">

<p class="author-name">blydd</p>
<p class="author-description">积跬步行千里</p>
<div class="author-message">
  <a class="author-posts-count" href="/archives">
    <span>66</span>
    <span>文章</span>
  </a>
  <a class="author-categories-count" href="/categories">
    <span>15</span>
    <span>分类</span>
  </a>
  <a class="author-tags-count" href="/tags">
    <span>91</span>
    <span>标签</span>
  </a>
</div>

            </div>
            
            <div class="sticky-tablet">
  
  
  <article class="display-when-two-columns spacer">
    <div class="card card-content toc-card">
      <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">1.接口的默认方法和静态方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">2.lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E5%9F%BA%E7%A1%80%E6%A0%BC%E5%BC%8F"><span class="toc-text">2.1基础格式:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-text">2.2 Lambda表达式底层原理解析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Predicate%E4%BD%BF%E7%94%A8"><span class="toc-text">3.1 Predicate使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Consumer%E4%BD%BF%E7%94%A8"><span class="toc-text">3.2 Consumer使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Function%E4%BD%BF%E7%94%A8"><span class="toc-text">3.3 Function使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Supplier%E4%BD%BF%E7%94%A8"><span class="toc-text">3.4 Supplier使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5-amp-%E6%8E%A8%E6%96%AD"><span class="toc-text">3.5 类型检查**&amp;**推断</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">4. 方法引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Stream%E6%B5%81%E4%BD%BF%E7%94%A8"><span class="toc-text">5. Stream流使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E6%B5%81%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3"><span class="toc-text">5.1流操作详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1%E7%AD%9B%E9%80%89"><span class="toc-text">5.1.1筛选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E5%88%87%E7%89%87"><span class="toc-text">5.1..2 切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3%E6%98%A0%E5%B0%84"><span class="toc-text">5.1.3映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4%E5%8C%B9%E9%85%8D"><span class="toc-text">5.1.4匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-5%E6%9F%A5%E6%89%BE"><span class="toc-text">5.1.5查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-6-%E5%BD%92%E7%BA%A6"><span class="toc-text">5.1.6 归约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-6-1%E5%9F%BA%E4%BA%8E-reduce-%E8%BF%9B%E8%A1%8C%E7%B4%AF%E7%A7%AF%E6%B1%82%E5%92%8C"><span class="toc-text">5.1.6.1基于**reduce()**进行累积求和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-6-2%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-text">5.1.6.2最大值最小值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E6%9E%84%E5%BB%BA%E6%B5%81"><span class="toc-text">5.2构建流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1%E5%9F%BA%E4%BA%8E%E5%80%BC%E5%88%9B%E5%BB%BA%E6%B5%81"><span class="toc-text">5.2.1基于值创建流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E6%B5%81"><span class="toc-text">5.2.2基于数组创建流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E6%B5%81"><span class="toc-text">5.2.3基于文件创建流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">5.3收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E9%80%9A%E8%BF%87-counting-%E7%BB%9F%E8%AE%A1%E9%9B%86%E5%90%88%E6%80%BB%E6%95%B0"><span class="toc-text">5.3.1 通过**counting()**统计集合总数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E9%80%9A%E8%BF%87maxBy-%E4%B8%8EminBy-%E8%8E%B7%E5%8F%96%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-text">5.3.2 通过maxBy()**与minBy()**获取最大值最小值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-%E9%80%9A%E8%BF%87-summingInt-%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%B1%87%E6%80%BB"><span class="toc-text">5.3.3 通过**summingInt()**进行数据汇总</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-4-%E9%80%9A%E8%BF%87-averagingInt-%E8%BF%9B%E8%A1%8C%E5%B9%B3%E5%9D%87%E5%80%BC%E8%8E%B7%E5%8F%96"><span class="toc-text">5.3.4 通过**averagingInt()**进行平均值获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-5%E5%A4%8D%E6%9D%82%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E"><span class="toc-text">5.3.5复杂结果返回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-6%E9%80%9A%E8%BF%87-joining-%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%8B%BC%E6%8E%A5"><span class="toc-text">5.3.6通过**joining()**进行数据拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-7-%E5%88%86%E7%BB%84"><span class="toc-text">5.3.7 分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-8-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">5.3.8 自定义收集器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C%E5%8C%96"><span class="toc-text">6.数据并行化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E5%B9%B6%E8%A1%8C%E6%B5%81%E5%8E%9F%E7%90%86"><span class="toc-text">6.1并行流原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E5%B9%B6%E8%A1%8C%E6%B5%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">6.2并行流注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E7%BB%93%E8%AE%BA"><span class="toc-text">6.3结论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8BCompletableFuture"><span class="toc-text">7.异步编程CompletableFuture</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1Future%E4%BB%8B%E7%BB%8D"><span class="toc-text">7.1Future介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2CompletableFuture"><span class="toc-text">7.2CompletableFuture</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA"><span class="toc-text">7.2.1 异步任务创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C%E8%A7%A6%E5%8F%91%E5%9B%9E%E8%B0%83"><span class="toc-text">7.2.2 异步计算结果触发回调</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-1whenComplete-%E4%B8%8EwhenCompleteAsync"><span class="toc-text">7.2.2.1whenComplete()**与whenCompleteAsync()**</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-2-exceptionally"><span class="toc-text">7.2.2.2 exceptionally()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%BE%9D%E8%B5%96%E6%89%A7%E8%A1%8C"><span class="toc-text">7.2.3 多任务依赖执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-1-thenApply"><span class="toc-text">7.2.3.1 thenApply()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-2-handle"><span class="toc-text">7.2.3.2 handle()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-3-thenAccept"><span class="toc-text">7.2.3.3 thenAccept()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-4-thenRun"><span class="toc-text">7.2.3.4  thenRun()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-4-%E4%B8%A4%E4%BB%BB%E5%8A%A1%E5%90%88%E5%B9%B6%E6%89%A7%E8%A1%8C"><span class="toc-text">7.2.4 两任务合并执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-4-1-%E4%B8%A4%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%85%A8%E9%83%A8%E5%AE%8C%E6%88%90%E8%A7%A6%E5%8F%91"><span class="toc-text">7.2.4.1 两个任务全部完成触发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-1-1-thenCombine"><span class="toc-text">7.2.4.1.1 thenCombine()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-1-2-thenAcceptBoth"><span class="toc-text">7.2.4.1.2 thenAcceptBoth()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-1-3-runAfterBoth"><span class="toc-text">7.2.4.1.3 runAfterBoth()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-4-2-%E4%B8%A4%E4%B8%AA%E4%BB%BB%E5%8A%A1%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%88%90%E8%A7%A6%E5%8F%91"><span class="toc-text">7.2.4.2 两个任务任意一个完成触发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-2-1-applyToEither"><span class="toc-text">7.2.4.2.1 applyToEither()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-2-2-acceptEither"><span class="toc-text">7.2.4.2.2 acceptEither()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-2-3-runAfterEither"><span class="toc-text">7.2.4.2.3 runAfterEither()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-5-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BB%84%E5%90%88%E6%89%A7%E8%A1%8C"><span class="toc-text">7.2.5 多任务组合执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-5-1-allOf"><span class="toc-text">7.2.5.1 allOf()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-5-2-%EF%BC%89anyOf"><span class="toc-text">7.2.5.2 ）anyOf()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Optional"><span class="toc-text">8.Optional</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%88%9B%E5%BB%BAoptional%E5%AF%B9%E8%B1%A1"><span class="toc-text">8.1 创建optional对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2%E5%9F%BA%E4%BA%8Eoptional%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E5%80%BC"><span class="toc-text">8.2基于optional对象获取值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E6%96%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">9.日期时间新方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-jdk11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">10.jdk11新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%89%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-text">1）变量类型推断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%89%E6%96%B0%E5%A2%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95"><span class="toc-text">2）新增字符串方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%89%E6%96%B0%E5%A2%9E%E5%88%9B%E5%BB%BA%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">3）新增创建集合的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%BC%89Files%E7%B1%BB%E5%A2%9E%E5%BC%BA"><span class="toc-text">4）Files类增强</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%BC%89HTTP-Client-Api"><span class="toc-text">5）HTTP Client Api</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%EF%BC%89%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C"><span class="toc-text">6）更方便的编译运行</span></a></li></ol></li></ol>
    </div>
  </article>
  
  
  <article class="card card-content categories-widget">
    <div class="categories-card">
  <div class="categories-header"><i class="iconfont icon-fenlei" style="padding-right: 2px;"></i>分类</div>
  <div class="categories-list">
    
      <a href="/categories/工具类">
        <div class="categories-list-item">
          工具类
          <span class="categories-list-item-badge">8</span>
        </div>
      </a>
    
      <a href="/categories/linux">
        <div class="categories-list-item">
          linux
          <span class="categories-list-item-badge">3</span>
        </div>
      </a>
    
      <a href="/categories/mac">
        <div class="categories-list-item">
          mac
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/java">
        <div class="categories-list-item">
          java
          <span class="categories-list-item-badge">19</span>
        </div>
      </a>
    
      <a href="/categories/springboot">
        <div class="categories-list-item">
          springboot
          <span class="categories-list-item-badge">13</span>
        </div>
      </a>
    
      <a href="/categories/docker">
        <div class="categories-list-item">
          docker
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/版本控制">
        <div class="categories-list-item">
          版本控制
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/hello world">
        <div class="categories-list-item">
          hello world
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/mele">
        <div class="categories-list-item">
          mele
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/db">
        <div class="categories-list-item">
          db
          <span class="categories-list-item-badge">7</span>
        </div>
      </a>
    
      <a href="/categories/其他">
        <div class="categories-list-item">
          其他
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/bug">
        <div class="categories-list-item">
          bug
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/js">
        <div class="categories-list-item">
          js
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/mq">
        <div class="categories-list-item">
          mq
          <span class="categories-list-item-badge">3</span>
        </div>
      </a>
    
      <a href="/categories/springCloud">
        <div class="categories-list-item">
          springCloud
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content tags-widget">
    <div class="tags-card">
  <div class="tags-header"><i class="iconfont icon-biaoqian" style="padding-right: 2px;"></i>热门标签</div>
  <div class="tags-list">
    
    <a href="\tags\springboot" title="springboot"><div class="tags-list-item">springboot</div></a>
    
    <a href="\tags\java" title="java"><div class="tags-list-item">java</div></a>
    
    <a href="\tags\工具类" title="工具类"><div class="tags-list-item">工具类</div></a>
    
    <a href="\tags\mybatis" title="mybatis"><div class="tags-list-item">mybatis</div></a>
    
    <a href="\tags\tool" title="tool"><div class="tags-list-item">tool</div></a>
    
    <a href="\tags\git" title="git"><div class="tags-list-item">git</div></a>
    
    <a href="\tags\linux" title="linux"><div class="tags-list-item">linux</div></a>
    
    <a href="\tags\springCloud" title="springCloud"><div class="tags-list-item">springCloud</div></a>
    
    <a href="\tags\线程池" title="线程池"><div class="tags-list-item">线程池</div></a>
    
    <a href="\tags\ms" title="ms"><div class="tags-list-item">ms</div></a>
    
    <a href="\tags\mq" title="mq"><div class="tags-list-item">mq</div></a>
    
    <a href="\tags\常用" title="常用"><div class="tags-list-item">常用</div></a>
    
    <a href="\tags\bug" title="bug"><div class="tags-list-item">bug</div></a>
    
    <a href="\tags\分布式" title="分布式"><div class="tags-list-item">分布式</div></a>
    
    <a href="\tags\acid" title="acid"><div class="tags-list-item">acid</div></a>
    
    <a href="\tags\事务" title="事务"><div class="tags-list-item">事务</div></a>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
          <aside class="right-column">
            <div class="sticky-widescreen">
  
  
  <article class="card card-content toc-card">
    <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">1.接口的默认方法和静态方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">2.lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E5%9F%BA%E7%A1%80%E6%A0%BC%E5%BC%8F"><span class="toc-text">2.1基础格式:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-text">2.2 Lambda表达式底层原理解析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Predicate%E4%BD%BF%E7%94%A8"><span class="toc-text">3.1 Predicate使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Consumer%E4%BD%BF%E7%94%A8"><span class="toc-text">3.2 Consumer使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Function%E4%BD%BF%E7%94%A8"><span class="toc-text">3.3 Function使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Supplier%E4%BD%BF%E7%94%A8"><span class="toc-text">3.4 Supplier使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5-amp-%E6%8E%A8%E6%96%AD"><span class="toc-text">3.5 类型检查**&amp;**推断</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">4. 方法引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Stream%E6%B5%81%E4%BD%BF%E7%94%A8"><span class="toc-text">5. Stream流使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E6%B5%81%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3"><span class="toc-text">5.1流操作详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1%E7%AD%9B%E9%80%89"><span class="toc-text">5.1.1筛选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E5%88%87%E7%89%87"><span class="toc-text">5.1..2 切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3%E6%98%A0%E5%B0%84"><span class="toc-text">5.1.3映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4%E5%8C%B9%E9%85%8D"><span class="toc-text">5.1.4匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-5%E6%9F%A5%E6%89%BE"><span class="toc-text">5.1.5查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-6-%E5%BD%92%E7%BA%A6"><span class="toc-text">5.1.6 归约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-6-1%E5%9F%BA%E4%BA%8E-reduce-%E8%BF%9B%E8%A1%8C%E7%B4%AF%E7%A7%AF%E6%B1%82%E5%92%8C"><span class="toc-text">5.1.6.1基于**reduce()**进行累积求和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-6-2%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-text">5.1.6.2最大值最小值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E6%9E%84%E5%BB%BA%E6%B5%81"><span class="toc-text">5.2构建流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1%E5%9F%BA%E4%BA%8E%E5%80%BC%E5%88%9B%E5%BB%BA%E6%B5%81"><span class="toc-text">5.2.1基于值创建流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E6%B5%81"><span class="toc-text">5.2.2基于数组创建流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E6%B5%81"><span class="toc-text">5.2.3基于文件创建流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">5.3收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E9%80%9A%E8%BF%87-counting-%E7%BB%9F%E8%AE%A1%E9%9B%86%E5%90%88%E6%80%BB%E6%95%B0"><span class="toc-text">5.3.1 通过**counting()**统计集合总数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E9%80%9A%E8%BF%87maxBy-%E4%B8%8EminBy-%E8%8E%B7%E5%8F%96%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-text">5.3.2 通过maxBy()**与minBy()**获取最大值最小值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-%E9%80%9A%E8%BF%87-summingInt-%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%B1%87%E6%80%BB"><span class="toc-text">5.3.3 通过**summingInt()**进行数据汇总</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-4-%E9%80%9A%E8%BF%87-averagingInt-%E8%BF%9B%E8%A1%8C%E5%B9%B3%E5%9D%87%E5%80%BC%E8%8E%B7%E5%8F%96"><span class="toc-text">5.3.4 通过**averagingInt()**进行平均值获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-5%E5%A4%8D%E6%9D%82%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E"><span class="toc-text">5.3.5复杂结果返回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-6%E9%80%9A%E8%BF%87-joining-%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%8B%BC%E6%8E%A5"><span class="toc-text">5.3.6通过**joining()**进行数据拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-7-%E5%88%86%E7%BB%84"><span class="toc-text">5.3.7 分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-8-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">5.3.8 自定义收集器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C%E5%8C%96"><span class="toc-text">6.数据并行化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E5%B9%B6%E8%A1%8C%E6%B5%81%E5%8E%9F%E7%90%86"><span class="toc-text">6.1并行流原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E5%B9%B6%E8%A1%8C%E6%B5%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">6.2并行流注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E7%BB%93%E8%AE%BA"><span class="toc-text">6.3结论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8BCompletableFuture"><span class="toc-text">7.异步编程CompletableFuture</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1Future%E4%BB%8B%E7%BB%8D"><span class="toc-text">7.1Future介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2CompletableFuture"><span class="toc-text">7.2CompletableFuture</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA"><span class="toc-text">7.2.1 异步任务创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C%E8%A7%A6%E5%8F%91%E5%9B%9E%E8%B0%83"><span class="toc-text">7.2.2 异步计算结果触发回调</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-1whenComplete-%E4%B8%8EwhenCompleteAsync"><span class="toc-text">7.2.2.1whenComplete()**与whenCompleteAsync()**</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-2-exceptionally"><span class="toc-text">7.2.2.2 exceptionally()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%BE%9D%E8%B5%96%E6%89%A7%E8%A1%8C"><span class="toc-text">7.2.3 多任务依赖执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-1-thenApply"><span class="toc-text">7.2.3.1 thenApply()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-2-handle"><span class="toc-text">7.2.3.2 handle()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-3-thenAccept"><span class="toc-text">7.2.3.3 thenAccept()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-4-thenRun"><span class="toc-text">7.2.3.4  thenRun()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-4-%E4%B8%A4%E4%BB%BB%E5%8A%A1%E5%90%88%E5%B9%B6%E6%89%A7%E8%A1%8C"><span class="toc-text">7.2.4 两任务合并执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-4-1-%E4%B8%A4%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%85%A8%E9%83%A8%E5%AE%8C%E6%88%90%E8%A7%A6%E5%8F%91"><span class="toc-text">7.2.4.1 两个任务全部完成触发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-1-1-thenCombine"><span class="toc-text">7.2.4.1.1 thenCombine()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-1-2-thenAcceptBoth"><span class="toc-text">7.2.4.1.2 thenAcceptBoth()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-1-3-runAfterBoth"><span class="toc-text">7.2.4.1.3 runAfterBoth()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-4-2-%E4%B8%A4%E4%B8%AA%E4%BB%BB%E5%8A%A1%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%88%90%E8%A7%A6%E5%8F%91"><span class="toc-text">7.2.4.2 两个任务任意一个完成触发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-2-1-applyToEither"><span class="toc-text">7.2.4.2.1 applyToEither()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-2-2-acceptEither"><span class="toc-text">7.2.4.2.2 acceptEither()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-2-3-runAfterEither"><span class="toc-text">7.2.4.2.3 runAfterEither()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-5-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BB%84%E5%90%88%E6%89%A7%E8%A1%8C"><span class="toc-text">7.2.5 多任务组合执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-5-1-allOf"><span class="toc-text">7.2.5.1 allOf()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-5-2-%EF%BC%89anyOf"><span class="toc-text">7.2.5.2 ）anyOf()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Optional"><span class="toc-text">8.Optional</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%88%9B%E5%BB%BAoptional%E5%AF%B9%E8%B1%A1"><span class="toc-text">8.1 创建optional对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2%E5%9F%BA%E4%BA%8Eoptional%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E5%80%BC"><span class="toc-text">8.2基于optional对象获取值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E6%96%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">9.日期时间新方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-jdk11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">10.jdk11新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%89%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-text">1）变量类型推断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%89%E6%96%B0%E5%A2%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95"><span class="toc-text">2）新增字符串方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%89%E6%96%B0%E5%A2%9E%E5%88%9B%E5%BB%BA%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">3）新增创建集合的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%BC%89Files%E7%B1%BB%E5%A2%9E%E5%BC%BA"><span class="toc-text">4）Files类增强</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%BC%89HTTP-Client-Api"><span class="toc-text">5）HTTP Client Api</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%EF%BC%89%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C"><span class="toc-text">6）更方便的编译运行</span></a></li></ol></li></ol>
  </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header"><i class="iconfont icon-wenzhang_huaban" style="padding-right: 2px;"></i>最近文章</div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-01-26</div>
        <a href="/2021/01/26/编写优雅高效的java代码/"><div class="recent-posts-item-content">编写高效优雅java代码</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-01-23</div>
        <a href="/2021/01/23/redis教程效率版/"><div class="recent-posts-item-content">redis入门效率版</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-01-22</div>
        <a href="/2021/01/22/开发注意代码整理/"><div class="recent-posts-item-content">开发中注意的小问题</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-01-02</div>
        <a href="/2021/01/02/SQL语句性能提升/"><div class="recent-posts-item-content">SQL语句性能提升</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
        </div>
      </div>
    </div>
  </div>
  
  <footer class="footer">
  <div class="footer-container">
    <div>
      <div class="footer-dsc">
        <span>Copyright ©
          
          2020 -
          
          2021
        </span>
        &nbsp;
        <a href="/" class="footer-link">mele blog </a>
      </div>
    </div>

    
    <div class="footer-dsc">
      
      Powered by
      <a href="https://hexo.io/" class="footer-link" target="_blank" rel="nofollow noopener noreferrer">&nbsp;Hexo </a>
      
      
      <span>&nbsp;|&nbsp;</span>
      
      
      Theme -
      <a href="https://github.com/theme-kaze" class="footer-link" target="_blank"
        rel="nofollow noopener noreferrer">&nbsp;Kaze</a>
      
    </div>
    
    
    
    
</footer>
  <a role="button" id="scrollbutton" class="basebutton"  aria-label="回到顶部">
  <i class="iconfont icon-arrowleft button-icon"></i>
</a>
<a role="button" id="menubutton" class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a role="button" id="popbutton" class="basebutton" aria-label="控制中心">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a role="button" id="darkbutton" class="basebutton darkwidget" aria-label="夜色模式">
  <i class="iconfont icon-weather button-icon"></i>
</a>
<a role="button" id="searchbutton" class="basebutton searchwidget" aria-label="搜索">
  <i class="iconfont icon-search button-icon"></i>
</a>

  
  
  
  <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img');
    var i;
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a');
      wrapper.setAttribute('href', img[i].getAttribute('data-src'));
      wrapper.setAttribute('aria-label', 'illustration');
      wrapper.style.cssText = 'width: 100%; display: flex; justify-content: center;';
      if (img[i].alt) wrapper.dataset.caption = img[i].alt;
      wrapper.dataset.nolink = true;
      img[i].before(wrapper);
      wrapper.append(img[i]);
      var divWrap = document.createElement('div');
      divWrap.classList.add('gallery');
      wrapper.before(divWrap);
      divWrap.append(wrapper);
    }
    baguetteBox.run('.gallery');
  }
</script>
<script>loadScript("/js/lib/lightbox/baguetteBox.min.js", addImgLayout)</script>
  
  
  
<script src="/js/main.js"></script>

  
  
  <script>
    var addLazyload = function () {
      var observer = lozad('.lozad', {
        load: function (el) {
          el.srcset = el.getAttribute('data-src');
        },
        loaded: function (el) {
          el.classList.add('loaded');
        }
      });
      observer.observe();
    }
  </script>
  <script>loadScript("/js/lib/lozad.min.js", addLazyload)</script>
  
  
</body>

</html>