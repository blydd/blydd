<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-springboot单元测试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/02/springboot%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2020-12-02T14:56:17.000Z" itemprop="datePublished">2020-12-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/springboot/">springboot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/02/springboot%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">springboot单元测试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>编写单元测试可以帮助开发人员编写高质量的代码，提升代码质量，减少Bug，便于重构。Spring<br>Boot提供了一些实用程序和注解，用来帮助我们测试应用程序，在Spring<br>Boot中开启单元测试只需引入<code>spring-boot-starter-test</code>即可，其包含了一些主流的测试库。本文主要介绍基于Service和Controller的单元测试。</p>
</blockquote>
<h3 id="一、引入依赖spring-boot-starter-test："><a href="#一、引入依赖spring-boot-starter-test：" class="headerlink" title="一、引入依赖spring-boot-starter-test："></a>一、引入依赖<code>spring-boot-starter-test</code>：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行Maven命令<code>dependency:tree</code>可看到其包含了以下依赖：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[INFO] +- org.springframework.boot:spring-boot-starter-test:jar:1.5.9.RELEASE:test</span><br><span class="line">[INFO] |  +- org.springframework.boot:spring-boot-test:jar:1.5.9.RELEASE:test</span><br><span class="line">[INFO] |  +- org.springframework.boot:spring-boot-test-autoconfigure:jar:1.5.9.RELEASE:test</span><br><span class="line">[INFO] |  +- com.jayway.jsonpath:json-path:jar:2.2.0:test</span><br><span class="line">[INFO] |  |  +- net.minidev:json-smart:jar:2.2.1:test</span><br><span class="line">[INFO] |  |  |  \- net.minidev:accessors-smart:jar:1.1:test</span><br><span class="line">[INFO] |  |  |     \- org.ow2.asm:asm:jar:5.0.3:test</span><br><span class="line">[INFO] |  |  \- org.slf4j:slf4j-api:jar:1.7.25:compile</span><br><span class="line">[INFO] |  +- junit:junit:jar:4.12:test</span><br><span class="line">[INFO] |  +- org.assertj:assertj-core:jar:2.6.0:test</span><br><span class="line">[INFO] |  +- org.mockito:mockito-core:jar:1.10.19:test</span><br><span class="line">[INFO] |  |  \- org.objenesis:objenesis:jar:2.1:test</span><br><span class="line">[INFO] |  +- org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO] |  +- org.hamcrest:hamcrest-library:jar:1.3:test</span><br><span class="line">[INFO] |  +- org.skyscreamer:jsonassert:jar:1.4.0:test</span><br><span class="line">[INFO] |  |  \- com.vaadin.external.google:android-json:jar:0.0.20131108.vaadin1:test</span><br><span class="line">[INFO] |  +- org.springframework:spring-core:jar:4.3.13.RELEASE:compile</span><br><span class="line">[INFO] |  \- org.springframework:spring-test:jar:4.3.13.RELEASE:test</span><br></pre></td></tr></table></figure>


<ul>
<li>JUnit，标准的单元测试Java应用程序；</li>
<li>Spring Test &amp; Spring Boot Test，对Spring Boot应用程序的单元测试提供支持；</li>
<li>Mockito, Java mocking框架，用于模拟任何Spring管理的Bean，比如在单元测试中模拟一个第三方系统Service接口返回的数据，而不会去真正调用第三方系统；</li>
<li>AssertJ，一个流畅的assertion库，同时也提供了更多的期望值与测试返回值的比较方式；</li>
<li>Hamcrest，库的匹配对象（也称为约束或谓词）；</li>
<li>JsonPath，提供类似XPath那样的符号来获取JSON数据片段；</li>
<li>JSONassert，对JSON对象或者JSON字符串断言的库。</li>
</ul>
<p>一个标准的Spring Boot测试单元应有如下的代码结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="二、知识准备"><a href="#二、知识准备" class="headerlink" title="二、知识准备"></a>二、知识准备</h3><h4 id="1-JUnit4注解"><a href="#1-JUnit4注解" class="headerlink" title="1.JUnit4注解"></a>1.JUnit4注解</h4><p>JUnit4中包含了几个比较重要的注解：<code>@BeforeClass</code>、<code>@AfterClass</code>、<code>@Before</code>、<code>@After</code>和<code>@Test</code>。其中， <code>@BeforeClass</code>和<code>@AfterClass</code>在每个类加载的开始和结束时运行，必须为静态方法；而<code>@Before</code>和<code>@After</code>则在每个测试方法开始之前和结束之后运行。见如下例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beforeClassTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before class test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test 1+1=2&quot;</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">2</span>, <span class="number">1</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test 2+2=4&quot;</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">4</span>, <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterClassTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after class test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">before class test</span><br><span class="line">before test</span><br><span class="line">test 1+1=2</span><br><span class="line">after test</span><br><span class="line">before test</span><br><span class="line">test 2+2=4</span><br><span class="line">after test</span><br><span class="line">after class test</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<p>从上面的输出可以看出各个注解的运行时机。</p>
<h4 id="2-Assert"><a href="#2-Assert" class="headerlink" title="2.Assert"></a>2.Assert</h4><p>上面代码中，我们使用了Assert类提供的assert口方法，下面列出了一些常用的assert方法：</p>
<ul>
<li><code>assertEquals(&quot;message&quot;,A,B)</code>，判断A对象和B对象是否相等，这个判断在比较两个对象时调用了<code>equals()</code>方法。</li>
<li><code>assertSame(&quot;message&quot;,A,B)</code>，判断A对象与B对象是否相同，使用的是<code>==</code>操作符。</li>
<li><code>assertTrue(&quot;message&quot;,A)</code>，判断A条件是否为真。</li>
<li><code>assertFalse(&quot;message&quot;,A)</code>，判断A条件是否不为真。</li>
<li><code>assertNotNull(&quot;message&quot;,A)</code>，判断A对象是否不为<code>null</code>。</li>
<li><code>assertArrayEquals(&quot;message&quot;,A,B)</code>，判断A数组与B数组是否相等。</li>
</ul>
<h4 id="3-MockMvc"><a href="#3-MockMvc" class="headerlink" title="3.MockMvc"></a>3.MockMvc</h4><p>下文中，对Controller的测试需要用到MockMvc技术。MockMvc，从字面上来看指的是模拟的MVC，即其可以模拟一个MVC环境，向Controller发送请求然后得到响应。</p>
<p>在单元测试中，使用MockMvc前需要进行初始化，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> WebApplicationContext wac;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setupMockMvc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-1-MockMvc模拟MVC请求"><a href="#3-1-MockMvc模拟MVC请求" class="headerlink" title="3.1 MockMvc模拟MVC请求"></a><strong>3.1 MockMvc模拟MVC请求</strong></h5><p>模拟一个get请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/hello?name=&#123;name&#125;&quot;</span>,<span class="string">&quot;mrbird&quot;</span>));</span><br></pre></td></tr></table></figure>


<p>模拟一个post请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">&quot;/user/&#123;id&#125;&quot;</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>


<p>模拟文件上传：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.fileUpload(<span class="string">&quot;/fileupload&quot;</span>).file(<span class="string">&quot;file&quot;</span>, <span class="string">&quot;文件内容&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>)));</span><br></pre></td></tr></table></figure>


<p>模拟请求参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟发送一个message参数，值为hello</span></span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/hello&quot;</span>).param(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;hello&quot;</span>));</span><br><span class="line"><span class="comment">// 模拟提交一个checkbox值，name为hobby，值为sleep和eat</span></span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/saveHobby&quot;</span>).param(<span class="string">&quot;hobby&quot;</span>, <span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;eat&quot;</span>));</span><br></pre></td></tr></table></figure>


<p>也可以直接使用<code>MultiValueMap</code>构建参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MultiValueMap&lt;String, String&gt; params = <span class="keyword">new</span> LinkedMultiValueMap&lt;String, String&gt;();</span><br><span class="line">params.add(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;mrbird&quot;</span>);</span><br><span class="line">params.add(<span class="string">&quot;hobby&quot;</span>, <span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">params.add(<span class="string">&quot;hobby&quot;</span>, <span class="string">&quot;eat&quot;</span>);</span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/hobby/save&quot;</span>).params(params));</span><br></pre></td></tr></table></figure>


<p>模拟发送JSON参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String jsonStr = <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;Dopa\&quot;,\&quot;passwd\&quot;:\&quot;ac3af72d9f95161a502fd326865c2f15\&quot;,\&quot;status\&quot;:\&quot;1\&quot;&#125;&quot;</span>;</span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">&quot;/user/save&quot;</span>).content(jsonStr.getBytes()));</span><br></pre></td></tr></table></figure>


<p>实际测试中，要手动编写这么长的JSON格式字符串很繁琐也很容易出错，可以借助Spring Boot自带的Jackson技术来序列化一个Java对象（可参考<a target="_blank" rel="noopener" href="https://mrbird.cc/Spring-Boot%E4%B8%AD%E7%9A%84JSON%E6%8A%80%E6%9C%AF.html">Spring Boot中的JSON技术</a>），如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUsername(<span class="string">&quot;Dopa&quot;</span>);</span><br><span class="line">user.setPasswd(<span class="string">&quot;ac3af72d9f95161a502fd326865c2f15&quot;</span>);</span><br><span class="line">user.setStatus(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">String userJson = mapper.writeValueAsString(user);</span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">&quot;/user/save&quot;</span>).content(userJson.getBytes()));</span><br></pre></td></tr></table></figure>


<p>其中，mapper为<code>com.fasterxml.jackson.databind.ObjectMapper</code>对象。</p>
<p>模拟Session和Cookie：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/index&quot;</span>).sessionAttr(name, value));</span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/index&quot;</span>).cookie(<span class="keyword">new</span> Cookie(name, value)));</span><br></pre></td></tr></table></figure>


<p>设置请求的Content-Type：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/index&quot;</span>).contentType(MediaType.APPLICATION_JSON_UTF8));</span><br></pre></td></tr></table></figure>


<p>设置返回格式为JSON：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/user/&#123;id&#125;&quot;</span>, <span class="number">1</span>).accept(MediaType.APPLICATION_JSON));</span><br></pre></td></tr></table></figure>


<p>模拟HTTP请求头：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/user/&#123;id&#125;&quot;</span>, <span class="number">1</span>).header(name, values));</span><br></pre></td></tr></table></figure>


<h5 id="3-2MockMvc处理返回结果"><a href="#3-2MockMvc处理返回结果" class="headerlink" title="3.2MockMvc处理返回结果"></a><strong>3.2MockMvc处理返回结果</strong></h5><p>期望成功调用，即HTTP Status为200：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/user/&#123;id&#125;&quot;</span>, <span class="number">1</span>))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.status().isOk());</span><br></pre></td></tr></table></figure>


<p>期望返回内容是<code>application/json</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/user/&#123;id&#125;&quot;</span>, <span class="number">1</span>))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.content().contentType(MediaType.APPLICATION_JSON));</span><br></pre></td></tr></table></figure>


<p>检查返回JSON数据中某个值的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/user/&#123;id&#125;&quot;</span>, <span class="number">1</span>))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">&quot;$.username&quot;</span>).value(<span class="string">&quot;mrbird&quot;</span>));</span><br></pre></td></tr></table></figure>


<p>这里使用到了<code>jsonPath</code>，<code>$</code>代表了JSON的根节点。更多关于<code>jsonPath</code>的介绍可参考 <a target="_blank" rel="noopener" href="https://github.com/json-path/JsonPath%E3%80%82">https://github.com/json-path/JsonPath。</a></p>
<p>判断Controller方法是否返回某视图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">&quot;/index&quot;</span>))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.view().name(<span class="string">&quot;index.html&quot;</span>));</span><br></pre></td></tr></table></figure>


<p>比较Model：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/user/&#123;id&#125;&quot;</span>, <span class="number">1</span>))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.model().size(<span class="number">1</span>))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.model().attributeExists(<span class="string">&quot;password&quot;</span>))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.model().attribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;mrbird&quot;</span>));</span><br></pre></td></tr></table></figure>


<p>比较forward或者redirect：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/index&quot;</span>))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.forwardedUrl(<span class="string">&quot;index.html&quot;</span>));</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/index&quot;</span>))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.redirectedUrl(<span class="string">&quot;index.html&quot;</span>));</span><br></pre></td></tr></table></figure>


<p>比较返回内容，使用<code>content()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回内容为hello</span></span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/index&quot;</span>))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.content().string(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回内容是XML，并且与xmlCotent一样</span></span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/index&quot;</span>))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.content().xml(xmlContent));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回内容是JSON ，并且与jsonContent一样</span></span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/index&quot;</span>))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.content().json(jsonContent));</span><br></pre></td></tr></table></figure>


<p>输出响应结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/index&quot;</span>))</span><br><span class="line">    .andDo(MockMvcResultHandlers.print());</span><br></pre></td></tr></table></figure>


<h3 id="三、-测试Service"><a href="#三、-测试Service" class="headerlink" title="三、 测试Service"></a>三、 测试Service</h3><p>现有如下Service：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findByName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        Example example = <span class="keyword">new</span> Example(User.class);</span><br><span class="line">        example.createCriteria().andCondition(<span class="string">&quot;username=&quot;</span>, userName);</span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">this</span>.selectByExample(example);</span><br><span class="line">        <span class="keyword">if</span> (userList.size() != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> userList.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>编写一个该Service的单元测试，测试<code>findByName</code>方法是否有效：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">this</span>.userService.findByName(<span class="string">&quot;scott&quot;</span>);</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;用户名为scott&quot;</span>, <span class="string">&quot;scott&quot;</span>, user.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行后，JUnit没有报错说明测试通过，即<code>UserService</code>的<code>findByName</code>方法可行。<br><img src="http://59.110.212.214/upload/20200716_11293669.png"></p>
<p>此外，和在Controller中引用Service相比，在测试单元中对Service测试完毕后，数据能自动回滚，只需要在测试方法上加上<code>@Transactional</code>注解，比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="keyword">this</span>.userService.getSequence(<span class="string">&quot;seq_user&quot;</span>));</span><br><span class="line">    user.setUsername(<span class="string">&quot;JUnit&quot;</span>);</span><br><span class="line">    user.setPasswd(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    user.setStatus(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    user.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">    <span class="keyword">this</span>.userService.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行，测试通过，查看数据库发现数据并没有被插入，这样很好的避免了不必要的数据污染。</p>
<h3 id="四、-测试Controller"><a href="#四、-测试Controller" class="headerlink" title="四、 测试Controller"></a>四、 测试Controller</h3><p>现有如下Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;user/&#123;userName&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserByName</span><span class="params">(<span class="meta">@PathVariable(value = &quot;userName&quot;)</span> String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userService.findByName(userName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;user/save&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService.saveUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>现在编写一个针对于该Controller<code>getUserByName(@PathVariable(value = &quot;userName&quot;) String userName)</code>方法的测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext wac;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setupMockMvc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(</span><br><span class="line">            MockMvcRequestBuilders.get(<span class="string">&quot;/user/&#123;userName&#125;&quot;</span>, <span class="string">&quot;scott&quot;</span>)</span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON_UTF8))</span><br><span class="line">        .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">        .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">&quot;$.username&quot;</span>).value(<span class="string">&quot;scott&quot;</span>))</span><br><span class="line">        .andDo(MockMvcResultHandlers.print());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行后，JUnit通过，控制台输出过程如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">MockHttpServletRequest:</span><br><span class="line">      HTTP Method = GET</span><br><span class="line">      Request URI = /user/scott</span><br><span class="line">       Parameters = &#123;&#125;</span><br><span class="line">          Headers = &#123;Content-Type=[application/json;charset=UTF-8]&#125;</span><br><span class="line"></span><br><span class="line">Handler:</span><br><span class="line">             Type = demo.springboot.test.controller.UserController</span><br><span class="line">           Method = public demo.springboot.test.domain.User demo.springboot.test.controller.UserController.getUserByName(java.lang.String)</span><br><span class="line"></span><br><span class="line">Async:</span><br><span class="line">    Async started = false</span><br><span class="line">     Async result = null</span><br><span class="line"></span><br><span class="line">Resolved Exception:</span><br><span class="line">             Type = null</span><br><span class="line"></span><br><span class="line">ModelAndView:</span><br><span class="line">        View name = null</span><br><span class="line">             View = null</span><br><span class="line">            Model = null</span><br><span class="line"></span><br><span class="line">FlashMap:</span><br><span class="line">       Attributes = null</span><br><span class="line"></span><br><span class="line">MockHttpServletResponse:</span><br><span class="line">           Status = 200</span><br><span class="line">    Error message = null</span><br><span class="line">          Headers = &#123;Content-Type=[application/json;charset=UTF-8]&#125;</span><br><span class="line">     Content type = application/json;charset=UTF-8</span><br><span class="line">             Body = &#123;&quot;id&quot;:23,&quot;username&quot;:&quot;scott&quot;,&quot;passwd&quot;:&quot;ac3af72d9f95161a502fd326865c2f15&quot;,&quot;createTime&quot;:1514535399000,&quot;status&quot;:&quot;1&quot;&#125;</span><br><span class="line">    Forwarded URL = null</span><br><span class="line">   Redirected URL = null</span><br><span class="line">          Cookies = []</span><br></pre></td></tr></table></figure>


<p>继续编写一个针对于该Controller<code>saveUser(@RequestBody User user)</code>方法的测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext wac;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ObjectMapper mapper;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setupMockMvc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">&quot;Dopa&quot;</span>);</span><br><span class="line">        user.setPasswd(<span class="string">&quot;ac3af72d9f95161a502fd326865c2f15&quot;</span>);</span><br><span class="line">        user.setStatus(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        String userJson = mapper.writeValueAsString(user);</span><br><span class="line">        mockMvc.perform(</span><br><span class="line">            MockMvcRequestBuilders.post(<span class="string">&quot;/user/save&quot;</span>)</span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">            .content(userJson.getBytes()))</span><br><span class="line">        .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">        .andDo(MockMvcResultHandlers.print());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行过程如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">MockHttpServletRequest:</span><br><span class="line">      HTTP Method = POST</span><br><span class="line">      Request URI = /user/save</span><br><span class="line">       Parameters = &#123;&#125;</span><br><span class="line">          Headers = &#123;Content-Type=[application/json;charset=UTF-8]&#125;</span><br><span class="line"></span><br><span class="line">Handler:</span><br><span class="line">             Type = demo.springboot.test.controller.UserController</span><br><span class="line">           Method = public void demo.springboot.test.controller.UserController.saveUser(demo.springboot.test.domain.User)</span><br><span class="line"></span><br><span class="line">Async:</span><br><span class="line">    Async started = false</span><br><span class="line">     Async result = null</span><br><span class="line"></span><br><span class="line">Resolved Exception:</span><br><span class="line">             Type = null</span><br><span class="line"></span><br><span class="line">ModelAndView:</span><br><span class="line">        View name = null</span><br><span class="line">             View = null</span><br><span class="line">            Model = null</span><br><span class="line"></span><br><span class="line">FlashMap:</span><br><span class="line">       Attributes = null</span><br><span class="line"></span><br><span class="line">MockHttpServletResponse:</span><br><span class="line">           Status = 200</span><br><span class="line">    Error message = null</span><br><span class="line">          Headers = &#123;&#125;</span><br><span class="line">     Content type = null</span><br><span class="line">             Body = </span><br><span class="line">    Forwarded URL = null</span><br><span class="line">   Redirected URL = null</span><br><span class="line">          Cookies = []</span><br></pre></td></tr></table></figure>


<p>值得注意的是，在一个完整的系统中编写测试单元时，可能需要模拟一个登录用户信息Session，MockMvc也提供了解决方案，可在初始化的时候模拟一个HttpSession：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"><span class="keyword">private</span> MockHttpSession session;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> WebApplicationContext wac;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setupMockMvc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();</span><br><span class="line">    session = <span class="keyword">new</span> MockHttpSession();</span><br><span class="line">    User user =<span class="keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="string">&quot;Dopa&quot;</span>);</span><br><span class="line">    user.setPasswd(<span class="string">&quot;ac3af72d9f95161a502fd326865c2f15&quot;</span>);</span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>, user); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>源码链接：<a target="_blank" rel="noopener" href="https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/19.Spring-Boot-Testing">https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/19.Spring-Boot-Testing</a></p>
<p>From: <a target="_blank" rel="noopener" href="https://mrbird.cc/Spring-Boot%20TESTing.html">MyBird</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/02/springboot%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" data-id="ckke5nr59009mcl8g4b8z0m55" data-title="springboot单元测试" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/springboot/" rel="tag">springboot</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" rel="tag">单元测试</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-springcloud入门" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/02/springcloud%E5%85%A5%E9%97%A8/" class="article-date">
  <time class="dt-published" datetime="2020-12-02T14:56:17.000Z" itemprop="datePublished">2020-12-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/springCloud/">springCloud</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/02/springcloud%E5%85%A5%E9%97%A8/">springcloud入门</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-RestTemplate的介绍"><a href="#1-RestTemplate的介绍" class="headerlink" title="1.RestTemplate的介绍"></a>1.RestTemplate的介绍</h1><p>一般情况下有如下三种http客户端工具类包都可以方便的进行http服务调用:</p>
<ul>
<li>httpClient</li>
<li>okHttp</li>
<li>JDK原生URLConnection</li>
</ul>
<p>spring提供了RestTemplate的工具类对上述的3种http客户端工具类进行了封装,可在spring项目中使用RestTemplate进行服务调用。</p>
<h2 id="1-1启动类注入RestTemplate"><a href="#1-1启动类注入RestTemplate" class="headerlink" title="1.1启动类注入RestTemplate"></a>1.1启动类注入RestTemplate</h2><p><img src="http://mele.cool//image-20200920144117052.png" alt="image-20200920144117052"></p>
<h2 id="1-2-代码中使用"><a href="#1-2-代码中使用" class="headerlink" title="1.2 代码中使用"></a>1.2 代码中使用</h2><p><img src="http://mele.cool//image-20200920144301465.png" alt="image-20200920144301465"></p>
<h1 id="2-入门工程"><a href="#2-入门工程" class="headerlink" title="2.入门工程"></a>2.入门工程</h1><p><img src="http://mele.cool//image-20200920145002197.png" alt="image-20200920145002197"></p>
<h2 id="2-1-父工程依赖"><a href="#2-1-父工程依赖" class="headerlink" title="2.1 父工程依赖"></a>2.1 父工程依赖</h2><blockquote>
<p>通过scope的import可以继承spring-cloud-dependencies工程中的依赖</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bgt<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>user-service<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>user-consumer<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span><span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper.starter.version</span>&gt;</span>2.1.5<span class="tag">&lt;/<span class="name">mapper.starter.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            spring-cloud &lt;scope&gt;import&lt;/scope&gt;此处配置意为本项目不仅继承springboot2.1.5.RELEASE的依赖坐标,同时也继承spring-cloud-dependencies Greenwich.SR1的依赖坐标--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            通用mapper--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mapper.starter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-user-service-生产者"><a href="#2-2-user-service-生产者" class="headerlink" title="2.2 user-service 生产者"></a>2.2 user-service 生产者</h2><h3 id="2-2-1依赖"><a href="#2-2-1依赖" class="headerlink" title="2.2.1依赖"></a>2.2.1依赖</h3><blockquote>
<p>版本号在父工程中管理,子工程不需要声明版本号</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--            通用mapper--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            mysql--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-配置文件"><a href="#2-2-2-配置文件" class="headerlink" title="2.2.2 配置文件"></a>2.2.2 配置文件</h3><p><img src="http://mele.cool//image-20200920170815660.png" alt="image-20200920170815660"></p>
<h3 id="2-2-3-创建实体类及数据库表"><a href="#2-2-3-创建实体类及数据库表" class="headerlink" title="2.2.3 创建实体类及数据库表"></a>2.2.3 创建实体类及数据库表</h3><h3 id="2-2-4-启动类加mybatis注解"><a href="#2-2-4-启动类加mybatis注解" class="headerlink" title="2.2.4 启动类加mybatis注解"></a>2.2.4 启动类加mybatis注解</h3><p><img src="http://mele.cool//image-20200920170950272.png" alt="image-20200920170950272"></p>
<h3 id="2-2-5-编写mapper"><a href="#2-2-5-编写mapper" class="headerlink" title="2.2.5 编写mapper"></a>2.2.5 编写mapper</h3><p><img src="http://mele.cool//image-20200920171020058.png" alt="image-20200920171020058"></p>
<h3 id="2-2-6-编写业务类service"><a href="#2-2-6-编写业务类service" class="headerlink" title="2.2.6 编写业务类service"></a>2.2.6 编写业务类service</h3><p><img src="http://mele.cool//image-20200920171117875.png" alt="image-20200920171117875"></p>
<h3 id="2-2-7-编写处理器controller"><a href="#2-2-7-编写处理器controller" class="headerlink" title="2.2.7 编写处理器controller"></a>2.2.7 编写处理器controller</h3><p><img src="http://mele.cool//image-20200920171207931.png" alt="image-20200920171207931"></p>
<h3 id="2-2-8-测试"><a href="#2-2-8-测试" class="headerlink" title="2.2.8 测试"></a>2.2.8 测试</h3><p><img src="http://mele.cool//image-20200920171249805.png" alt="image-20200920171249805"></p>
<h2 id="2-3-user-consumer-消费者"><a href="#2-3-user-consumer-消费者" class="headerlink" title="2.3 user-consumer 消费者"></a>2.3 user-consumer 消费者</h2><h3 id="2-3-1-添加依赖"><a href="#2-3-1-添加依赖" class="headerlink" title="2.3.1 添加依赖"></a>2.3.1 添加依赖</h3><p><img src="http://mele.cool//image-20200920171603411.png" alt="image-20200920171603411"></p>
<h3 id="2-3-2-启动类注入RestTemplate"><a href="#2-3-2-启动类注入RestTemplate" class="headerlink" title="2.3.2 启动类注入RestTemplate"></a>2.3.2 启动类注入RestTemplate</h3><p><img src="http://mele.cool//image-20200920171647566.png" alt="image-20200920171647566"></p>
<h3 id="2-3-3-编写controller"><a href="#2-3-3-编写controller" class="headerlink" title="2.3.3 编写controller"></a>2.3.3 编写controller</h3><blockquote>
<p>编写用到的user类</p>
</blockquote>
<p><img src="http://mele.cool//image-20200920171850133.png" alt="image-20200920171850133"></p>
<h3 id="2-3-4-测试"><a href="#2-3-4-测试" class="headerlink" title="2.3.4 测试"></a>2.3.4 测试</h3><p><img src="http://mele.cool//image-20200920171930021.png" alt="image-20200920171930021"></p>
<h2 id="2-4-问题"><a href="#2-4-问题" class="headerlink" title="2.4 问题"></a>2.4 问题</h2><p><img src="http://mele.cool//image-20200920172051654.png" alt="image-20200920172051654"></p>
<blockquote>
<p>上述的问题都可以通过Spring Cloud的各种组件解决。</p>
</blockquote>
<h1 id="3-Eureka-注册中心"><a href="#3-Eureka-注册中心" class="headerlink" title="3.Eureka 注册中心"></a>3.Eureka 注册中心</h1><p><img src="http://mele.cool//image-20200920172332720.png" alt="image-20200920172332720"></p>
<p><img src="http://mele.cool//image-20200920172535724.png" alt="image-20200920172535724"></p>
<blockquote>
<p>Eureka的主要功能是进行服务管理,定期检查服务状态,返回服务地址列表。</p>
</blockquote>
<h2 id="3-1-搭建eureka-server工程"><a href="#3-1-搭建eureka-server工程" class="headerlink" title="3.1 搭建eureka-server工程"></a>3.1 搭建eureka-server工程</h2><blockquote>
<p>Eureka是服务注册中心,只做服务注册;自身并不提供服务也不消费服务。可以搭建web工程使用Eureka ,可以使用Spring Boot方式搭建。</p>
</blockquote>
<p><img src="http://mele.cool//image-20200920172725325.png" alt="image-20200920172725325"></p>
<h3 id="3-1-1-依赖"><a href="#3-1-1-依赖" class="headerlink" title="3.1.1 依赖"></a>3.1.1 依赖</h3><p><img src="http://mele.cool//image-20200920172752229.png" alt="image-20200920172752229"></p>
<h3 id="3-1-2-启动类"><a href="#3-1-2-启动类" class="headerlink" title="3.1.2 启动类"></a>3.1.2 启动类</h3><p><img src="http://mele.cool//image-20200920172837013.png" alt="image-20200920172837013"></p>
<h3 id="3-1-3-配置文件"><a href="#3-1-3-配置文件" class="headerlink" title="3.1.3 配置文件"></a>3.1.3 配置文件</h3><p><img src="http://mele.cool//image-20200920173002950.png" alt="image-20200920173002950"></p>
<h3 id="3-1-4-启动测试-能否查看到"><a href="#3-1-4-启动测试-能否查看到" class="headerlink" title="3.1.4 启动测试,能否查看到"></a>3.1.4 启动测试,能否查看到</h3><p><img src="http://mele.cool//image-20200920173033190.png" alt="image-20200920173033190"></p>
<h2 id="3-2-服务注册与发现"><a href="#3-2-服务注册与发现" class="headerlink" title="3.2 服务注册与发现"></a>3.2 服务注册与发现</h2><blockquote>
<p><strong>目标:将user-service的服务注册到eureka并在consumer-demo中可以根据服务名称调用</strong></p>
</blockquote>
<p><img src="http://mele.cool//image-20200920173328373.png" alt="image-20200920173328373"></p>
<h3 id="3-2-1-生产者工程user-serivce依赖"><a href="#3-2-1-生产者工程user-serivce依赖" class="headerlink" title="3.2.1 生产者工程user-serivce依赖"></a>3.2.1 生产者工程user-serivce依赖</h3><p><img src="http://mele.cool//image-20200920173352540.png" alt="image-20200920173352540"></p>
<h3 id="3-2-2-生产者工程user-serivce启动器修改"><a href="#3-2-2-生产者工程user-serivce启动器修改" class="headerlink" title="3.2.2 生产者工程user-serivce启动器修改"></a>3.2.2 生产者工程user-serivce启动器修改</h3><p><img src="http://mele.cool//image-20200920173440400.png" alt="image-20200920173440400"></p>
<h3 id="3-2-3-生产者工程user-serivce修改配置文件"><a href="#3-2-3-生产者工程user-serivce修改配置文件" class="headerlink" title="3.2.3 生产者工程user-serivce修改配置文件"></a>3.2.3 生产者工程user-serivce修改配置文件</h3><p><img src="http://mele.cool//image-20200920173517140.png" alt="image-20200920173517140"></p>
<h3 id="3-2-4-生产者工程user-serivce启动测试测试"><a href="#3-2-4-生产者工程user-serivce启动测试测试" class="headerlink" title="3.2.4 生产者工程user-serivce启动测试测试"></a>3.2.4 生产者工程user-serivce启动测试测试</h3><blockquote>
<p>启动eureka服务,启动user-service服务,成功标准是在eureka界面可以看到user-service的服务注册成功.</p>
</blockquote>
<p><img src="http://mele.cool//image-20200920173722437.png" alt="image-20200920173722437"></p>
<h3 id="3-2-5-消费者工程user-consumer添加依赖"><a href="#3-2-5-消费者工程user-consumer添加依赖" class="headerlink" title="3.2.5 消费者工程user-consumer添加依赖"></a>3.2.5 消费者工程user-consumer添加依赖</h3><p><img src="http://mele.cool//image-20200920173911001.png" alt="image-20200920173911001"></p>
<h3 id="3-2-6-消费者工程user-consumer启动类修改"><a href="#3-2-6-消费者工程user-consumer启动类修改" class="headerlink" title="3.2.6 消费者工程user-consumer启动类修改"></a>3.2.6 消费者工程user-consumer启动类修改</h3><p><img src="http://mele.cool//image-20200920174001298.png" alt="image-20200920174001298"></p>
<h3 id="3-2-7-消费者工程user-consumer配置文件修改"><a href="#3-2-7-消费者工程user-consumer配置文件修改" class="headerlink" title="3.2.7 消费者工程user-consumer配置文件修改"></a>3.2.7 消费者工程user-consumer配置文件修改</h3><p><img src="http://mele.cool//image-20200920174042219.png" alt="image-20200920174042219"></p>
<h3 id="3-2-8-消费者工程user-consumer处理器controller修改"><a href="#3-2-8-消费者工程user-consumer处理器controller修改" class="headerlink" title="3.2.8 消费者工程user-consumer处理器controller修改"></a>3.2.8 消费者工程user-consumer处理器controller修改</h3><p><img src="http://mele.cool//image-20200920174501114.png" alt="image-20200920174501114"></p>
<h3 id="3-2-9-测试"><a href="#3-2-9-测试" class="headerlink" title="3.2.9 测试"></a>3.2.9 测试</h3><h2 id="3-3-Eureka-Server高可用配置"><a href="#3-3-Eureka-Server高可用配置" class="headerlink" title="3.3 Eureka Server高可用配置"></a>3.3 Eureka Server高可用配置</h2><p><img src="http://mele.cool//image-20200920175231122.png" alt="image-20200920175231122"></p>
<p><img src="http://mele.cool//image-20200920175352093.png" alt="image-20200920175352093"></p>
<h3 id="3-3-1-eureka-server工程1修改配置文件"><a href="#3-3-1-eureka-server工程1修改配置文件" class="headerlink" title="3.3.1 eureka-server工程1修改配置文件"></a>3.3.1 eureka-server工程1修改配置文件</h3><blockquote>
<p>${port:10086}  表示如果提供port就用提供的port,否则使用10086</p>
</blockquote>
<p><img src="http://mele.cool//image-20200920175601619.png" alt="image-20200920175601619"></p>
<h3 id="3-3-2-修改启动项-并复制一个新的启动器-相互注册"><a href="#3-3-2-修改启动项-并复制一个新的启动器-相互注册" class="headerlink" title="3.3.2 修改启动项,并复制一个新的启动器,相互注册."></a>3.3.2 修改启动项,并复制一个新的启动器,相互注册.</h3><p><img src="http://mele.cool//image-20200920175835585.png" alt="image-20200920175835585"></p>
<p><img src="http://mele.cool//image-20200920175956133.png" alt="image-20200920175956133"> </p>
<h3 id="3-3-3-启动两个启动类-查看效果"><a href="#3-3-3-启动两个启动类-查看效果" class="headerlink" title="3.3.3 启动两个启动类,查看效果"></a>3.3.3 启动两个启动类,查看效果</h3><p><img src="http://mele.cool//image-20200920180210637.png" alt="image-20200920180210637"></p>
<p><img src="http://mele.cool//image-20200920180253572.png" alt="image-20200920180253572"></p>
<h3 id="3-3-4-启动user-service"><a href="#3-3-4-启动user-service" class="headerlink" title="3.3.4  启动user-service"></a>3.3.4  启动user-service</h3><blockquote>
<p>本服务会自动注册到10086 10087两个eureka-server中</p>
<p>也可以在配置文件中配置注册到多台eureka-server中</p>
</blockquote>
<p><img src="http://mele.cool//image-20200920180419824.png" alt="image-20200920180419824"></p>
<h2 id="3-4-Eureka客户端与服务端配置"><a href="#3-4-Eureka客户端与服务端配置" class="headerlink" title="3.4 Eureka客户端与服务端配置"></a>3.4 Eureka客户端与服务端配置</h2><p><img src="http://mele.cool//image-20200920180739046.png" alt="image-20200920180739046"></p>
<h3 id="3-4-1-服务提供者设置-使用ip地址"><a href="#3-4-1-服务提供者设置-使用ip地址" class="headerlink" title="3.4.1 服务提供者设置 使用ip地址"></a>3.4.1 服务提供者设置 使用ip地址</h3><p><img src="http://mele.cool//image-20200920180818207.png" alt="image-20200920180818207"></p>
<p><img src="http://mele.cool//image-20200920203745777.png" alt="image-20200920203745777"></p>
<h3 id="3-4-2-服务提供者服务续约配置"><a href="#3-4-2-服务提供者服务续约配置" class="headerlink" title="3.4.2 服务提供者服务续约配置"></a>3.4.2 服务提供者服务续约配置</h3><p><img src="http://mele.cool//image-20200920203940965.png" alt="image-20200920203940965"></p>
<p><img src="http://mele.cool//image-20200920204216306.png" alt="image-20200920204216306"></p>
<blockquote>
<p>并非服务失效时间到了就一定会剔除,只是说时间到了表示该服务可以被剔除,具体啥时剔除需要eureka-server扫描到(默认60秒扫描一次). </p>
</blockquote>
<h3 id="3-4-3-服务消费者设置拉取服务列表间隔时间"><a href="#3-4-3-服务消费者设置拉取服务列表间隔时间" class="headerlink" title="3.4.3 服务消费者设置拉取服务列表间隔时间"></a>3.4.3 服务消费者设置拉取服务列表间隔时间</h3><p><img src="http://mele.cool//image-20200920204721072.png" alt="image-20200920204721072"></p>
<h3 id="3-4-4-eureka-server服务端设置失效剔除时间间隔"><a href="#3-4-4-eureka-server服务端设置失效剔除时间间隔" class="headerlink" title="3.4.4 eureka-server服务端设置失效剔除时间间隔"></a>3.4.4 eureka-server服务端设置失效剔除时间间隔</h3><p><img src="http://mele.cool//image-20200920205004580.png" alt="image-20200920205004580"></p>
<h3 id="3-4-5-eureka-server服务端设置关闭自我保护模式-开发中推荐设置"><a href="#3-4-5-eureka-server服务端设置关闭自我保护模式-开发中推荐设置" class="headerlink" title="3.4.5 eureka-server服务端设置关闭自我保护模式(开发中推荐设置)"></a>3.4.5 eureka-server服务端设置关闭自我保护模式(开发中推荐设置)</h3><p><img src="http://mele.cool//image-20200920205329811.png" alt="image-20200920205329811"></p>
<h1 id="4-Ribbon负载均衡"><a href="#4-Ribbon负载均衡" class="headerlink" title="4.Ribbon负载均衡"></a>4.Ribbon负载均衡</h1><p><img src="http://mele.cool//image-20200920211541115.png" alt="image-20200920211541115"></p>
<blockquote>
<p>依赖来自于eureka.</p>
<p>需求:可以使用RestTemplate访问<a target="_blank" rel="noopener" href="http://user-service/user/8%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E6%95%B0%E6%8D%AE%E3%80%82">http://user-service/user/8获取服务数据。</a></p>
</blockquote>
<p><img src="http://mele.cool//image-20200920211927539.png" alt="image-20200920211927539"></p>
<h2 id="4-1-启动两个user-serivce"><a href="#4-1-启动两个user-serivce" class="headerlink" title="4.1 启动两个user-serivce"></a>4.1 启动两个user-serivce</h2><h2 id="4-2-服务消费者启动类添加注解"><a href="#4-2-服务消费者启动类添加注解" class="headerlink" title="4.2 服务消费者启动类添加注解"></a>4.2 服务消费者启动类添加注解</h2><p><img src="http://mele.cool//image-20200920212132772.png" alt="image-20200920212132772"></p>
<h2 id="4-3-服务消费者controller修改"><a href="#4-3-服务消费者controller修改" class="headerlink" title="4.3 服务消费者controller修改"></a>4.3 服务消费者controller修改</h2><p><img src="http://mele.cool//image-20200920212242748.png" alt="image-20200920212242748"></p>
<h1 id="5-hystrix熔断器-服务消费者"><a href="#5-hystrix熔断器-服务消费者" class="headerlink" title="5.hystrix熔断器(服务消费者)"></a>5.hystrix熔断器(服务消费者)</h1><p><img src="http://mele.cool//image-20200923232356990.png" alt="image-20200923232356990"></p>
<p>雪崩问题:</p>
<p><img src="http://mele.cool//image-20200923232420682.png" alt="image-20200923232420682"></p>
<h2 id="5-1-开启熔断"><a href="#5-1-开启熔断" class="headerlink" title="5.1 开启熔断"></a>5.1 开启熔断</h2><p><img src="http://mele.cool//image-20200920213406074.png" alt="image-20200920213406074"></p>
<h3 id="5-1-1-依赖"><a href="#5-1-1-依赖" class="headerlink" title="5.1.1 依赖"></a>5.1.1 依赖</h3><p><img src="http://mele.cool//image-20200920213453131.png" alt="image-20200920213453131"></p>
<h3 id="5-1-2-服务消费者开启熔断"><a href="#5-1-2-服务消费者开启熔断" class="headerlink" title="5.1.2 服务消费者开启熔断"></a>5.1.2 服务消费者开启熔断</h3><p><img src="http://mele.cool//image-20200920213517996.png" alt="image-20200920213517996"></p>
<h3 id="5-1-3-服务消费者编写降级逻辑"><a href="#5-1-3-服务消费者编写降级逻辑" class="headerlink" title="5.1.3 服务消费者编写降级逻辑"></a>5.1.3 服务消费者编写降级逻辑</h3><p><img src="http://mele.cool//image-20200920213744472.png" alt="image-20200920213744472"></p>
<h3 id="5-1-4-服务消费者默认降级逻辑"><a href="#5-1-4-服务消费者默认降级逻辑" class="headerlink" title="5.1.4 服务消费者默认降级逻辑"></a>5.1.4 服务消费者默认降级逻辑</h3><blockquote>
<p>5.1.3中针对单个方法的降级逻辑,如果方法多了,每个方法都这么写不现实,可以根据类设置默认降级回调方法</p>
</blockquote>
<p><img src="http://mele.cool//image-20200920214231894.png" alt="image-20200920214231894"></p>
<p><img src="http://mele.cool//image-20200920214304060.png" alt="image-20200920214304060"></p>
<h3 id="5-1-5-服务消费者设置熔断器hystrix超时时间"><a href="#5-1-5-服务消费者设置熔断器hystrix超时时间" class="headerlink" title="5.1.5 服务消费者设置熔断器hystrix超时时间"></a>5.1.5 服务消费者设置熔断器hystrix超时时间</h3><p><img src="http://mele.cool//image-20200920214513101.png" alt="image-20200920214513101"></p>
<h2 id="5-2-熔断原理"><a href="#5-2-熔断原理" class="headerlink" title="5.2 熔断原理"></a>5.2 熔断原理</h2><p><img src="http://mele.cool//image-20200920215010560.png" alt="image-20200920215010560"><img src="http://mele.cool//image-20200920215206312.png" alt="image-20200920215206312"><img src="http://mele.cool//image-20200920215222319.png" alt="image-20200920215222319"></p>
<p>  修改熔断器阈值:</p>
<p><img src="http://mele.cool//image-20200920215607448.png" alt="image-20200920215607448"></p>
<h1 id="6-Feign"><a href="#6-Feign" class="headerlink" title="6. Feign"></a>6. Feign</h1><p><img src="http://mele.cool//image-20200920215753322.png" alt="image-20200920215753322"></p>
<h2 id="6-1-使用"><a href="#6-1-使用" class="headerlink" title="6.1 使用"></a>6.1 使用</h2><p><img src="http://mele.cool//image-20200920215855740.png" alt="image-20200920215855740"></p>
<h3 id="6-1-1-消费者工程添加依赖"><a href="#6-1-1-消费者工程添加依赖" class="headerlink" title="6.1.1 消费者工程添加依赖"></a>6.1.1 消费者工程添加依赖</h3><p><img src="http://mele.cool//image-20200920215941454.png" alt="image-20200920215941454"></p>
<h3 id="6-1-2-修改启动类-开启feign功能"><a href="#6-1-2-修改启动类-开启feign功能" class="headerlink" title="6.1.2 修改启动类,开启feign功能"></a>6.1.2 修改启动类,开启feign功能</h3><p><img src="http://mele.cool//image-20200920220030594.png" alt="image-20200920220030594"></p>
<h3 id="6-1-3-编写feign客户端代码"><a href="#6-1-3-编写feign客户端代码" class="headerlink" title="6.1.3 编写feign客户端代码"></a>6.1.3 编写feign客户端代码</h3><p><img src="http://mele.cool//image-20200920220209633.png" alt="image-20200920220209633"></p>
<h3 id="6-1-4-编写处理器controller"><a href="#6-1-4-编写处理器controller" class="headerlink" title="6.1.4 编写处理器controller"></a>6.1.4 编写处理器controller</h3><p><img src="http://mele.cool//image-20200920220336461.png" alt="image-20200920220336461"></p>
<h3 id="6-1-5-测试"><a href="#6-1-5-测试" class="headerlink" title="6.1.5 测试"></a>6.1.5 测试</h3><p><img src="http://mele.cool//image-20200920220426686.png" alt="image-20200920220426686"></p>
<h2 id="6-2feign负载均衡及熔断"><a href="#6-2feign负载均衡及熔断" class="headerlink" title="6.2feign负载均衡及熔断"></a>6.2feign负载均衡及熔断</h2><p><img src="http://mele.cool//image-20200920220645044.png" alt="image-20200920220645044"></p>
<h3 id="6-2-1-负载均衡"><a href="#6-2-1-负载均衡" class="headerlink" title="6.2.1 负载均衡"></a>6.2.1 负载均衡</h3><p><img src="http://mele.cool//image-20200920220707935.png" alt="image-20200920220707935"></p>
<p><img src="http://mele.cool//image-20200920220754005.png" alt="image-20200920220754005"></p>
<h3 id="6-2-2-hystrix支持-熔断"><a href="#6-2-2-hystrix支持-熔断" class="headerlink" title="6.2.2 hystrix支持  熔断"></a>6.2.2 hystrix支持  熔断</h3><h4 id="6-2-2-1-服务消费者修改配置文件开启feign熔断功能"><a href="#6-2-2-1-服务消费者修改配置文件开启feign熔断功能" class="headerlink" title="6.2.2.1 服务消费者修改配置文件开启feign熔断功能"></a>6.2.2.1 服务消费者修改配置文件开启feign熔断功能</h4><p><img src="http://mele.cool//image-20200920221055277.png" alt="image-20200920221055277"></p>
<h4 id="6-2-2-2-编写熔断降级类"><a href="#6-2-2-2-编写熔断降级类" class="headerlink" title="6.2.2.2 编写熔断降级类"></a>6.2.2.2 编写熔断降级类</h4><p><img src="http://mele.cool//image-20200920221259559.png" alt="image-20200920221259559"></p>
<h4 id="6-2-2-3-feign客户端指定使用降级类"><a href="#6-2-2-3-feign客户端指定使用降级类" class="headerlink" title="6.2.2.3  feign客户端指定使用降级类"></a>6.2.2.3  feign客户端指定使用降级类</h4><p><img src="http://mele.cool//image-20200920221348726.png" alt="image-20200920221348726"></p>
<h3 id="6-2-3-请求压缩"><a href="#6-2-3-请求压缩" class="headerlink" title="6.2.3 请求压缩"></a>6.2.3 请求压缩</h3><h3 id="6-2-4-日志级别"><a href="#6-2-4-日志级别" class="headerlink" title="6.2.4 日志级别"></a>6.2.4 日志级别</h3><h1 id="7-Gateway-网关"><a href="#7-Gateway-网关" class="headerlink" title="7.Gateway 网关"></a>7.Gateway 网关</h1><p><img src="http://mele.cool//image-20200923211651489.png" alt="image-20200923211651489"></p>
<p><img src="http://mele.cool//image-20200923211754242.png" alt="image-20200923211754242"></p>
<p><strong>核心概念:</strong></p>
<p><img src="http://mele.cool//image-20200923211925717.png" alt="image-20200923211925717"></p>
<p><img src="http://mele.cool//image-20200923212140202.png" alt="image-20200923212140202"></p>
<h2 id="7-1-入门工程"><a href="#7-1-入门工程" class="headerlink" title="7.1 入门工程"></a>7.1 入门工程</h2><h3 id="7-1-1-依赖"><a href="#7-1-1-依赖" class="headerlink" title="7.1.1 依赖"></a>7.1.1 依赖</h3><p><img src="http://mele.cool//image-20200923212228237.png" alt="image-20200923212228237"></p>
<h3 id="7-1-2-启动类"><a href="#7-1-2-启动类" class="headerlink" title="7.1.2 启动类"></a>7.1.2 启动类</h3><p> <img src="http://mele.cool//image-20200923212323963.png" alt="image-20200923212323963"></p>
<h3 id="7-1-3-配置文件"><a href="#7-1-3-配置文件" class="headerlink" title="7.1.3 配置文件"></a>7.1.3 配置文件</h3><p><img src="http://mele.cool//image-20200923212655857.png" alt="image-20200923212655857"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1:10010/user/8">http://127.0.0.1:10010/user/8</a> -&gt; <a target="_blank" rel="noopener" href="http://127.0.0.1:9091/user/8">http://127.0.0.1:9091/user/8</a></p>
</blockquote>
<h3 id="7-1-4-测试"><a href="#7-1-4-测试" class="headerlink" title="7.1.4 测试"></a>7.1.4 测试</h3><p><img src="http://mele.cool//image-20200923212902804.png" alt="image-20200923212902804"></p>
<h2 id="7-2-面向服务的路由-动态路由"><a href="#7-2-面向服务的路由-动态路由" class="headerlink" title="7.2 面向服务的路由(动态路由)"></a>7.2 面向服务的路由(动态路由)</h2><p><img src="http://mele.cool//image-20200923213930806.png" alt="image-20200923213930806"></p>
<p><img src="http://mele.cool//image-20200923213911706.png" alt="image-20200923213911706"></p>
<h2 id="7-3-路由前缀处理"><a href="#7-3-路由前缀处理" class="headerlink" title="7.3 路由前缀处理"></a>7.3 路由前缀处理</h2><p><img src="http://mele.cool//image-20200923214142011.png" alt="image-20200923214142011"></p>
<h4 id="7-3-1-添加前缀"><a href="#7-3-1-添加前缀" class="headerlink" title="7.3.1 添加前缀"></a>7.3.1 添加前缀</h4><p><img src="http://mele.cool//image-20200923214503568.png" alt="image-20200923214503568"></p>
<p><img src="http://mele.cool//image-20200923214600258.png" alt="image-20200923214600258"></p>
<h3 id="7-3-2-去除前缀"><a href="#7-3-2-去除前缀" class="headerlink" title="7.3.2 去除前缀"></a>7.3.2 去除前缀</h3><p><img src="http://mele.cool//image-20200923214822024.png" alt="image-20200923214822024"></p>
<p><img src="http://mele.cool//image-20200923214910646.png" alt="image-20200923214910646"></p>
<h2 id="7-4-过滤器"><a href="#7-4-过滤器" class="headerlink" title="7.4 过滤器"></a>7.4 过滤器</h2><p><img src="http://mele.cool//image-20200923215013929.png" alt="image-20200923215013929"></p>
<p> <img src="http://mele.cool//image-20200923215301331.png" alt="image-20200923215301331"></p>
<p><img src="http://mele.cool//image-20200923215334116.png" alt="image-20200923215334116"></p>
<p><img src="http://mele.cool//image-20200923215428236.png" alt="image-20200923215428236"></p>
<p><img src="http://mele.cool//image-20200923215516964.png" alt="image-20200923215516964"></p>
<p><img src="http://mele.cool//image-20200923215547317.png" alt="image-20200923215547317"></p>
<p><img src="http://mele.cool//image-20200923215701949.png" alt="image-20200923215701949"></p>
<h2 id="7-5-自定义过滤器"><a href="#7-5-自定义过滤器" class="headerlink" title="7.5 自定义过滤器"></a>7.5 自定义过滤器</h2><h3 id="7-5-1-自定义局部过滤器"><a href="#7-5-1-自定义局部过滤器" class="headerlink" title="7.5.1 自定义局部过滤器"></a>7.5.1 自定义局部过滤器</h3><blockquote>
<p>需求:在过滤器( MyParamGatewayFilterFactory )中将<a target="_blank" rel="noopener" href="http://localhost:10010/api/user/8?name=itcast%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0name%E7%9A%84%E5%80%BC%E8%8E%B7%E5%8F%96%E5%88%B0%E5%B9%B6%E8%BE%93%E5%87%BA%E5%88%B0%E6%8E%A7%E5%88%B6%E5%8F%B0;%E5%B9%B6%E4%B8%94%E5%8F%82%E6%95%B0%E5%90%8D%E6%98%AF%E5%8F%AF%E5%8F%98%E7%9A%84,%E4%B9%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%AF%8F%E6%AC%A1%E9%83%BD%E6%98%AFname">http://localhost:10010/api/user/8?name=itcast中的参数name的值获取到并输出到控制台;并且参数名是可变的,也就是不一定每次都是name</a> ;需要可以通过配置过滤器的时候做到配置参数名。</p>
</blockquote>
<h4 id="7-5-1-1-配置"><a href="#7-5-1-1-配置" class="headerlink" title="7.5.1.1 配置"></a>7.5.1.1 配置</h4><p><img src="http://mele.cool//image-20200923220045239.png" alt="image-20200923220045239"></p>
<h4 id="7-5-1-2-编写过滤器类"><a href="#7-5-1-2-编写过滤器类" class="headerlink" title="7.5.1.2 编写过滤器类"></a>7.5.1.2 编写过滤器类</h4><p><img src="http://mele.cool//image-20200923220916297.png" alt="image-20200923220916297"></p>
<h4 id="7-5-1-3-测试"><a href="#7-5-1-3-测试" class="headerlink" title="7.5.1.3 测试"></a>7.5.1.3 测试</h4><p><img src="http://mele.cool//image-20200923221005101.png" alt="image-20200923221005101"><img src="http://mele.cool//image-20200923221026836.png" alt="image-20200923221026836"></p>
<h3 id="7-5-2-自定义全局过滤器"><a href="#7-5-2-自定义全局过滤器" class="headerlink" title="7.5.2 自定义全局过滤器"></a>7.5.2 自定义全局过滤器</h3><blockquote>
<p>需求:编写全局过滤器,在过滤器中检查请求地址是否携带token参数。如果token参数的值存在则放行;如果token的参数值为空或者不存在则设置返回的状态码为:未授权也不再执行下去</p>
</blockquote>
<h4 id="7-5-2-1-编写全局过滤器"><a href="#7-5-2-1-编写全局过滤器" class="headerlink" title="7.5.2.1 编写全局过滤器"></a>7.5.2.1 编写全局过滤器</h4><p><img src="http://mele.cool//image-20200923221443289.png" alt="image-20200923221443289"></p>
<h4 id="7-5-2-2-测试"><a href="#7-5-2-2-测试" class="headerlink" title="7.5.2.2 测试"></a>7.5.2.2 测试</h4><p> <img src="http://mele.cool//image-20200923221716106.png" alt="image-20200923221716106"><img src="http://mele.cool//image-20200923221740245.png" alt="image-20200923221740245"></p>
<h2 id="7-6-gateway其他配置"><a href="#7-6-gateway其他配置" class="headerlink" title="7.6 gateway其他配置"></a>7.6 gateway其他配置</h2><p><img src="http://mele.cool//image-20200923221838328.png" alt="image-20200923221838328"><img src="http://mele.cool//image-20200923221937995.png" alt="image-20200923221937995"><img src="http://mele.cool//image-20200923222035564.png" alt="image-20200923222035564"><img src="http://mele.cool//image-20200923222243751.png" alt="image-20200923222243751"><img src="http://mele.cool//image-20200923222311843.png" alt="image-20200923222311843"></p>
<h1 id="8-springcloud-config-配置中心"><a href="#8-springcloud-config-配置中心" class="headerlink" title="8.springcloud config 配置中心"></a>8.springcloud config 配置中心</h1><blockquote>
<p>spring cloud config作用:可以通过修改在git仓库中的配置文件实现其它所有微服务的配置文件的修改。</p>
</blockquote>
<p><img src="http://mele.cool//image-20200923222455968.png" alt="image-20200923222455968"><img src="http://mele.cool//image-20200923222521176.png" alt="image-20200923222521176"></p>
<h2 id="8-1-搭建配置中心微服务"><a href="#8-1-搭建配置中心微服务" class="headerlink" title="8.1 搭建配置中心微服务"></a>8.1 搭建配置中心微服务</h2><h3 id="8-1-1-依赖"><a href="#8-1-1-依赖" class="headerlink" title="8.1.1 依赖"></a>8.1.1 依赖</h3><p><img src="http://mele.cool//image-20200923223034987.png" alt="image-20200923223034987"></p>
<h3 id="8-1-2-启动类"><a href="#8-1-2-启动类" class="headerlink" title="8.1.2 启动类"></a>8.1.2 启动类</h3><p><img src="http://mele.cool//image-20200923223109585.png" alt="image-20200923223109585"></p>
<h3 id="8-1-3-配置文件"><a href="#8-1-3-配置文件" class="headerlink" title="8.1.3 配置文件"></a>8.1.3 配置文件</h3><p><img src="http://mele.cool//image-20200923223203360.png" alt="image-20200923223203360"></p>
<h3 id="8-1-4-测试"><a href="#8-1-4-测试" class="headerlink" title="8.1.4 测试"></a>8.1.4 测试</h3><blockquote>
<p>在gitee中修改了配置文件会在配置中心服务及时更新。</p>
</blockquote>
<p><img src="http://mele.cool//image-20200923223301672.png" alt="image-20200923223301672"></p>
<h2 id="8-2-获取配置中心配置"><a href="#8-2-获取配置中心配置" class="headerlink" title="8.2  获取配置中心配置"></a>8.2  获取配置中心配置</h2><p><img src="http://mele.cool//image-20200923223953961.png" alt="image-20200923223953961"></p>
<blockquote>
<p> <strong>目标</strong>:改造用户微服务user-service ,配置文件信息不再由微服务项目提供,而是从配置中心获取<br> <strong>需求</strong>:将服务提供工程user-service的application.yml配置文件删除,修改为从配置中心config-server中获取。<br> <strong>实现步骤:</strong><br>     1.添加启动器依赖;<br>     2.修改配置文件;<br>     3.启动测试</p>
</blockquote>
<h3 id="8-2-1-依赖"><a href="#8-2-1-依赖" class="headerlink" title="8.2.1 依赖"></a>8.2.1 依赖</h3><p><img src="http://mele.cool//image-20200923223751935.png" alt="image-20200923223751935"></p>
<h3 id="8-2-2-删除原来配置文件application-propetes-创建bootstrap-yml"><a href="#8-2-2-删除原来配置文件application-propetes-创建bootstrap-yml" class="headerlink" title="8.2.2 删除原来配置文件application.propetes,创建bootstrap.yml"></a>8.2.2 删除原来配置文件application.propetes,创建bootstrap.yml</h3><blockquote>
<p>将原来的application.yml删除;然后添加bootstrap.yml配置文件,该文件也是spring boot的默认配置文件,其内容经常配置一些项目中固定的配置项。如果是项目经常变动的应该配置到application.yml中,现在使用了配置中心则应该配置到git仓库中对于的配置文件。</p>
</blockquote>
<p><img src="http://mele.cool//image-20200923224222475.png" alt="image-20200923224222475"></p>
<h3 id="8-2-3-测试成功"><a href="#8-2-3-测试成功" class="headerlink" title="8.2.3 测试成功"></a>8.2.3 测试成功</h3><p><img src="http://mele.cool//image-20200923224328755.png" alt="image-20200923224328755"></p>
<h1 id="9-springcloud-bus消息总线"><a href="#9-springcloud-bus消息总线" class="headerlink" title="9.springcloud bus消息总线"></a>9.springcloud bus消息总线</h1><blockquote>
<p>Spring Cloud Bus是用轻量的消息代理将分布式的节点连接起来,可以用于广播配置文件的更改或者服务的监控管理。也就是消息总线可以为微服务做监控,也可以实现应用程序之间相互通信。 Spring Cloud Bus可选的消息 理有RabbitMQ和Kafka</p>
<p><strong>Spring Cloud Bus作用:将git仓库的配置文件更新,在不重启系统的情况下实现及时同步到各个微服务。</strong></p>
</blockquote>
<p><img src="http://mele.cool//image-20200923225605902.png" alt="image-20200923225605902"></p>
<p><strong>目标</strong>:启动RabbitMQ通过修改码云中的配置文件后发送Post请求实现及时更新用户微服务中的配置项分析<br><strong>需求:**在码云的git仓库中修改user-dev.yml配置文件,实现不重启user-service的情况下可以及时更新配置文件。<br>**实现步骤:</strong></p>
<ol>
<li>启动RabbitMQ;</li>
<li>修改配置中心config-server;</li>
<li>修改服务提供工程dser-service ;</li>
<li>测试</li>
</ol>
<h2 id="9-1改造配置中心"><a href="#9-1改造配置中心" class="headerlink" title="9.1改造配置中心"></a>9.1改造配置中心</h2><h3 id="9-1-1-在config-server项目的pom-xml文件中加入Spring-Cloud-Bus相关依赖"><a href="#9-1-1-在config-server项目的pom-xml文件中加入Spring-Cloud-Bus相关依赖" class="headerlink" title="9.1.1 在config-server项目的pom.xml文件中加入Spring Cloud Bus相关依赖"></a>9.1.1 在config-server项目的pom.xml文件中加入Spring Cloud Bus相关依赖</h3><p><img src="http://mele.cool//image-20200923225337626.png" alt="image-20200923225337626"></p>
<h3 id="9-1-2-修改配置文件"><a href="#9-1-2-修改配置文件" class="headerlink" title="9.1.2 修改配置文件"></a>9.1.2 修改配置文件</h3><p><img src="http://mele.cool//image-20200923225648167.png" alt="image-20200923225648167"></p>
<h2 id="9-3-修改服务提供工程"><a href="#9-3-修改服务提供工程" class="headerlink" title="9.3 修改服务提供工程"></a>9.3 修改服务提供工程</h2><h3 id="9-3-1-添加依赖"><a href="#9-3-1-添加依赖" class="headerlink" title="9.3.1 添加依赖"></a>9.3.1 添加依赖</h3><p><img src="http://mele.cool//image-20200923225758719.png" alt="image-20200923225758719"></p>
<h3 id="9-3-2-配置文件"><a href="#9-3-2-配置文件" class="headerlink" title="9.3.2 配置文件"></a>9.3.2 配置文件</h3><p><img src="http://mele.cool//image-20200923225903422.png" alt="image-20200923225903422"></p>
<h3 id="9-3-3-修改控制器"><a href="#9-3-3-修改控制器" class="headerlink" title="9.3.3 修改控制器"></a>9.3.3 修改控制器</h3><p><img src="http://mele.cool//image-20200923225950867.png" alt="image-20200923225950867"></p>
<h3 id="9-3-4-测试"><a href="#9-3-4-测试" class="headerlink" title="9.3.4 测试"></a>9.3.4 测试</h3><p>git上修改完配置文件后,需要手动访问下配置中心的这个路径,才会发消息给服务获取最新配置项:</p>
<p><img src="http://mele.cool//image-20200923230359915.png" alt="image-20200923230359915"></p>
<p><img src="http://mele.cool//image-20200923230312058.png" alt="image-20200923230312058"></p>
<h1 id="10-springCloud综合应用"><a href="#10-springCloud综合应用" class="headerlink" title="10. springCloud综合应用"></a>10. springCloud综合应用</h1><p><img src="http://mele.cool//image-20200923230549118.png" alt="image-20200923230549118"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/02/springcloud%E5%85%A5%E9%97%A8/" data-id="ckke5nr5a009rcl8gajvshyrv" data-title="springcloud入门" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/springCloud/" rel="tag">springCloud</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-jdk8以上提高开发效率的新特性有哪些" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/02/jdk8%E4%BB%A5%E4%B8%8A%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B/" class="article-date">
  <time class="dt-published" datetime="2020-12-02T14:56:17.000Z" itemprop="datePublished">2020-12-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/02/jdk8%E4%BB%A5%E4%B8%8A%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B/">jdk8以上提高开发效率的新特性有哪些</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-接口的默认方法和静态方法"><a href="#1-接口的默认方法和静态方法" class="headerlink" title="1.接口的默认方法和静态方法"></a>1.接口的默认方法和静态方法</h1><p><strong>众所周知，在接口中定义的普通方法都是抽象方法，方法前面默认都会添加public abstract，不能有方法实现，需要在接口的实现类中对方法进行具体实现。</strong></p>
<p>但是<strong>Java8开始允许在接口中定义默认方法和静态方法</strong>，对于这两种方法，可以直接在接口对其进行实现，无需再在接口实现类中进行实现。</p>
<ul>
<li>默认方法：又叫扩展方法，在方法前面需通过default修饰,不能直接通过接口调用，必须通过接口实现类的实例对象进行方法调用</li>
<li>静态方法：又叫类方法，在方法前面需通过static修饰。可以直接通过接口调用。</li>
</ul>
<p><strong>普通方法必须实现，默认方法可以选择性重写，静态方法无法重写。</strong></p>
<h1 id="2-lambda表达式"><a href="#2-lambda表达式" class="headerlink" title="2.lambda表达式"></a>2.lambda表达式</h1><blockquote>
<p><strong>Lambda表达式是Java8非常重要的一个新特性,其基于函数式编程的思想,支持将代码作为方法参数进行使用</strong>。可以把Lambda表达式理解为通过一种更加简洁的方式表示可传递的匿名函数。<br>它本身没有名称,而且不像方法那样属于某一个类,但是可以有参数列表、代码体、返回值。使用了Lambda表达式之后就不需要再去编写匿名类了。</p>
</blockquote>
<h2 id="2-1基础格式"><a href="#2-1基础格式" class="headerlink" title="2.1基础格式:"></a>2.1基础格式:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(参数列表) ‐&gt; &#123;</span><br><span class="line">	方法体</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有参数的Lambda表达式</span></span><br><span class="line">()‐&gt;<span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//只有一个参数的Lambda表达式</span></span><br><span class="line">x -&gt; &#123;</span><br><span class="line">  System.out.println(x);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有多个参数的Lambda表达式</span></span><br><span class="line">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)-&gt;&#123;</span><br><span class="line">	System.out.println(x);</span><br><span class="line">  System.out.println(y);</span><br><span class="line">	<span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上述可以进行简写，因为在Lambda中，参数列表中参数的数据类型可以交给JVM根据上下文进行推断。所以可以不用定义类型。</span></span><br><span class="line"><span class="comment">//一个参数和仅一条语句的Lambda表达式</span></span><br><span class="line">x-&gt;<span class="number">3</span>+x;</span><br><span class="line"><span class="comment">//多个参数和仅一条语句的Lambda表达式</span></span><br><span class="line">(x,y) -&gt;x+y;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-Lambda表达式底层原理解析"><a href="#2-2-Lambda表达式底层原理解析" class="headerlink" title="2.2 Lambda表达式底层原理解析"></a>2.2 <strong>Lambda</strong>表达式底层原理解析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lambda循环比较 </span></span><br><span class="line">Arrays.sort(language,(o1,o2)‐&gt;(o1.compareTo(o2)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个使用Lambda表达式的方法 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceDemo</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span>&#123; </span><br><span class="line">		String[] language = &#123;<span class="string">&quot;c&quot;</span>, <span class="string">&quot;c++&quot;</span>, <span class="string">&quot;c#&quot;</span>, <span class="string">&quot;java&quot;</span>,<span class="string">&quot;python&quot;</span>, <span class="string">&quot;go&quot;</span>,<span class="string">&quot;hive&quot;</span>, <span class="string">&quot;php&quot;</span>&#125;; </span><br><span class="line">		List&lt;String&gt; list = Arrays.asList(language);</span><br><span class="line">    list.forEach(s‐&gt; System.out.println(s)); </span><br><span class="line">    &#125; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//将当前.java文件编译生成.class文件，执行命令后，会在当前文件夹生成对应的.class文件 </span></span><br><span class="line">javac SourceDemo.java</span><br><span class="line"><span class="comment">//将.class文件进行反编译，查看文件内容 </span></span><br><span class="line">javap ‐p SourceDemo.class</span><br><span class="line"><span class="comment">//  生成内容如下</span></span><br><span class="line">  Compiled from <span class="string">&quot;SourceDemo.java&quot;</span> </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">itheima</span>.<span class="title">lambda</span>.<span class="title">source</span>.<span class="title">SourceDemo</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> com.itheima.lambda.source.SourceDemo(); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> lambda$demo$<span class="number">0</span>(java.lang.String); </span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//此时可以发现，代码中执行Lambda表达式的部分生成了一个静态私有函数。这个静态私有函数的函数干就是 Lambda表达式里面的内容。 那么对于这个静态私有函数，在JDK8内部是如何实现调用的呢？可以查看 LambdaMetafactory 类，该类下有一个 metafactory方法，lambda表达式每一次在执行的时候都会进入到这个方法中，并且为lambda表达式创建一个内 部类。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想查看内部类里面的内容，可以在lambda表达式执行之前，添加 </span></span><br><span class="line">System.setProperty(<span class="string">&quot;jdk.internal.lambda.dumpProxyClasses&quot;</span>, <span class="string">&quot;D://&quot;</span>); </span><br><span class="line"><span class="comment">//这个方法会将运行时生成的内部类class文件进行输出。 当该文件生成后，可以通过 javap -c -p class文件名 查看文件中的内容</span></span><br><span class="line"><span class="comment">//此时可以发现编译后的Lambda表达式已经被执行。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>综上所述，Lambda表达式在执行的时候，会调用LambdaMetafactory.metafactory动态的生成内部类，在方法 内调用 SourceDemo$&amp;Lambda$1 ，内部类里的调用方法块并不是动态生成的，只是在原class里已经编译生成了一个 静态的方法，内部类只需要调用该静态方法。 </p>
</blockquote>
<h1 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3.函数式接口"></a>3.函数式接口</h1><blockquote>
<p>在Java8中为了让现在有的函数能够更加友好的使用Lambda表达式，因此引入了<strong>函数式接口</strong>这个概念。其是<strong>一个 仅有一个抽象方法的普通接口</strong>。如果声明多个抽象方法则会报错。但是默认方法和静态方法在此接口中可以定义多个。</p>
<p>要想自定义一个函数式接口的话，需要在<strong>接口上添加 @FunctionalInterface</strong> 。 </p>
<p>在Java8的类库设计中，已经引入了几个函数式接口：Predicate、Consumer、Function、Supplier </p>
</blockquote>
<h2 id="3-1-Predicate使用"><a href="#3-1-Predicate使用" class="headerlink" title="3.1 Predicate使用"></a>3.1 <strong>Predicate</strong>使用</h2><blockquote>
<p>Predicate接口是Java8定义的一个函数式接口，属于<strong>java.util.function</strong>包下，<strong>内部定义一个 抽象方法test、三个默认方法and，negate，or、一个静态方法isEqual</strong> </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.lambda.Student; </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList; </span><br><span class="line"><span class="keyword">import</span> java.util.List; </span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPredicateDemo</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Student&gt; <span class="title">filter</span><span class="params">(List&lt;Student&gt; studentList, Predicate&lt;Student&gt; predicate)</span></span>&#123; 		ArrayList&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();                                                                                         		studentList.forEach(s‐&gt;&#123; 	                                                                                      		<span class="keyword">if</span> (predicate.test(s))&#123;                                                                                        			list.add(s); </span><br><span class="line">	  &#125; </span><br><span class="line">  &#125;); </span><br><span class="line">                                                                                              <span class="keyword">return</span> list; </span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">    students.add(<span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;M&quot;</span>)); </span><br><span class="line">    students.add(<span class="keyword">new</span> Student(<span class="number">2</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;M&quot;</span>)); </span><br><span class="line">    students.add(<span class="keyword">new</span> Student(<span class="number">3</span>,<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;F&quot;</span>)); </span><br><span class="line">    List&lt;Student&gt; result = filter(students, (s) ‐&gt; s.getSex().equals(<span class="string">&quot;F&quot;</span>)); 	</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-Consumer使用"><a href="#3-2-Consumer使用" class="headerlink" title="3.2 Consumer使用"></a>3.2 <strong>Consumer</strong>使用</h2><blockquote>
<p>Consumer也是JDK8提供的函数式接口，用于进行<strong>获取数据</strong>的操作，其内部定义了一个抽象方法accept、一个默 认方法andThen。</p>
<p>对于accept()方法来说，它接受一个泛型T对象。如果现在需要访问类型T对象，并对其进行某些操作的话，就可以使用这个接口。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List <span class="keyword">import</span> java.util. function.Consumer.</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumerDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foreach</span><span class="params">(List&lt;String&gt; arrays, Consumer&lt;String&gt; consumer)</span>&#125;</span></span><br><span class="line"><span class="function">		arrays.<span class="title">forEach</span><span class="params">(s-&gt;consumer.accept (s)</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;string&gt; arrays = <span class="keyword">new</span> ArrayListo&gt;();</span><br><span class="line">		arrays.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">		arrays. add(<span class="string">&quot;python&quot;</span>);</span><br><span class="line">		arrays.add(<span class="string">&quot;go&quot;</span>);</span><br><span class="line">		arrays.add(<span class="string">&quot;hive&quot;</span>);</span><br><span class="line">		foreach(arrays, (s)-&gt; System.out.print(s+<span class="string">&quot;,&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-Function使用"><a href="#3-3-Function使用" class="headerlink" title="3.3 Function使用"></a>3.3 <strong>Function</strong>使用</h2><blockquote>
<p>Function主要用于进行类型转换的操作。内部提供一个抽象方法apply、两个默认方法compose，andThen、一个 静态方法identity </p>
<p>对于apply方法，它接收一个泛型T对象，并返回一个泛型R的对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFunctionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">convert</span><span class="params">(String value, Function&lt;String,Integer&gt; function)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function.apply(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer convert = convert(<span class="string">&quot;666&quot;</span>, value -&gt; Integer.valueOf(value)+<span class="number">222</span>);</span><br><span class="line">        System.out.println(convert);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-4-Supplier使用"><a href="#3-4-Supplier使用" class="headerlink" title="3.4 Supplier使用"></a>3.4 <strong>Supplier</strong>使用</h2><blockquote>
<p>Supplier也是用来进行值获取操作，内部只有一个抽象方法get</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySupplierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">getMin</span><span class="params">(Supplier&lt;Integer&gt; supplier)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">100</span>,<span class="number">22</span>,<span class="number">111</span>&#125;;</span><br><span class="line">        Integer min1 = getMin(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> min = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (min &gt; a) &#123;</span><br><span class="line">                    min = a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(min1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-5-类型检查-amp-推断"><a href="#3-5-类型检查-amp-推断" class="headerlink" title="3.5 类型检查**&amp;**推断"></a>3.5 类型检查**&amp;**推断</h2><blockquote>
<p>对于Lambda表达式的类型推断，它是对Java7中的目标类型推断进行的再次扩展。在Java7中引入了 菱形操作 </p>
<p>符 的概念，它可以是代码在编译时自动推断出泛型参数的类型。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全量声明 </span></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;(); </span><br><span class="line"><span class="comment">//菱形运算符 </span></span><br><span class="line">Map&lt;String,String&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>第二种书写代码的方式，也是我们在开发中经常使用的。不用明确声明泛型类型，代码在进行编译时，可以自动的进行类型推断。 </p>
<p>那么在Java8中对于这种使用方式又进一步扩展，可以省略Lambda表达式中的所有参数类型。在编译时根据Lambda表达式的上下文信息推断出参数的正确类型。这就是所谓的类型推断。</p>
<blockquote>
<p>到现在为止，对于Lambda表达式都只用到了方法体里面的参数，但Lambda其实是支持使用外部定义的变量的。在下面这段代码中，在Lambda表达式内部引用了外部变量。但是当在Lambda方法体内使用外部变量时，其必须声明为final。下述代码虽然没有显示的声明，但是在Java8它自动的会对需要为final的变量进行转换。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> port = <span class="number">8086</span>; </span><br><span class="line">  Runnable runnable = ()‐&gt; System.out.println(port); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4. 方法引用"></a>4. 方法引用</h1><p>方法引用更近一步的优化了Lambda的使用。它让代码感觉更加的自然。我们可以直接使用 :: 来简化Lambda表 达式的使用。其使用语法如下： 类名或实例名::方法名  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">students.sort(Comparator.comparing(Student::getId)); </span><br></pre></td></tr></table></figure>
<h1 id="5-Stream流使用"><a href="#5-Stream流使用" class="headerlink" title="5. Stream流使用"></a><strong>5. Stream</strong>流使用</h1><blockquote>
<p>流操作是Java8提供一个重要新特性，它允许开发人员以声明性方式处理集合，其<strong>核心类库主要改进了对集合类的 API和新增Stream操作</strong>。Stream类中每一个方法都对应集合上的一种操作。将真正的函数式编程引入到Java中，能 让代码更加简洁，极大地简化了集合的处理操作，提高了开发的效率和生产力。 </p>
<p>同时<strong>stream</strong>不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，<strong>Java</strong>容器或<strong>I/O</strong> channel<strong>等。在</strong>Stream**中的操作每一次都会产生新的流，内部不会像普通集合操作一样立刻获取值，而是惰性 取值，只有等到用户真正需要结果的时候才会执行。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; result = studentList.stream() </span><br><span class="line">  .filter(s ‐&gt; s.getAge() &lt; <span class="number">20</span>) <span class="comment">//过滤出年龄小于20岁的学生 </span></span><br><span class="line">  .sorted(Comparator.comparing(Student::getAge)) <span class="comment">//对结果进行排序 </span></span><br><span class="line">  .map(Student::getName) <span class="comment">// 提取出结合中的name属性 </span></span><br><span class="line">  .collect(Collectors.toList());<span class="comment">//转换成一个新的集合</span></span><br></pre></td></tr></table></figure>
<p>通过上述代码的执行，可以发现<strong>无需再去定义过多的冗余变量</strong>。我们可以将多个操作组成一个调用链，形成数据处理的流水线。在减少代码量的同时也更加的清晰易懂。 </p>
<p>并且对于现在调用的方法，本身都是一种高层次构件，与线程模型无关。因此在并行使用中，<strong>开发者们无需再去操心线程和锁了。Stream内部都已经做好了。</strong></p>
<p>steam流本身就是将集合的操作由外部迭代转换为了内部迭代。而内部迭代来说，它所操作的就是不是一个集合了，而是一个流。它会将所有的操作融合在流中，由其在内部进行处理，这种隐式的方式称之为内部迭代。 </p>
<p><strong>并且内部迭代支持并行处理，更利于集合操作的性能优化。其关注与对数据的计算。</strong> </p>
<h2 id="5-1流操作详解"><a href="#5-1流操作详解" class="headerlink" title="5.1流操作详解"></a>5.1流操作详解</h2><p>Stream流接口中定义了许多对于集合的操作方法,总的来说可以分为两大类:中间操作和终端操作。</p>
<ul>
<li>中间操作:会返回一个流,通过这种方式可以将多个中间操作连接起来,形成一个调用链,从而转换为另外一个流。除非调用链最后存在一个终端操作,否则中间操作对流不会进行任何结果处理。</li>
<li>终端操作:会返回一个具体的结果,如boolean, list, integer等。</li>
</ul>
<h3 id="5-1-1筛选"><a href="#5-1-1筛选" class="headerlink" title="5.1.1筛选"></a>5.1.1筛选</h3><p>对于集合的操作，经常性的会涉及到对于集中符合条件的数据筛选，Stream中对于数据筛选两个常见的API：filter(过滤)、distinct(去重) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filter</span></span><br><span class="line">Stream&lt;Student&gt; studentStream = studentList.stream() </span><br><span class="line">																.filter(s‐&gt;s.getAge() &lt; <span class="number">20</span>); <span class="comment">//.filter(Student::getIsPass);</span></span><br><span class="line">List&lt;Student&gt; list = studentStream.collect(Collectors.toList());</span><br><span class="line"><span class="comment">//distinct 对对象进行去重的话，还需要在对象内部重写，hashCode()和equals()方法才可以实现去重。</span></span><br><span class="line">List&lt;Integer&gt; result = numberList.stream() </span><br><span class="line">  .filter(n ‐&gt; n % <span class="number">2</span> == <span class="number">0</span>) </span><br><span class="line">  .distinct() </span><br><span class="line">  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h3 id="5-1-2-切片"><a href="#5-1-2-切片" class="headerlink" title="5.1..2 切片"></a>5.1..2 切片</h3><blockquote>
<p>基于**limit()**实现数据截取,该方法会返回一个不超过给定长度的流。</p>
<p>对于limit方法的实现，它会接收截取的长度，如果该值小于0，则抛出异常，否则会继续向下调用 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numberList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line">List&lt;Integer&gt; collect = numberList.stream().limit(<span class="number">5</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>基于**skip()**实现数据跳过,刚才已经基于limit完成了数据截取，但是limit对于数据截取是从前往后截取几个。如果现在对结果只获取后几个怎么办呢？此时就需要使用skip()。其与limit()的使用是相辅相成的。 </p>
<p>在skip方法中接收的n代表的是要跳过的元素个数，如果n小于0，抛出非法参数异常，如果n等于0，则返回当前 流。如果n小于0，才会调用makeRef()。同时指定limit参数为-1. </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numberList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line">List&lt;Integer&gt; collect = numberList.stream().limit(<span class="number">5</span>).skip(<span class="number">2</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h3 id="5-1-3映射"><a href="#5-1-3映射" class="headerlink" title="5.1.3映射"></a>5.1.3映射</h3><blockquote>
<p>在对集合进行操作的时候，我们经常会从某些对象中选择性的提取某些元素的值，就像编写sql一样，指定获取表 中特定的数据列 </p>
<p>#指定获取特定列  SELECT name FROM student; </p>
<p>在Stream API中也提供了类似的方法，map()。它接收一个函数作为方法参数，这个函数会被应用到集合中每一个 元素上，并最终将其映射为一个新的元素。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取每一个学生的名字，并形成一个新的集合 </span></span><br><span class="line">List&lt;String&gt; nameList = studentList.stream() </span><br><span class="line">  .map(Student::getName) </span><br><span class="line">  .collect(Collectors.toList());</span><br><span class="line"><span class="comment">//获取每一个学生名字的长度</span></span><br><span class="line">List&lt;Integer&gt; nameList = studentList.stream()</span><br><span class="line">  .map(Student::getName)</span><br><span class="line">  .map(String::length) <span class="comment">//也可以继续向下获取每一个名称的长度 </span></span><br><span class="line">  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h3 id="5-1-4匹配"><a href="#5-1-4匹配" class="headerlink" title="5.1.4匹配"></a>5.1.4匹配</h3><blockquote>
<p>有时还需要判断集合中某些元素是否匹配对应的条件，如果有的话，在进行后续的操作。在 Stream API中也提供了相关方法供我们进行使用，如anyMatch、allMatch等。他们对应的就是&amp;&amp;和||运算符。</p>
<p>anyMatch()主要用于判断流中是否至少存在一个符合条件的元素，它会返回一个boolean值，并且对于它的操作， 一般叫做短路求值 (某些操作不用操作整个流就可以得到结果:&amp;&amp;  || )</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//anyMatch执行时，只要流中有一个元素符合条件就会返回true</span></span><br><span class="line"><span class="keyword">if</span> (studentList.stream().anyMatch(s‐&gt;s.getAge()&lt;<span class="number">20</span>))&#123; </span><br><span class="line">		System.out.println(<span class="string">&quot;集合中有符合条件的学生&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//allMatch会判断流中是否所有条件都符合条件，全部符合才会返回true</span></span><br><span class="line"><span class="keyword">if</span> (studentList.stream().allMatch(Student::getIsPass))&#123; </span><br><span class="line">  System.out.println(<span class="string">&quot;所有学生合格&quot;</span>); </span><br><span class="line">&#125;<span class="keyword">else</span> &#123; </span><br><span class="line">  System.out.println(<span class="string">&quot;有学生不合格&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-1-5查找"><a href="#5-1-5查找" class="headerlink" title="5.1.5查找"></a>5.1.5查找</h3><ul>
<li>findany</li>
</ul>
<blockquote>
<p>fifindAny用于获取流中随机的某一个元素，并且利用短路在找到结果时，立即结束。</p>
<p>fifindAny对于同一数据源的多次操作会返回不同的结果。但是，如果我们的操作是串行的， 在数据较少的情况下，一般会返回第一个结果，如果在并行的情况下，那就不能确保返回的是第一个了。 </p>
<p>这种设计主要是为了获取更加高效的性能</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; optional = studentList.stream().filter(s ‐&gt; s.getAge() &lt; <span class="number">20</span>).findAny(); </span><br><span class="line"><span class="keyword">if</span> (optional.isPresent())&#123; </span><br><span class="line">	System.out.println(optional.get()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并行流</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123; </span><br><span class="line">  Optional&lt;Student&gt; optional = studentList.parallelStream().filter(s ‐&gt; s.getAge() &lt; <span class="number">20</span>).findAny();</span><br><span class="line">  <span class="keyword">if</span> (optional.isPresent())&#123; </span><br><span class="line">    System.out.println(optional.get()); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>findFirst</li>
</ul>
<blockquote>
<p>fifindFirst使用原理与fifindAny类似，但不管是在并行还是串行，指定返回流中的第一个元素。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123; </span><br><span class="line">  Optional&lt;Student&gt; optional = studentList </span><br><span class="line">    .stream() </span><br><span class="line">    <span class="comment">//.parallelStream() </span></span><br><span class="line">    .filter(s ‐&gt; s.getAge() &lt; <span class="number">20</span>) </span><br><span class="line">    .findFirst(); </span><br><span class="line">  <span class="keyword">if</span> (optional.isPresent())&#123; </span><br><span class="line">    System.out.println(optional.get()); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-1-6-归约"><a href="#5-1-6-归约" class="headerlink" title="5.1.6 归约"></a>5.1.6 归约</h3><blockquote>
<p>到现在截止，对于流的终端操作，我们返回的有boolean、Optional和List。但是在集合操作中，我们经常会涉及 对元素进行统计计算之类的操作，如求和、求最大值、最小值等，从而返回不同的数据结果。 </p>
</blockquote>
<h4 id="5-1-6-1基于-reduce-进行累积求和"><a href="#5-1-6-1基于-reduce-进行累积求和" class="headerlink" title="5.1.6.1基于**reduce()**进行累积求和"></a>5.1.6.1基于**reduce()**进行累积求和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数声明为初始值，第二个参数接收一个lambda表达式，代表当前流中的两 个元素，它会反复相加每一个元素，直到流被归约成一个最终结果</span></span><br><span class="line">Integer reduce = numbers.stream().reduce(<span class="number">0</span>, (a, b) ‐&gt; a + b);</span><br><span class="line"><span class="comment">//优化:Integer类中提供了sum方法，用于对两个数求和，这里我们可 以直接基于lambda方法调用的形式来使用</span></span><br><span class="line">Integer reduce = numbers.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="comment">//继续优化:reduce方法还有一个重载方法，不需要初始化值，会返回一个 Optional对象</span></span><br><span class="line">Optional&lt;Integer&gt; optional = numbers.stream().reduce(Integer::sum);</span><br></pre></td></tr></table></figure>
<h4 id="5-1-6-2最大值最小值"><a href="#5-1-6-2最大值最小值" class="headerlink" title="5.1.6.2最大值最小值"></a>5.1.6.2最大值最小值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大值</span></span><br><span class="line">Optional&lt;Integer&gt; optional = numbers.stream().reduce(Integer::max)</span><br><span class="line"><span class="comment">//优化</span></span><br><span class="line">Optional&lt;Integer&gt; optional = numbers.stream().max(Integer::compareTo);</span><br><span class="line"><span class="comment">//最小值</span></span><br><span class="line">Optional&lt;Integer&gt; min = numbers.stream().min(Integer::compareTo);</span><br></pre></td></tr></table></figure>
<h2 id="5-2构建流"><a href="#5-2构建流" class="headerlink" title="5.2构建流"></a>5.2构建流</h2><blockquote>
<p>难道Stream只能在集合基础上才能操作么？当然不是，我们还可以基于值、数组甚至文件来构建流，完成流操作。</p>
</blockquote>
<h3 id="5-2-1基于值创建流"><a href="#5-2-1基于值创建流" class="headerlink" title="5.2.1基于值创建流"></a>5.2.1基于值创建流</h3><blockquote>
<p>在Stream中提供了一个静态方法of，它可以接收任意数量参数，显式的创建一个流。并且会根据传入的参数类 型，构建不同泛型的流。</p>
<p>其内部就是基于Arrays中的stream方法将传入的多个参数转换为数组，然后创建流，并遍历数组，将每一个元素放入流中。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>); </span><br><span class="line">Stream&lt;Object&gt; stream = Stream.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">3</span>,<span class="keyword">true</span>,<span class="keyword">new</span> St());</span><br></pre></td></tr></table></figure>
<h3 id="5-2-2基于数组创建流"><a href="#5-2-2基于数组创建流" class="headerlink" title="5.2.2基于数组创建流"></a>5.2.2基于数组创建流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] numbers = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; integerStream = Arrays.stream(numbers);</span><br></pre></td></tr></table></figure>
<h3 id="5-2-3基于文件创建流"><a href="#5-2-3基于文件创建流" class="headerlink" title="5.2.3基于文件创建流"></a>5.2.3基于文件创建流</h3><blockquote>
<p>在Java中 提供了Files类，该类中提供了一些对于文件操作的相关方法。可以看下Files类中部分方法</p>
<p>在该类中部分方法返回值就是Stream，如：newDirectoryStream、list、lines等。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201002221915020.png" alt="image-20201002221915020"></p>
<h2 id="5-3收集器"><a href="#5-3收集器" class="headerlink" title="5.3收集器"></a>5.3收集器</h2><blockquote>
<p>对于数据的返回，我们返回的都是一些简单的数据类型。那现在我们要做一些复杂的数据返回，应该怎么做呢？ 比方说返回一个Map或者Map。就需要通过收集器来实现了</p>
<p>其内部主要核心是通过Collectors完成更加复杂的计算转换，从而获取到最终结果。并且Collectors内部提供了非常多的常用静态方法，直接拿来就可以了。比方说：toList。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据年龄进行分组</span></span><br><span class="line">Map&lt;Integer, List&lt;Student&gt;&gt; map = studentList.stream().collect(Collectors.groupingBy(Student::getAge));</span><br></pre></td></tr></table></figure>
<h3 id="5-3-1-通过-counting-统计集合总数"><a href="#5-3-1-通过-counting-统计集合总数" class="headerlink" title="5.3.1 通过**counting()**统计集合总数"></a>5.3.1 通过**counting()**统计集合总数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Long collect = studentList.stream().collect(Collectors.counting());</span><br><span class="line"><span class="comment">//简写</span></span><br><span class="line"><span class="keyword">long</span> count = studentList.stream().count();</span><br></pre></td></tr></table></figure>
<h3 id="5-3-2-通过maxBy-与minBy-获取最大值最小值"><a href="#5-3-2-通过maxBy-与minBy-获取最大值最小值" class="headerlink" title="5.3.2 通过maxBy()**与minBy()**获取最大值最小值"></a>5.3.2 通过<strong>maxBy()**与</strong>minBy()**获取最大值最小值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取年龄最大的学生 </span></span><br><span class="line">Optional&lt;Student&gt; optional = studentList.stream().collect(Collectors.maxBy(Comparator.comparing(Student::getAge)));</span><br><span class="line"><span class="comment">//优化</span></span><br><span class="line">Optional&lt;Student&gt; studentOptional = studentList.stream().max(Comparator.comparing(Student::getAge));</span><br><span class="line"><span class="comment">//获取年龄最小的学生 </span></span><br><span class="line">Optional&lt;Student&gt; studentOptional = studentList.stream().min(Comparator.comparing(Student::getAge));</span><br></pre></td></tr></table></figure>
<h3 id="5-3-3-通过-summingInt-进行数据汇总"><a href="#5-3-3-通过-summingInt-进行数据汇总" class="headerlink" title="5.3.3 通过**summingInt()**进行数据汇总"></a>5.3.3 通过**summingInt()**进行数据汇总</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取年龄总和</span></span><br><span class="line">Integer collect = studentList.stream().collect(Collectors.summingInt(Student::getAge));</span><br><span class="line"><span class="comment">//简化</span></span><br><span class="line"><span class="keyword">int</span> sum = studentList.stream().mapToInt(Student::getAge).sum();</span><br></pre></td></tr></table></figure>
<h3 id="5-3-4-通过-averagingInt-进行平均值获取"><a href="#5-3-4-通过-averagingInt-进行平均值获取" class="headerlink" title="5.3.4 通过**averagingInt()**进行平均值获取"></a>5.3.4 通过**averagingInt()**进行平均值获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Double collect = studentList.stream().collect(Collectors.averagingInt(Student::getAge));</span><br><span class="line"><span class="comment">//另外一种 这种方式虽然代码写多了一些，但是可以防止空值的出现。</span></span><br><span class="line">OptionalDouble average = studentList.stream().mapToDouble(Student::getAge).average(); </span><br><span class="line"><span class="keyword">if</span> (average.isPresent())&#123; </span><br><span class="line">  <span class="keyword">double</span> asDouble = average.getAsDouble(); </span><br><span class="line">  System.out.println(asDouble); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-5复杂结果返回"><a href="#5-3-5复杂结果返回" class="headerlink" title="5.3.5复杂结果返回"></a>5.3.5复杂结果返回</h3><blockquote>
<p>到此截止，已经通过收集器完成了汇总、求和、求最大最小值、求平均值的操作。但是值得注意的是，这些操作每 一次都是返回单独的一个值，但是日常开发中，经常需要获取多种内容，那这种需求应该如何完成？Collectors也 提供了相关静态方法进行解决，这三个方法可以，返回的都是收集器。其内部已经包含了多种结果内容 </p>
<p>上述方法返回了IntSummaryStatistics类，其内部提供了相关getter方法用于获取汇总值、总和、最大值最小值等 方法，直接调用即可 </p>
<p>对于另外的summarizingDouble()和summarizingLong()使用方式都是相同的。只不过他们适用于收集属性数据类 型为double和long而已。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics collect = studentList.stream().collect(Collectors.summarizingInt(Student::getAge));</span><br><span class="line"><span class="keyword">long</span> count = collect.getCount(); </span><br><span class="line"><span class="keyword">long</span> sum = collect.getSum(); </span><br><span class="line"><span class="keyword">int</span> max = collect.getMax(); </span><br><span class="line"><span class="keyword">int</span> min = collect.getMin(); </span><br><span class="line"><span class="keyword">double</span> average = collect.getAverage();</span><br></pre></td></tr></table></figure>
<h3 id="5-3-6通过-joining-进行数据拼接"><a href="#5-3-6通过-joining-进行数据拼接" class="headerlink" title="5.3.6通过**joining()**进行数据拼接"></a>5.3.6通过**joining()**进行数据拼接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String collect = studentList.stream().map(Student::getName).collect(Collectors.joining());</span><br><span class="line">String collect = studentList.stream().map(Student::getName).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br></pre></td></tr></table></figure>
<h3 id="5-3-7-分组"><a href="#5-3-7-分组" class="headerlink" title="5.3.7 分组"></a>5.3.7 分组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一级分组 根据年龄分组</span></span><br><span class="line">Map&lt;Integer, List&lt;Student&gt;&gt; map = studentList.stream().collect(Collectors.groupingBy(Student::getAge))</span><br><span class="line"><span class="comment">//根据年龄 是否通过进行多级分组</span></span><br><span class="line">Map&lt;Integer, Map&lt;String, List&lt;Student&gt;&gt;&gt; collect = studentList.stream().collect(Collectors.groupingBy(Student::getAge, Collectors.groupingBy(student ‐&gt; &#123; </span><br><span class="line">  <span class="keyword">if</span> (student.getIsPass()) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;pass&quot;</span>; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;not pass&quot;</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;)));</span><br><span class="line"><span class="comment">//多级分组变形 </span></span><br><span class="line"><span class="comment">//根据年龄进行分组，获取并汇总人数 </span></span><br><span class="line">Map&lt;Integer, Long&gt; collect = studentList.stream().collect(Collectors.groupingBy(Student::getAge, Collectors.counting())); </span><br><span class="line"><span class="comment">//根据年龄与是否及格进行分组，并汇总人数</span></span><br><span class="line">Map&lt;Integer, Map&lt;Boolean, Long&gt;&gt; collect = studentList.stream().collect(Collectors.groupingBy(Student::getAge, Collectors.groupingBy(Student::getIsPass, Collectors.counting())));</span><br><span class="line"><span class="comment">//根据年龄与是否及格进行分组，并获取每组中分数最高的学生</span></span><br><span class="line">Map&lt;Integer, Map&lt;Boolean, Student&gt;&gt; collect = studentList.stream().collect( Collectors.groupingBy(Student::getAge, </span><br><span class="line">                                                                                               		Collectors.groupingBy(Student::getIsPass, </span><br><span class="line">                                                                                                                     			Collectors.collectingAndThen( </span><br><span class="line">                                                                                                                       				Collectors.maxBy( </span><br><span class="line">                                                                                                                         						Comparator.comparing(Student::getScore)), Optional::get))));</span><br></pre></td></tr></table></figure>
<h3 id="5-3-8-自定义收集器"><a href="#5-3-8-自定义收集器" class="headerlink" title="5.3.8 自定义收集器"></a>5.3.8 自定义收集器</h3><blockquote>
<p>根据源码，Collector接口需要三个参数。T：流中要收集的元素类型、A：累加器的类型、R：收集的结果类型。 </p>
<p>如想自定义收集器，需要实现Collector接口中的五个方法：supplier、accumulator、fifinisher、combiner、 </p>
<p>characteristics </p>
<ul>
<li><p>supplier：用于创建一个容器，在调用它时，需要创建一个空的累加器实例，供后续方法使用。 </p>
</li>
<li><p>accumulator：基于supplier中创建的累加容器，进行累加操作。 </p>
</li>
<li><p>fifinisher：当遍历完流后，在其内部完成最终转换，返回一个最终结果。 </p>
</li>
<li><p>combiner：用于在并发情况下，将每个线程的容器进行合并。 </p>
</li>
<li><p>characteristics：用于定义收集器行为，如是否可以并行或使用哪些优化。其本身是一个枚举，内部有三个值，分别为： </p>
<p>CONCURRENT：表明收集器是并行的且只会存在一个中间容器。 </p>
<p>UNORDERED：表明结果不受流中顺序影响，收集是无序的。 </p>
<p>IDENTITY_FINISH：表明累积器的结果将会直接作为归约的最终结果，跳过fifinisher()。 </p>
</li>
</ul>
</blockquote>
<p>自定义收集器，返回所有合格的学员:</p>
<p><img src="http://mele.cool/image-20201002225245978.png" alt="image-20201002225245978"></p>
<p>使用自定义收集器 :</p>
<p><img src="http://mele.cool/image-20201002225308032.png" alt="image-20201002225308032"></p>
<h1 id="6-数据并行化"><a href="#6-数据并行化" class="headerlink" title="6.数据并行化"></a>6.数据并行化</h1><blockquote>
<p>为了让数据处理更加高效，Java8对于Stream也提供了并行的操作方式，在Java7之前如果要对数据并行处理，需要开发人员做的事情很多，如数据如何进行分块、开启多少个线程、哪个线程负责哪部分数据、出现线程竞争怎么办等等的问题。 </p>
<p>Java8对于数据并行化处理的实现非常简单，直接调用一个parallelStream()就可以开启并行化处理。</p>
<ul>
<li>并行：多个任务在同一时间点发生，并由不同的cpu进行处理，不互相抢占资源</li>
<li>并发：多个任务在同一时间点内同时发生了，但由同一个cpu进行处理，互相抢占资源</li>
</ul>
<p>当在大量数据处理上，数据并行化可以大量缩短任务的执行时间，将一个数据分解成多个部分，然后并行处理，最后将多个结果汇总，得到最终结果。 </p>
<p>int sum = numbers.parallelStream().mapToInt(i ‐&gt; i).sum(); </p>
<p>当将stream()切换为parallelStream()后，则完成了串行转换为并行的实现。 </p>
</blockquote>
<h2 id="6-1并行流原理"><a href="#6-1并行流原理" class="headerlink" title="6.1并行流原理"></a>6.1并行流原理</h2><p>对于并行流，其在底层实现中，是沿用了Java7提供的fork/join分解合并框架进行实现。fork根据<strong>cpu</strong>核数进行数据分块，join对各个fork进行合并。实现过程如下所示：</p>
<p><img src="http://mele.cool/image-20201002225809916.png" alt="image-20201002225809916"></p>
<h2 id="6-2并行流注意事项"><a href="#6-2并行流注意事项" class="headerlink" title="6.2并行流注意事项"></a>6.2并行流注意事项</h2><p>对于并行流，一定不要陷入一个误区：并行一定比串行快。并行在不同的情况下它不一定是比串行快的。影响并行流性能主要存在5个因素： </p>
<p><strong>1）数据大小：</strong>输入数据的大小，直接影响了并行处理的性能。因为在并行内部实现中涉及到了fork/join操作，它本身就存在性能上的开销。因此<strong>只有当数据量很大，使用并行处理才有意义。</strong> </p>
<p><strong>2）源数据结构</strong>：fork时会对源数据进行分割，数据源的特性直接影响了fork的性能。 </p>
<ul>
<li>ArrayList、数组或IntStream.range，可分解性最佳，因为他们都支持随机读取，因此可以被任意分割。 </li>
<li>HashSet、TreeSet，可分解性一般，其虽然可被分解，但因为其内部数据结构，很难被平均分解。 </li>
<li>LinkedList、Streams.iterate、BufferedReader.lines，可分解性极差，因为他们长度未知，无法确定在哪里进行分割。 </li>
</ul>
<p><strong>3）装箱拆箱</strong> </p>
<ul>
<li><strong>尽量使用基本数据类型，避免装箱拆箱。</strong> </li>
</ul>
<p><strong>4）CPU核数</strong> </p>
<ul>
<li>fork的产生数量是与可用CPU核数相关，可<strong>用的核数越多，获取的性能提升就会越大。</strong> </li>
</ul>
<p><strong>5）单元处理开销</strong> </p>
<ul>
<li><strong>花在流中每个元素的时间越长，并行操作带来的性能提升就会越明显</strong>。 </li>
</ul>
<h2 id="6-3结论"><a href="#6-3结论" class="headerlink" title="6.3结论"></a>6.3结论</h2><p>*<em>根据性能测试可知，对于简单操作，如果环境机是多核的话，建议使用Stream并行，同时在不考虑核数的情况</em>下，普通for循环性能要明显高于Stream串行，相差两倍左右。**</p>
<p><strong>对于复杂操作，推荐使用Stream API操作。</strong> </p>
<h1 id="7-异步编程CompletableFuture"><a href="#7-异步编程CompletableFuture" class="headerlink" title="7.异步编程CompletableFuture"></a>7.异步编程CompletableFuture</h1><blockquote>
<p>在现在软件开发的环境下，经常需要考虑如何能够设计出性能更加优异的系统。就像上面提到的数据并行化，就 是充分利用多核处理器结合并行操作来让代码执行效率更加优异。第二种方式就是让功能方法能够并行执行(异步编程CompletableFuture)。 </p>
</blockquote>
<h2 id="7-1Future介绍"><a href="#7-1Future介绍" class="headerlink" title="7.1Future介绍"></a>7.1Future介绍</h2><p>有的同学会说，对于任务并行需求，直接通过多线程实现不就可以了， 要注意，对于多线程的实现，java提 供了三种方式：继承Thread类、实现Runnable接口和实现Callable接口。但是业务代码在执行时会考虑执行顺序 的问题，直接基于这些方式实现多线程会出现两个问题： </p>
<p>1）要想控制线程执行顺序，会通过join()等待线程结束，那这样的话又回归到了阻塞式调用的思路上，违背了并行的需求。 另外还可以通过wait()、notify()、notifyAll()结合状态变量实现，但实现起来过于复杂。 </p>
<p>2）线程执行完之后，要想获取线程执行结果，还要用过共享变量或线程间通信等方式来获取，同样过于复杂。 为了解决上述问题，Java5中推出了<strong>Future</strong>，其初衷就是用于构建复杂并行操作。内部方法在返回时，不是返回一个值，而是返回Future对象。 其本质是在执行主业务的同时，异步的执行其他分业务，从而利用原本需要同步执行时的等待时间去执行其他的业 务，当需要获取其结果时，再进行获取。 </p>
<p><strong>在Future接口中有五个抽象方法：</strong> </p>
<ol>
<li>cancel()：取消任务, 取消成功返回true；入参mayInterruptIfRunning表示是否允许取消正在执行中的任务。 </li>
<li>isCancelled()：返回布尔值，代表是否取消成功。</li>
<li>isDone()：返回布尔值，代表是否执行完毕。 </li>
<li>get()：返回Future对象，获取执行结果，如果任务没有完成会阻塞到任务完成再返回。 </li>
<li>get(long timeout, TimeUnit unit)：获取执行结果并设置超时时间，如果超时则抛出TimeoutException </li>
</ol>
<h2 id="7-2CompletableFuture"><a href="#7-2CompletableFuture" class="headerlink" title="7.2CompletableFuture"></a>7.2CompletableFuture</h2><p>CompletableFuture是Java1.8提供的一个新类，其实现了Future与CompletionStage两个接口。提供了诸多API扩展功能，可以通过Stream形式简化异步编程的复杂度，同时提供通过回调方式处理计算结果。</p>
<h3 id="7-2-1-异步任务创建"><a href="#7-2-1-异步任务创建" class="headerlink" title="7.2.1 异步任务创建"></a>7.2.1 异步任务创建</h3><p>在CompletableFuture中提供了四个静态方法用于创建异步任务 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据源码可知，runAsync()分为一个参数和两个参数，并且其内部都会调用asyncRunStage().</span></span><br><span class="line"><span class="comment">//在该方法内部会创建异步任务，并把任务放入线程池中。并且runAsync()是没有返回值的。</span></span><br><span class="line"><span class="comment">//根据源码可知，当传入Executor会使用指定线程池执行，如果没有传入则使用默认ForkJoinPool.commonPool()执 行，值得注意的是，commonPool中都是守护线程，主线程执行完，子线程也就over了。因此建议当任务非常耗 时，使用自定义线程池。</span></span><br><span class="line"><span class="number">1.</span>runAsync(Runnable runnable) </span><br><span class="line"><span class="number">2.</span>runAsync(Runnable runnable,Executor executor) </span><br><span class="line"><span class="comment">//根据源码可知，supplyAsync()分为一个参数和两个参数，并且其内部都会调用asyncSupplyStage().</span></span><br><span class="line">  <span class="comment">//现在可知，其实supplyAsync()与runAsync()内部原理类似，但supplyAsync()有返回值。</span></span><br><span class="line"><span class="number">3.</span>supplyAsync(Supplier&lt;U&gt; supplier) </span><br><span class="line"><span class="number">4.</span>supplyAsync(Supplier&lt;U&gt; supplier,Executor executor)</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>使用示例:</p>
<p><img src="http://mele.cool/image-20201002232340066.png" alt="image-20201002232340066"></p>
<h3 id="7-2-2-异步计算结果触发回调"><a href="#7-2-2-异步计算结果触发回调" class="headerlink" title="7.2.2 异步计算结果触发回调"></a>7.2.2 异步计算结果触发回调</h3><blockquote>
<p>当异步任务结束或者抛出异常时，还要根据结果来完成特定的操作，对于这种需求CompletableFuture也提供了方法进行实现 </p>
</blockquote>
<h4 id="7-2-2-1whenComplete-与whenCompleteAsync"><a href="#7-2-2-1whenComplete-与whenCompleteAsync" class="headerlink" title="7.2.2.1whenComplete()**与whenCompleteAsync()**"></a><strong>7.2.2.1whenComplete()**与</strong>whenCompleteAsync()**</h4><p>whenComplete是在当前任务线程中继续执行指定的特定处理，而whenCompleteAsync会将指定的特定交给线程池另开启一个线程来执行。</p>
<p><img src="http://mele.cool/image-20201003162011657.png" alt="image-20201003162011657"></p>
<h4 id="7-2-2-2-exceptionally"><a href="#7-2-2-2-exceptionally" class="headerlink" title="7.2.2.2 exceptionally()"></a>7.2.2.2 <strong>exceptionally()</strong></h4><blockquote>
<p>exceptionally()与上述两个方法类似，都是用于当异步任务结束后，执行特定处理，但不同的是，上述两个方法即 可以处理正常的返回结果也可以处理异常，而exceptionally()只对异常进行处理，且其使用的是主线程。</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003162122297.png" alt="image-20201003162122297"></p>
<h3 id="7-2-3-多任务依赖执行"><a href="#7-2-3-多任务依赖执行" class="headerlink" title="7.2.3 多任务依赖执行"></a>7.2.3 多任务依赖执行</h3><h4 id="7-2-3-1-thenApply"><a href="#7-2-3-1-thenApply" class="headerlink" title="7.2.3.1 thenApply()"></a>7.2.3.1 <strong>thenApply()</strong></h4><blockquote>
<p>该方法会接收一个Function，用于声明后续要执行的业务，其中T代表上一个方法的执行结果，fn代表当前任务的 结果数据类型，最终其会映射到CompletableFuture中的结果数据类型。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003162440304.png" alt="image-20201003162440304"></p>
<p>根据运行结果可以看到，此处通过thenApply()串接了两个任务，第二个方法会在第一个方法执行完成后触发，且第二个方法的执行依赖于第一个方法的执行结果。 </p>
<h4 id="7-2-3-2-handle"><a href="#7-2-3-2-handle" class="headerlink" title="7.2.3.2 handle()"></a>7.2.3.2 <strong>handle()</strong></h4><blockquote>
<p>handle()的使用效果与thenApply()类似，但不同的是thenApply()只能处理任务的正常返回结果，一旦出现异常则 无法进行后续处理。而handle()即可以处理正常结果，也可以处理异常结果。</p>
<p>当第一个任务出现异常后，第二个任务会对该异常进行后续的处理，完成串性操作。</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003162616742.png" alt="image-20201003162616742"></p>
<h4 id="7-2-3-3-thenAccept"><a href="#7-2-3-3-thenAccept" class="headerlink" title="7.2.3.3 thenAccept()"></a>7.2.3.3 <strong>thenAccept()</strong></h4><blockquote>
<p>当将多个任务连接起来执行时，有时最终是不需要返回结果，CompletableFuture中也提供了方法实现。 thenAccept()使用与上述方法类似，接收任务执行结果，并使用，但其没有结果返回。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003162744285.png" alt="image-20201003162744285"></p>
<h4 id="7-2-3-4-thenRun"><a href="#7-2-3-4-thenRun" class="headerlink" title="7.2.3.4  thenRun()"></a>7.2.3.4  <strong>thenRun()</strong></h4><blockquote>
<p>thenRun()与thenAccept()使用基本相同，都是不会进行结果返回，但不同的是，thenRun()不关心方法是否有结 果，只要它完成，就会触发其执行。</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003162822708.png" alt="image-20201003162822708"></p>
<h3 id="7-2-4-两任务合并执行"><a href="#7-2-4-两任务合并执行" class="headerlink" title="7.2.4 两任务合并执行"></a>7.2.4 两任务合并执行</h3><h4 id="7-2-4-1-两个任务全部完成触发"><a href="#7-2-4-1-两个任务全部完成触发" class="headerlink" title="7.2.4.1 两个任务全部完成触发"></a>7.2.4.1 两个任务全部完成触发</h4><h5 id="7-2-4-1-1-thenCombine"><a href="#7-2-4-1-1-thenCombine" class="headerlink" title="7.2.4.1.1 thenCombine()"></a>7.2.4.1.1 <strong>thenCombine()</strong></h5><blockquote>
<p>当两个异步任务都执行完毕后，它可以将两个任务进行合并，获取到两个任务的执行结果，进行合并处理，最后会有返回值。 </p>
<p>内部会判断当前要执行的函数是否为null，或者任务有没有执行完。如果为true，则抛出空指针异常。接着会构建 一个新的任务，将任务放入栈中，线程池会为其分配线程让其执行。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163113414.png" alt="image-20201003163113414"></p>
<h5 id="7-2-4-1-2-thenAcceptBoth"><a href="#7-2-4-1-2-thenAcceptBoth" class="headerlink" title="7.2.4.1.2 thenAcceptBoth()"></a>7.2.4.1.2 <strong>thenAcceptBoth()</strong></h5><blockquote>
<p>thenAcceptBoth()使用与thenCombine()类似，当两个任务执行完，获取两个任务的结果进行特定处理，但 thenAcceptBoth()没有返回值 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163229028.png" alt="image-20201003163229028"></p>
<h5 id="7-2-4-1-3-runAfterBoth"><a href="#7-2-4-1-3-runAfterBoth" class="headerlink" title="7.2.4.1.3 runAfterBoth()"></a>7.2.4.1.3 <strong>runAfterBoth()</strong></h5><blockquote>
<p>当两个任务执行完毕，触发特定任务处理，但不要两个异步任务结果，且不会进行值返回。</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163318219.png" alt="image-20201003163318219"></p>
<h4 id="7-2-4-2-两个任务任意一个完成触发"><a href="#7-2-4-2-两个任务任意一个完成触发" class="headerlink" title="7.2.4.2 两个任务任意一个完成触发"></a>7.2.4.2 两个任务任意一个完成触发</h4><h5 id="7-2-4-2-1-applyToEither"><a href="#7-2-4-2-1-applyToEither" class="headerlink" title="7.2.4.2.1 applyToEither()"></a>7.2.4.2.1 <strong>applyToEither()</strong></h5><blockquote>
<p>当两个任务异步任务执行，谁先执行完，就以谁的结果为准，完成后续的业务处理，并且会进行结果值返回。</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163436119.png" alt="image-20201003163436119"></p>
<h5 id="7-2-4-2-2-acceptEither"><a href="#7-2-4-2-2-acceptEither" class="headerlink" title="7.2.4.2.2 acceptEither()"></a>7.2.4.2.2 <strong>acceptEither()</strong></h5><blockquote>
<p>acceptEither()的使用效果与applyToEither()类似，但acceptEither()没有返回值</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163527665.png" alt="image-20201003163527665"></p>
<h5 id="7-2-4-2-3-runAfterEither"><a href="#7-2-4-2-3-runAfterEither" class="headerlink" title="7.2.4.2.3 runAfterEither()"></a>7.2.4.2.3 <strong>runAfterEither()</strong></h5><blockquote>
<p>当两个任务执行，只要有一个任务执行完，则触发特定处理执行，无需使用异步任务的执行结果，且特定处理不会进行值的返回。</p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163634259.png" alt="image-20201003163634259"></p>
<h3 id="7-2-5-多任务组合执行"><a href="#7-2-5-多任务组合执行" class="headerlink" title="7.2.5 多任务组合执行"></a>7.2.5 多任务组合执行</h3><h4 id="7-2-5-1-allOf"><a href="#7-2-5-1-allOf" class="headerlink" title="7.2.5.1 allOf()"></a>7.2.5.1 <strong>allOf()</strong></h4><blockquote>
<p>当一个特定业务处理任务的执行需要一组异步任务完成后才能执行的话，就可以通过allOf()实现。适用场景：假设现在有一个Z任务，它的执行需要[A,B,C,D,E,F]这一组异步任务全部执行完才能触发。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003163858821.png" alt="image-20201003163858821"></p>
<h4 id="7-2-5-2-）anyOf"><a href="#7-2-5-2-）anyOf" class="headerlink" title="7.2.5.2 ）anyOf()"></a>7.2.5.2 ）<strong>anyOf()</strong></h4><blockquote>
<p>使用anyOf()时，当一组异步任务中，只要有一个执行完毕，则会被触发，利用该特性可以用来获取最快的那个线程结果。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003164020818.png" alt="image-20201003164020818"></p>
<h1 id="8-Optional"><a href="#8-Optional" class="headerlink" title="8.Optional"></a>8.Optional</h1><blockquote>
<p>为了防止空指针异常的出现，Java8中引入了一个新类Optional，对于它之前我们已经进行了简单的实现。其本质 就是通过Optional类对值进行封装， 当有值的时候，会把该值封装到Optional类中。如果没有值的话，则会在该 类封装一个Empty </p>
</blockquote>
<h2 id="8-1-创建optional对象"><a href="#8-1-创建optional对象" class="headerlink" title="8.1 创建optional对象"></a>8.1 创建optional对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接返回一个空的Optional实例，内部不会存在任何值。</span></span><br><span class="line">Optional&lt;Student&gt; studentOptional = Optional.empty(); </span><br><span class="line"><span class="comment">//返回一个存在值的Optional对象，并且该值不允许null的存在。如果调用该方法时传入参数 是null，则立刻抛出NullPointerException，而不是等到你用这个对象时才抛出，相当于进行了立即检查。</span></span><br><span class="line">Optional&lt;Student&gt; studentOptional = Optional.of(student);</span><br><span class="line"><span class="comment">//ofNullable()同样也会返回一个存在值的Optional对象，但是它和of()最大的不同在于，它会对传入 的值进行判断，如果传入的值为null，其会调用empty()返回一个不包含内容的Optional，如果不为null，则会调用 of()返回一个包含内容的Optional</span></span><br><span class="line">Optional&lt;Student&gt; studentOptional = Optional.ofNullable(student);</span><br></pre></td></tr></table></figure>
<h2 id="8-2基于optional对象获取值"><a href="#8-2基于optional对象获取值" class="headerlink" title="8.2基于optional对象获取值"></a>8.2基于optional对象获取值</h2><blockquote>
<p>Optional类中提供了两个方法用于判断Optional是否有值，分别是i<strong>sPresent()和ifPresent(Consumer&lt;? super T&gt; consumer)**。</strong>其一般与ofNullable()搭配使用**，因为of()在创建时已经完成了判断，而empty()只是单纯了实例化了 一个Optional对象。 </p>
</blockquote>
<ul>
<li><p>**isPresent()**内部非常简单，就是判断这个值是否为null。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; studentOptional = Optional.ofNullable(student); </span><br><span class="line"><span class="keyword">if</span> (studentOptional.isPresent())&#123; <span class="comment">//存在 </span></span><br><span class="line">  System.out.println(<span class="string">&quot;student存在&quot;</span>); </span><br><span class="line">&#125;<span class="keyword">else</span> &#123; </span><br><span class="line">  System.out.println(<span class="string">&quot;student不存在&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>**ifPresent()**方法在执行时，接收一个consumer函数式接口，如果value不为null，则通过consumer中的 </p>
<p>accept方法获取该值。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; studentOptional = Optional.ofNullable(student); studentOptional.ifPresent(s‐&gt; System.out.println(<span class="string">&quot;学生存在&quot;</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>get()</strong></p>
<blockquote>
<p>get()的使用非常简单，但不安全，因为其在获取值的时候，如果值存在，则直接返回封装在Optional中的值，如 果不存在，则抛出NoSuchElementException。因此它的使用前提是已经确定Optional中有值，否则没有使用意义。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (studentOptional.isPresent())&#123; </span><br><span class="line">	Student result = studentOptional.get(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>orElseThrow()</strong></li>
</ul>
<blockquote>
<p>该方法与get()类似，都是用于取值，但是当Optional中没有值时，get()会直接抛出NoSuchElementException， 这样的话，就存在了一定的局限性，因为有时可能需要抛出自定义异常。此时就可以使用orElseThrow()，它在取值时，如果Optional中没有值时，可以抛出自定义异常。 </p>
</blockquote>
</li>
</ul>
<p><img src="http://mele.cool/image-20201003165624398.png" alt="image-20201003165624398"></p>
<ul>
<li><strong>map()</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (studentOptional.isPresent())&#123;</span><br><span class="line">		Optional&lt;String&gt; nameOptional = studentOptional.map(Student::getName);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>flflatMap()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student类添加Job属性 </span></span><br><span class="line"><span class="keyword">private</span> Optional&lt;Job&gt; job; </span><br><span class="line"><span class="comment">//Job类添加Company属性 </span></span><br><span class="line"><span class="keyword">private</span> Optional&lt;ComPany&gt; comPany;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>用于多层调用</strong>，同时对于结 果它不会形成多个Optional，而是将结果处理成最终的一个类型的Optional。但是通过flflatMap获取的返回值必须是Optional类型。而map则没有这个限制。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; nameOptional = studentOptional.flatMap(Student::getJob).flatMap(Job::getCompany).map(Company::getName);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>fifilter()</strong></li>
</ul>
<blockquote>
<p>会根据传入的条件进行判断，如果匹配则返回一个Optional对象并包含对应的值，否则返回一个空值的Optional </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Company&gt; company = companyOptional.filter(c ‐&gt; <span class="string">&quot;itheima&quot;</span>.equals(c.getName()));</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>orElse()</strong></li>
</ul>
<blockquote>
<p>在取值的时候，如果值不存在，有时我们会考虑返回一个默认值。该需求就可以通过orElse()实现。 其内部会判断值是否为null，如果不为null，则返回该值，如果为null，则返回传入的默认值。 </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003170351987.png" alt="image-20201003170351987"></p>
<ul>
<li><strong>orElseGet()</strong></li>
</ul>
<blockquote>
<p>orElseGet()也是用于当Optional中没有值时，返回默认值的方法。但是它与orElse()的区别在于，它是延迟加载 的。只有当Optional中没有值是才会被调用。</p>
<p><strong>在使用时，更加推荐使用orElseGet()，因为它使用延迟调用所以性能更加优异。</strong> </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003170559116.png" alt="image-20201003170559116"></p>
<h1 id="9-日期时间新方式"><a href="#9-日期时间新方式" class="headerlink" title="9.日期时间新方式"></a>9.日期时间新方式</h1><blockquote>
<p>SimpleDateFormat本身是线程不安全的，在多线程环境下，如果多个线程使用同一个类解析日期，最后的结果是 无法预期的。同时继承了它的DateFormat类也不是线程安全的。 </p>
<p><strong>DateTimeFormatter</strong> 该类是不可变和线程的。该类中提供了很多方法用于替换SimpleDateFormat。基于DateTimeFormatter改造</p>
</blockquote>
<ul>
<li><strong>LocalDate</strong>介绍 根据源码可知，该类是一个不可变，线程安全的类。其内部了提供了若干用于操作日期的方法</li>
<li><strong>LocalTime</strong>介绍 LocalTime类可以用来操作时间</li>
<li><strong>LocalDateTime</strong>介绍 LocalDateTime类可以用来操作日期+时间。</li>
</ul>
<h1 id="10-jdk11新特性"><a href="#10-jdk11新特性" class="headerlink" title="10.jdk11新特性"></a>10.jdk11新特性</h1><h2 id="1）变量类型推断"><a href="#1）变量类型推断" class="headerlink" title="1）变量类型推断"></a>1）变量类型推断</h2><p>在JS中，不管类型是什么，我们都是使用var来进行变量声明的。但是之前对于Java的使用，都会提到它是强类型语言，变量声明需要定义特定类型。但是在JDK11中对JDK8的类型推断思路又得以延伸，使用JS的方式，通过var定义局部变量，它会根据右边的表达式推断变量类型 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">&quot;hello itheima&quot;</span>; </span><br><span class="line">sout(text);</span><br></pre></td></tr></table></figure>
<h2 id="2）新增字符串方法"><a href="#2）新增字符串方法" class="headerlink" title="2）新增字符串方法"></a>2）新增字符串方法</h2><p><img src="http://mele.cool/image-20201003191743832.png" alt="image-20201003191743832"></p>
<h2 id="3）新增创建集合的方式"><a href="#3）新增创建集合的方式" class="headerlink" title="3）新增创建集合的方式"></a>3）新增创建集合的方式</h2><p>JDK11提供了通过of()和copyOf()创建集合的方式，但是创建的集合长度不可变，不能进行任何修改操作，of()会直接创建，而copyOf()首先会判断传入的集合是否为不可变集合，是的话直接返回，不是的话，调用of()创建新集合并返回。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = List.of(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;itheima&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;(); </span><br><span class="line"><span class="keyword">var</span> list2 = List.copyOf(arrayList); </span><br></pre></td></tr></table></figure>
<h2 id="4）Files类增强"><a href="#4）Files类增强" class="headerlink" title="4）Files类增强"></a>4）Files类增强</h2><p>在Files类中新增两个方法：writeString和readString。可以把String内容写入文件或者把整个文件以String读出 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Files.writeString( Path.of(<span class="string">&quot;./&quot;</span>, <span class="string">&quot;demo.txt&quot;</span>), <span class="string">&quot;hello,itheima&quot;</span>, <span class="string">&quot;utf‐8&quot;</span>); </span><br><span class="line"></span><br><span class="line">String info = Files.readString(Paths.get(<span class="string">&quot;./demo.txt&quot;</span>), <span class="string">&quot;utf‐8&quot;</span>); </span><br></pre></td></tr></table></figure>


<h2 id="5）HTTP-Client-Api"><a href="#5）HTTP-Client-Api" class="headerlink" title="5）HTTP Client Api"></a>5）HTTP Client Api</h2><p>平时我们要去访问HTTP资源，大多数时间我们都是通过第三方完成的，虽然在JDK标准类库中有HttpURLConnection，但是也不太好用。 在JDK9就提出了HTTP Client Api，经过9，10两个版本的改进，在11中正式发布。其同时支持同步请求和异步请 求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = HttpRequest.newBuilder()</span><br><span class="line">.uri(URI.create(<span class="string">&quot;http://www.itcast.cn&quot;</span>)) </span><br><span class="line">.POST() </span><br><span class="line">.build(); </span><br><span class="line"><span class="keyword">var</span> client = HttpClient.newHttpClient(); </span><br><span class="line"><span class="comment">// 同步 </span></span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response.body()); </span><br><span class="line"><span class="comment">// 异步 </span></span><br><span class="line">client.sendAsync(request, HttpResponse.BodyHandlers.ofString()) </span><br><span class="line">.thenApply(HttpResponse::body) </span><br><span class="line">.thenAccept(System.out::println);</span><br></pre></td></tr></table></figure>
<h2 id="6）更方便的编译运行"><a href="#6）更方便的编译运行" class="headerlink" title="6）更方便的编译运行"></a>6）更方便的编译运行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">之前</span> </span><br><span class="line">javac Demo.java </span><br><span class="line">java Demo </span><br><span class="line"><span class="meta">#</span><span class="bash">现在</span> </span><br><span class="line">java Demo.java </span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/02/jdk8%E4%BB%A5%E4%B8%8A%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B/" data-id="ckke5nr5h00azcl8gew6rbb6x" data-title="jdk8以上提高开发效率的新特性有哪些" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jdk8-java/" rel="tag">jdk8 - java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-多线程及调优" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%8A%E8%B0%83%E4%BC%98/" class="article-date">
  <time class="dt-published" datetime="2020-12-02T14:56:17.000Z" itemprop="datePublished">2020-12-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%8A%E8%B0%83%E4%BC%98/">多线程及调优</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-多线程-J-U-C"><a href="#1-多线程-J-U-C" class="headerlink" title="1.多线程 J.U.C"></a>1.多线程 J.U.C</h1><h2 id="1-1-线程池"><a href="#1-1-线程池" class="headerlink" title="1.1 线程池"></a>1.1 线程池</h2><h3 id="1-1-1线程的状态"><a href="#1-1-1线程的状态" class="headerlink" title="1.1.1线程的状态:"></a>1.1.1线程的状态:</h3><p><img src="http://mele.cool/image-20201003195737443.png" alt="image-20201003195737443"></p>
<ul>
<li>NEW：刚刚创建，没做任何操作 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(); </span><br><span class="line">System.out.println(thread.getState()); </span><br></pre></td></tr></table></figure>
<ul>
<li>RUNNABLE：调用run，可以执行，但不代表一定在执行（RUNNING,READY） </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread.start(); </span><br><span class="line"></span><br><span class="line">System.out.println(thread.getState());</span><br></pre></td></tr></table></figure>
<ul>
<li>BLOCKED：抢不到锁 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  		<span class="comment">//这种对象作为锁对象系统消耗最低</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] lock = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(thread1.getState());<span class="comment">//TIMED_WAITING</span></span><br><span class="line">        System.out.println(thread2.getState());<span class="comment">//BLOCKED</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>WAITING</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               LockSupport.park();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       thread2.start();</span><br><span class="line">       Thread.sleep(<span class="number">500</span>);</span><br><span class="line">       System.out.println(thread2.getState());</span><br><span class="line">       LockSupport.unpark(thread2);</span><br><span class="line">       Thread.sleep(<span class="number">500</span>);</span><br><span class="line">       System.out.println(thread2.getState());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>TIMED_WAITING</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       thread3.start();</span><br><span class="line">       Thread.sleep(<span class="number">500</span>);</span><br><span class="line">       System.out.println(thread3.getState());</span><br></pre></td></tr></table></figure>
<ul>
<li>TERMINATED</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待1s后再来看</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">System.out.println(thread.getState());</span><br></pre></td></tr></table></figure>
<h3 id="1-1-2常用线程池类结构"><a href="#1-1-2常用线程池类结构" class="headerlink" title="1.1.2常用线程池类结构"></a>1.1.2常用线程池类结构</h3><blockquote>
<p>可以通过idea查看到 （查看：<em>ScheduledThreadPoolExecutor</em>，<em>ForkJoinPool</em>类图） </p>
</blockquote>
<p><img src="http://mele.cool/image-20201003201954972.png" alt="image-20201003201954972"></p>
<ul>
<li>最常用的是ThreadPoolExecutor </li>
<li><strong>调度用ScheduledThreadPoolExecutor,完美取代Timer</strong></li>
<li>任务拆分合并用ForkJoinPool </li>
<li>Executors是工具类，协助你创建线程池的 </li>
</ul>
<h3 id="1-1-3-线程池工作机制及状态"><a href="#1-1-3-线程池工作机制及状态" class="headerlink" title="1.1.3 线程池工作机制及状态"></a>1.1.3 线程池工作机制及状态</h3><blockquote>
<p>在线程池的编程模式下，任务是提交给整个线程池，而不是直接提交给某个线程，线程池在拿到任务后，就在内部协调空闲的线程，如果有，则将任务交给某个空闲的线程。一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。 </p>
</blockquote>
<p><strong>线程池状态:</strong></p>
<p><img src="http://mele.cool/image-20201003202201492.png" alt="image-20201003202201492"></p>
<ul>
<li><p><strong>RUNNING</strong>：初始化状态是RUNNING。线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0。RUNNING状态下，能够接收新任务，以及对已添加的任务进行处理。 </p>
</li>
<li><p><strong>SHUTDOWN</strong>：SHUTDOWN状态时，<strong>不接收新任务，但能处理已添加的任务</strong>。调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN</p>
</li>
<li><p><strong>STOP</strong>：<strong>不接收新任务，不处理已添加的任务，并且会中断正在处理的任务</strong>。调用线程池的shutdownNow()接口时，线程池由(RUNNING 或 SHUTDOWN ) -&gt; STOP </p>
<p>注意：运行中的任务还会打印，直到结束，因为调的是Thread.interrupt</p>
</li>
<li><p><strong>TIDYING</strong>：<strong>所有的任务已终止</strong>，队列中的”任务数量”为0，线程池会变为TIDYING。线程池变为TIDYING状态时，会执行钩子函数terminated()，可以通过重载terminated()函数来实现自定义行为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.test;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">//源码中ThreadPoolExecutor的terminated方法是个空方法,如果需要在线程池结束时实现自己的业务逻辑,改写线程池类MyExecutorService可重写此方法.</span></span><br><span class="line"><span class="comment">//自定义类，重写terminated方法 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExecutorService</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyExecutorService</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.terminated();</span><br><span class="line">        System.out.println(<span class="string">&quot;treminated&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用 shutdownNow， ternimated方法被调用打印 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyExecutorService service = <span class="keyword">new</span> MyExecutorService(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10000</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line">        service.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>TERMINATED</strong>：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED </p>
</li>
</ul>
<h3 id="1-1-4-线程池结构"><a href="#1-1-4-线程池结构" class="headerlink" title="1.1.4 线程池结构"></a>1.1.4 线程池结构</h3><p><img src="http://mele.cool/image-20201003203016551.png" alt="image-20201003203016551"></p>
<ol>
<li>添加任务，如果线程池中线程数没达到coreSize，直接创建新线程执行 </li>
<li>达到core，放入queue </li>
<li>queue已满，未达到maxSize继续创建线程 </li>
<li>达到maxSize(最大为Integer.max)，根据reject策略处理 </li>
<li>超时后，非核心线程被释放，下降到coreSize </li>
</ol>
<p><strong>源码解析:</strong></p>
<p><img src="http://mele.cool/image-20201007101449869.png" alt="image-20201007101449869"></p>
<p>核心线程与非核心线程有区别吗?<br>答案:没有。被销毁的线程和创建的先后无关。即便是第一个被创建的核心线程,仍然有可能被销毁<br>验证:看源码,每个works在runWork的时候去getTask,在getTask内部,并没有针对性的区分当前work是否是核心线程或者类似的标记。只要判断works数量超出core,就会调用pollo),否则take()</p>
<h3 id="1-1-5-Executors工具"><a href="#1-1-5-Executors工具" class="headerlink" title="1.1.5 Executors工具"></a>1.1.5 <strong>Executors</strong>工具</h3><p>以上构造函数比较多，为了方便使用，提供了一个Executors工具类 </p>
<p><strong>实际开发建议使用上面ThreadPoolExecutor构造函数</strong></p>
<ul>
<li>1）newCachedThreadPool() ： 弹性线程数 </li>
<li>2）newFixedThreadPool(int nThreads) ： 固定线程数 </li>
<li>3）newSingleThreadExecutor() : 单一线程数 </li>
<li>4）newScheduledThreadPool(int corePoolSize) ： 可调度，常用于定时 </li>
</ul>
<h2 id="1-2-锁"><a href="#1-2-锁" class="headerlink" title="1.2 锁"></a>1.2 锁</h2><blockquote>
<p>锁是一种互斥的机制，在多线程环境中实现对资源的协调与控制，凡是有资源被多线程共享，涉及到你改我改的情况就要考虑锁的加持。 </p>
</blockquote>
<h3 id="1-2-1-锁的实现方式"><a href="#1-2-1-锁的实现方式" class="headerlink" title="1.2.1 锁的实现方式."></a>1.2.1 锁的实现方式.</h3><h4 id="1）synchronized"><a href="#1）synchronized" class="headerlink" title="1）synchronized"></a>1）synchronized</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//synchronized包裹的代码段执行完会自动释放锁,但是lock需要手动释放,所以如果使用lock时中间有try catch需要在finnaly中手动释放锁,否则会一直占用锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure>
<h4 id="2）Lock"><a href="#2）Lock" class="headerlink" title="2）Lock"></a>2）Lock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock(); </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	lock.lock(); </span><br><span class="line">	<span class="comment">//... </span></span><br><span class="line">	lock.unlock(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上两种方式性能太差.</p>
<h3 id="1-2-2-锁的分类"><a href="#1-2-2-锁的分类" class="headerlink" title="1.2.2 锁的分类"></a>1.2.2 锁的分类</h3><h4 id="1-2-2-1-乐观锁-悲观锁"><a href="#1-2-2-1-乐观锁-悲观锁" class="headerlink" title="1.2.2.1 乐观锁/悲观锁"></a>1.2.2.1 <strong>乐观锁</strong>/<strong>悲观锁</strong></h4><p>乐观锁顾名思义，很乐观的认为每次读取数据的时候总是认为没人动过，所以不去加锁。但是在更新的时候回去对比一下原来的值，看有没有被别人更改过。适用于读多写少的场景。 </p>
<blockquote>
<p><strong>mysql中类比</strong>version号更新 update xxx set a=aaa where id=xx and version=1 </p>
<p>j<strong>ava中的atomic包属于乐观锁实现，即CAS</strong>（下节会详细介绍） </p>
</blockquote>
<p>悲观锁在每次读取数据的时候都认为其他人会修改数据，所以读取数据的时候也加锁，这样别人想拿的时候就会阻塞，直到这个线程释放锁，这就影响了并发性能。适合写操作比较多的场景。 </p>
<blockquote>
<p><strong>mysql中类比</strong>for select xxx for update; update update xx set a = aaa </p>
<p>案例中synchronized实现就是悲观锁（1.6之后优化为锁升级机制），悲观锁书写不当很容易影响性能（性能部分会讲到） </p>
</blockquote>
<h4 id="1-2-2-2-独享锁-共享锁"><a href="#1-2-2-2-独享锁-共享锁" class="headerlink" title="1.2.2.2 独享锁**/**共享锁"></a>1.2.2.2 独享锁**/**共享锁</h4><p><strong>独享锁是指该锁一次只能被一个线程所持有，而共享锁是指该锁可被多个线程所持有。</strong> </p>
<p>synchronized,ReentrantLock,ReentrantReadWriteLock的writelock都是独享锁.</p>
<ul>
<li>案例一：ReentrantLock，独享锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateLock</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;read time = &quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> PrivateLock lock = <span class="keyword">new</span> PrivateLock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    lock.read();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果分析：每个线程结束的时间点逐个上升，锁被独享，一个用完下一个，依次获取锁</span></span><br></pre></td></tr></table></figure>
<ul>
<li>案例二：ReadWriteLock，read共享，write独享</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedLock</span> </span>&#123;</span><br><span class="line">    ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    Lock lock = readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end time = &quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SharedLock lock = <span class="keyword">new</span> SharedLock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    lock.read();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果分析：每个线程独自跑，各在100ms左右，证明是共享的</span></span><br></pre></td></tr></table></figure>
<ul>
<li>案例三：同样是上例，换成writeLock </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = readWriteLock.writeLock();</span><br><span class="line"><span class="comment">//结果分析：恢复到了1s时长，变为独享</span></span><br></pre></td></tr></table></figure>
<p><strong>小结:</strong></p>
<ul>
<li>读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。 </li>
<li>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。 </li>
</ul>
<h4 id="1-2-2-3分段锁"><a href="#1-2-2-3分段锁" class="headerlink" title="1.2.2.3分段锁"></a><strong>1.2.2.3</strong>分段锁</h4><blockquote>
<p>从Map一家子说起…. </p>
<p>HashMap是线程不安全的，在多线程环境下，使用HashMap进行put操作时，可能会引起死循环，导致CPU利用 率接近100%，所以在并发情况下不能使用HashMap。 </p>
<p>于是有了HashTable，HashTable是线程安全的。但是HashTable线程安全的策略实在不怎么高明，将get/put等所 有相关操作都整成了synchronized的。</p>
<p>那有没有办法做到线程安全，又不这么粗暴呢？基于分段锁的ConcurrentHashMap诞生… </p>
</blockquote>
<p><strong>ConcurrentHashMap使用Segment（分段锁）技术，将数据分成一段一段的存储</strong>，Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，<strong>Segment数组中每一个元素一把锁，每一个Segment元素存储的是HashEntry数组+链表</strong>，这个和HashMap的数据存储结构一样。当访问其中一个段数据被某个线程加锁的时候，其他段的数据也能被其他线程访问，这就使得ConcurrentHashMap<strong>不仅保证了线程安全，而且提高了性能</strong>。 </p>
<p>但是这也引来一个<strong>负面影响</strong>：<strong>ConcurrentHashMap 定位一个元素的过程需要进行两次Hash操作</strong>，第一次 Hash定位到 Segment，第二次 Hash 定位到元素所在的链表。所以 Hash 的过程比普通的 HashMap 要长。</p>
<p><strong>备注：<em>JDK1.8ConcurrentHashMap</em>中抛弃了原有的 <em>Segment</em> 分段锁，而采用了 <em>CAS + synchronized</em> 来保证并发安全性。</strong> </p>
<h4 id="1-2-2-4-可重入锁"><a href="#1-2-2-4-可重入锁" class="headerlink" title="1.2.2.4 可重入锁"></a>1.2.2.4 可重入锁</h4><p><strong>可重入锁</strong>指的获取到锁后，如果同步块内需要再次获取同一把锁的时候，直接放行，而不是等待。其意义在于防止死锁。前面使用的synchronized 和ReentrantLock 都是可重入锁。 </p>
<p><strong>实现原理</strong>是通过为每个锁关联一个请求计数器和一个占有它的线程。如果同一个线程再次请求这个锁，计数器将递增，线程退出同步块，计数器值将递减。直到计数器为0锁被释放。 </p>
<p><strong>场景</strong>见于父类和子类的锁的重入（调super方法），以及多个加锁方法的嵌套调用</p>
<p>案例一：父子可重入 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] lock = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f1 from parent&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SonLock</span> <span class="keyword">extends</span> <span class="title">ParentLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">super</span>.lock) &#123;</span><br><span class="line">            <span class="keyword">super</span>.f1();</span><br><span class="line">            System.out.println(<span class="string">&quot;f1 from son&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SonLock lock = <span class="keyword">new</span> SonLock();</span><br><span class="line">        lock.f1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>案例二：内嵌方法可重入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        f1();</span><br><span class="line">        System.out.println(<span class="string">&quot;f2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NestedLock lock = <span class="keyword">new</span> NestedLock(); <span class="comment">//可以正常打印 f1,f2 </span></span><br><span class="line">        lock.f2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>案例三：不可重入锁的典型错误，不要这么做！！！ </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadLock</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f1&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        f2();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;f2&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BadLock badLock = <span class="keyword">new</span> BadLock();</span><br><span class="line">        <span class="comment">//理论上，会打印 f1 和 f2 实际上，这个错误的设计会导致卡死在f1 </span></span><br><span class="line">        badLock.f1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义的锁，现实中不要这么做！！！ </span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//想要拿锁，一直判断标记，如果被占就wait等待 </span></span><br><span class="line">                <span class="keyword">while</span> (isLocked) &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//一旦被唤醒，退出while了，自己拿到锁，将标记改为true（已占用） </span></span><br><span class="line">            isLocked = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//占用标记改成false </span></span><br><span class="line">            isLocked = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//同时唤醒等待锁的线程 </span></span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-2-5-公平锁-非公平锁"><a href="#1-2-2-5-公平锁-非公平锁" class="headerlink" title="1.2.2.5 公平锁**/**非公平锁"></a>1.2.2.5 公平锁**/**非公平锁</h4><p>AQS既能实现公平锁,也能实现非公平锁.</p>
<p><strong>概念:</strong></p>
<p>常见于AQS，<strong>公平锁就是在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，直到按照FIFO的规则从队列中取到自己。</strong></p>
<p>非公平锁与公平锁基本类似，只是在放入队列前先判断当前锁是否被线程持有。如果锁空闲，那么他可以直接抢占，而不需要判断当前队列中是否有等待线程。只有锁被占用的话，才会进入排队。 </p>
<p><strong>优缺点：</strong> </p>
<p>公平锁的优点是等待锁的线程不会饿死，进入队列规规矩矩的排队，迟早会轮到。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。 </p>
<p>非公平锁的性能要高于公平锁，因为线程有几率不阻塞直接获得锁。ReentrantLock默认使用非公平锁就是基于性能考量。但是非公平锁的缺点是可能引发队列中的线程始终拿不到锁，一直排队被饿死。 </p>
<p><strong>编码方式：</strong> </p>
<p>很简单，ReentrantLock支持创建公平锁和非公平锁（默认），想要实现公平锁，使用new ReentrantLock(true)。 </p>
<p><strong>背后原理：</strong> </p>
<p>AQS，后面还会详细讲到。AQS中有一个state标识锁的占用情况，一个队列存储等待线程。 state=0表示锁空闲。如果是公平锁，那就看看队列有没有线程在等，有的话不参与竞争乖乖追加到尾部。如果是非公平锁，那就直接参与竞争，不管队列有没有等待者。 </p>
<p>state&gt;0表示有线程占着锁，这时候无论公平与非公平，都直接去排队（想抢也没有） </p>
<p><strong>备注：</strong> </p>
<p>因为<em>ReentrantLock</em>是可以定义公平非公平锁，次数。所以是*&gt;0<em>而不是简单的</em>0<em>和</em>1* ,而**<em>synchronized</em>只能是非公平锁 .**</p>
<h4 id="1-2-2-6-锁升级"><a href="#1-2-2-6-锁升级" class="headerlink" title="1.2.2.6 锁升级"></a>1.2.2.6 锁升级</h4><p><strong>java中每个对象都可作为锁，锁有四种级别，按照量级从轻到重分为：无锁、偏向锁、轻量级锁、重量级锁。</strong> </p>
<p>如何理解呢？A占了锁，B就要阻塞等。但是，在操作系统中，阻塞就要存储当前线程状态，唤醒就要再恢复，这个过程是要消耗时间的… </p>
<p>如果A使用锁的时间远远小于B被阻塞和挂起的执行时间，那么我们将B挂起阻塞就相当的不合算。 </p>
<p>于是出现自旋：<strong>自旋指的是锁已经被其他线程占用时，当前线程不会被挂起，而是在不停的试图获取锁（可以理解为不停的循环），每循环一次表示一次自旋过程。显然这种操作会消耗CPU时间，但是相比线程下文切换时间要少的时候，自旋划算。</strong>而偏向锁、轻量锁、重量锁就是围绕如何使得cpu的占用更划算而展开的。</p>
<blockquote>
<p>举个生活的例子，假设公司只有一个会议室（共享资源） </p>
<p><strong>偏向锁：</strong> 前期公司只有1个团队，那么什么时候开会都能满足，就不需要询问和查看会议室的占用情况，直接进入使用状态。会议室门口挂了个牌子写着A使用，A默认不需要预约（ThreadID=A） </p>
<p><strong>轻量级锁：</strong> 随着业务发展，扩充为2个团队，B团队肯定不会同意A无法无天，于是当AB同时需要开会时，两者竞争，谁抢到谁算谁的。偏向锁升级为轻量级锁，但是未抢到者在门口会不停敲门询问（自旋，循环），开完没有？开完没有？ </p>
<p><strong>重量级锁：</strong> 后来发现，这种不停敲门的方式很烦，A可能不理不睬，但是B要不停的闹腾。于是锁再次升级。如果会议室被A占用，那么B团队直接闭嘴，在门口安静的等待（wait进入阻塞），直到A用完后会通知B（notify）。</p>
</blockquote>
<p>注意点：</p>
<ul>
<li>上面几种锁都是JVM自己内部实现，我们不需要干预，但是可以配置jvm参数开启/关闭自旋锁、偏向锁。 </li>
<li>锁可以升级，但是不能反向降级：偏向锁→轻量级锁→重量级锁 </li>
<li>无锁争用的时候使用偏向锁，第二个线程到了升级为轻量级锁进行竞争，更多线程时，进入重量级锁阻塞</li>
</ul>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>若线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>只有一个线程访问同步块或者同步方法</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞,提高了程序的响应速度</td>
<td>若线程长时间竞争不到锁,自旋会消耗CPU性能</td>
<td>线程交替执行同步块或者同步方法,追求响应时间,锁占用时间很短,阻塞还不如自旋的场景</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋,不会消耗CPU</td>
<td>线程阻塞,响应时间缓慢,在多线程下,频繁的获取释放锁,会带来巨大的性能消耗</td>
<td>追求吞吐量,锁占用时间较长</td>
</tr>
</tbody></table>
<h4 id="1-2-2-7互斥锁-读写锁"><a href="#1-2-2-7互斥锁-读写锁" class="headerlink" title="1.2.2.7互斥锁**/**读写锁"></a>1.2.2.7互斥锁**/**读写锁</h4><ul>
<li>典型的互斥锁：synchronized，ReentrantLock，读写锁：ReadWriteLock 前面都用过了 </li>
<li>互斥锁属于独享锁，读写锁里的写锁属于独享锁，而读锁属于共享锁 </li>
</ul>
<p>案例:互斥锁用不好可能失效,看一个典型的锁不住现象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//重点！把锁的new操作放在外面才能锁住.</span></span><br><span class="line">                    <span class="keyword">new</span> ObjectLock().inc();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="comment">//理论上10才对。可是.... </span></span><br><span class="line">        System.out.println(ObjectLock.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果分析：每个线程内都是new对象，所以this不是同一把锁，结果锁不住，输出1 </p>
<ul>
<li>this，换成static的 i 变量试试？ </li>
<li>换成ObjectLock.class 试试？ </li>
<li>换成String.class </li>
<li>去掉synchronized块，外部方法上加 static synchronized </li>
<li>以上都能得到10</li>
</ul>
<h3 id="1-2-3-AQS"><a href="#1-2-3-AQS" class="headerlink" title="1.2.3 AQS"></a>1.2.3 AQS</h3><p>关于信号量:<a target="_blank" rel="noopener" href="https://blog.csdn.net/J080624/article/details/85625350">https://blog.csdn.net/J080624/article/details/85625350</a></p>
<p>概念:</p>
<p>首先搞清楚，<strong>AbstractQuenedSynchronizer抽象的队列式同步器，是一个抽象类</strong>，这个类在 java.util.concurrent.locks包。除了java自带的synchronized关键字之外，jdk提供的另外一种锁机制。如果需要<strong>自己实现锁的逻辑，可以考虑使用AQS</strong>，非常的便捷。 </p>
<p><img src="http://mele.cool/image-20201007213811599.png" alt="image-20201007213811599"></p>
<p> <strong>场景案例</strong> </p>
<p>用AQS自己实现一个锁，最大允许指定数量的线程并行运作。其他排队等候</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLock</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> newCount = current ‐arg;</span><br><span class="line">            <span class="keyword">if</span> (newCount &lt; <span class="number">0</span> || compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                <span class="keyword">return</span> newCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> newState = current + arg;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, newState)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MyLock lock = <span class="keyword">new</span> MyLock(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    lock.acquireShared(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">1000</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock.releaseShared(<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证结果：虽然30个一次性start，但是会每1s输出3个ok，达到了并发控制 </p>
<h2 id="1-3-原子操作"><a href="#1-3-原子操作" class="headerlink" title="1.3 原子操作"></a>1.3 原子操作</h2><p><strong>概念:</strong></p>
<p>原子（atom）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。类比于数据库事务，redis的multi。 </p>
<p><strong>CAS:</strong></p>
<p>Compare And Set（或Compare And Swap），翻译过来就是比较并替换，CAS操作包含三个操作数——内存位置（V）、预期原值（A）、新值(B)。从第一视角来看，理解为：我认为位置 V 应该是 A，如果是A，则将 B 放到这个位置；否则，不要更改，只告诉我这个位置现在的值即可。 </p>
<p>计数器问题发生归根结底是取值和运算后的赋值中间，发生了插队现象，他们不是原子的操作。前面的计数器使用加锁方式实现了正确计数，下面，基于CAS的原子类上场…. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        i.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AtomicCounter counter = <span class="keyword">new</span> AtomicCounter();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    counter.inc();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">//同样可以正确输出10 </span></span><br><span class="line">        System.out.println(counter.i.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面展示了AtomicInteger,关于atomic包,还有很多其他类型:</p>
<p><strong>基本类型</strong></p>
<ul>
<li>AtomicBoolean:以原子更新的方式更新boolean</li>
<li>AtomicInteger:以原子更新的方式更新Integer;</li>
<li>AtomicLong:以原子更新的方式更新Long;</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li> AtomicReference:原子更新引用类型</li>
<li>AtomicReferenceFieldUpdater :原子更新引用类型的字段</li>
<li>AtomicMarkableReference :原子更新带有标志位的引用类型</li>
</ul>
<p><strong>数组</strong></p>
<ul>
<li>AtomicintegerArray:原子更新整型数组里的元素。</li>
<li>AtomicLongArray:原子更新长整型数组里的元素。</li>
<li>AtomicReferenceArray:原子更新引用类型数组里的元素。</li>
</ul>
<p><strong>字段</strong></p>
<ul>
<li>AtomicIntegerFieldUpdater:原子更新整型的字段的更新器。</li>
<li>AtomicLongFieldUpdater:原子更新长整型字段的更新器。</li>
<li>AtomicStampedReference:原子更新带有版本号的引用类型。</li>
</ul>
<p><strong>使用atomic要注意原子性的边界，把握不好会起不到应有的效果，原子性被破坏。</strong> </p>
<p><strong>案例：原子性被破坏现象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadAtomic</span> </span>&#123;</span><br><span class="line">    AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">badInc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = i.incrementAndGet();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        j = k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BadAtomic atomic = <span class="keyword">new</span> BadAtomic();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()‐ &gt; &#123;atomic.badInc(); &#125;).start();</span><br><span class="line">        &#125; Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(atomic.j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果分析： </p>
<p>每次都不一样，总之不是10 </p>
<p>原因:多线程下,赋值给k没问题,k肯定是递增的,但是在j=k这一步之前的耗时操作,可能被别的线程插队,导致给j赋值的结果改变.</p>
<p>在badInc上加synchronized，问题解决 </p>
</blockquote>
<h2 id="1-4-threadLocal"><a href="#1-4-threadLocal" class="headerlink" title="1.4 threadLocal"></a>1.4 threadLocal</h2><p> 概念 </p>
<p>ThreadLocal类并不是用来解决多线程环境下的共享变量问题，而是用来提供线程内部的共享变量。在多线程环境下，可以保证各个线程之间的变量互相隔离、相互独立。 </p>
<p> 使用 </p>
<p>ThreadLocal实例一般定义为private static类型的，在一个线程内，该变量共享一份，类似上下文作用，可以用来上下传递信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            threadLocal.set(i);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;,value=&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocalDemo demo = <span class="keyword">new</span> ThreadLocalDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(demo).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(demo).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>应用场景</strong> </p>
<ul>
<li>数据库连接，session管理 </li>
<li>下面的基于日志平台的访问链路追踪中，会用到 </li>
</ul>
<p>注意！ </p>
<p>ThreadLocal如果指向了同一个引用，会打破隔离而失效。 </p>
<p>案例：隔离失败了！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadLocal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal&lt;Map&gt; local = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">new</span> Thread(()‐ &gt; &#123;</span><br><span class="line">                <span class="comment">//在线程设置后，过段时间取name </span></span><br><span class="line">                <span class="comment">// 猜一猜结果？ </span></span><br><span class="line">                map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;i am &quot;</span> + Thread.currentThread().getName()); local.set(map);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + local.get().get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">//do something... </span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + local.get().get(<span class="string">&quot;name&quot;</span>)); &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()‐ &gt; &#123;</span><br><span class="line">                <span class="comment">// 在线程中赋值name</span></span><br><span class="line">                map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;i am &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        local.set(map); &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="1-5-Fork-Join"><a href="#1-5-Fork-Join" class="headerlink" title="1.5 Fork/Join"></a>1.5 Fork/Join</h2><p><strong>概念</strong> </p>
<p>ForkJoin是由JDK1.7后提供多线并发处理框架。ForkJoinPool由Java大师Doug Lea主持编写，处理逻辑大概分为两步。</p>
<p>1.任务分割：Fork（分岔），先把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割。</p>
<p>2.合并结果：join，分割后的子任务被多个线程执行后，再合并结果，得到最终的完整输出。 </p>
<p><strong>组成</strong> </p>
<ul>
<li><strong>ForkJoinTask</strong>：主要提供fork和join两个方法用于任务拆分与合并；多数使用RecursiveAction（无返回值的任务）和RecursiveTask（需要返回值）来实现compute方法</li>
<li><strong>ForkJoinPool</strong>：调度ForkJoinTask的线程池； </li>
<li><strong>ForkJoinWorkerThread</strong>：Thread的子类，存放于线程池中的工作线程（Worker）； </li>
<li><strong>WorkQueue</strong>：任务队列，用于保存任务； </li>
</ul>
<p><strong>基本使用</strong> </p>
<p>一个典型的例子：计算1-1000的和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer MAX = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SubTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 子任务开始计算的值 </span></span><br><span class="line">        <span class="keyword">private</span> Integer start;</span><br><span class="line">        <span class="comment">// 子任务结束计算的值</span></span><br><span class="line">        <span class="keyword">private</span> Integer end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SubTask</span><span class="params">(Integer start, Integer end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (end ‐start&lt;MAX)&#123;</span><br><span class="line">                <span class="comment">//小于边界，开始计算 </span></span><br><span class="line">                System.out.println(<span class="string">&quot;start = &quot;</span> + start + <span class="string">&quot;;end = &quot;</span> + end);</span><br><span class="line">                Integer totalValue = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="keyword">this</span>.start; index &lt;= <span class="keyword">this</span>.end; index++) &#123;</span><br><span class="line">                    totalValue += index;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> totalValue;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//否则，中间劈开继续拆分 </span></span><br><span class="line">                SubTask subTask1 = <span class="keyword">new</span> SubTask(start, (start + end) / <span class="number">2</span>);</span><br><span class="line">                subTask1.fork();</span><br><span class="line">                SubTask subTask2 = <span class="keyword">new</span> SubTask((start + end) / <span class="number">2</span> + <span class="number">1</span>, end);</span><br><span class="line">                subTask2.fork();</span><br><span class="line">                <span class="keyword">return</span> subTask1.join() + subTask2.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        Future&lt;Integer&gt; taskFuture = pool.submit(<span class="keyword">new</span> SubTask(<span class="number">1</span>, <span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer result = taskFuture.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace(System.out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>设计思想</strong> </p>
<ul>
<li>普通线程池内部有两个重要集合：工作线程集合，和任务队列。 </li>
<li>ForkJoinPool也类似，工作集合里放的是特殊线程ForkJoinWorkerThread，任务队列里放的是特殊任务ForkJoinTask </li>
<li>不同之处在于，普通线程池只有一个队列。而ForkJoinPool的工作线程ForkJoinWorkerThread每个线程内都绑定一个双端队列。<img src="http://mele.cool/image-20201006215021466.png" alt="image-20201006215021466"></li>
<li>在fork的时候，也就是任务拆分，将拆分的task会被当前线程放到自己的队列中。 </li>
<li>队列中的任务被线程执行时，有两种模式，默认是同步模式（asyncMode==false）从队尾取任务（LIFO） </li>
<li>窃取：当自己队列中执行完后，工作线程会到其他队列的队首获取任务（FIFO），取到后如果任务再次fork，拆分会被放入当前线程的队列，依次扩张 </li>
</ul>
<p><strong>注意点</strong> </p>
<p>使用ForkJoin将相同的计算任务通过多线程执行。但是在使用中需要注意： </p>
<ul>
<li>注意任务切分的粒度，也就是fork的界限。并非越小越好 </li>
<li>判断要不要使用ForkJoin。任务量不是太大的话，串行可能优于并行。因为多线程会涉及到上下文的切换</li>
</ul>
<h2 id="1-6-Volatile"><a href="#1-6-Volatile" class="headerlink" title="1.6 Volatile"></a>1.6 Volatile</h2><p><strong>基本概念</strong> </p>
<p>回顾Java 内存模型中的可见性、原子性和有序性： </p>
<ul>
<li>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的 </li>
<li>原子性，指的是这个操作是原子不可拆分的，不允许别的线程中间插队操作 </li>
<li>有序性指的是你写的代码的顺序要和最终执行的指令保持一致。因为在Java内存模型中，允许编译器和处理器 </li>
</ul>
<p>对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 volatile要解决的就是可见性和有序性问题。 </p>
<p><strong>使用方式</strong> </p>
<p>先看一个经典案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag) ;</span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> VolatileTest().start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>给flag加上 volatile再试试…… </p>
</blockquote>
<p><strong>原理:</strong></p>
<p>Java内存模型分为主内存和线程工作内存两大类。 </p>
<ul>
<li>主内存：多个线程共享的内存。方法区和堆属于主内存区域。 </li>
<li>线程工作内存：每个线程独享的内存。虚拟机栈、本地方法栈、程序计数器属于线程独享的工作内存。 <img src="http://mele.cool/image-20201006220038412.png" alt="image-20201006220038412"></li>
</ul>
<p>Java内存模型规定，所有变量都需要存储在主内存中，线程需要时，在自己的工作内存保存变量的副本，线程对变量的所有操作都在工作内存中进行，执行结束后再同步到主内存中去。这里必然会存在时间差，在这个时间差内，该线程对副本的操作，对于其他线程是不见的，从而造成了可见性问题。 </p>
<p>但是，当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。</p>
<p>同时，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议。每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期，一旦发现过期就会将当前处理器的缓存行设置成无效状态，强制从主内存读取，这就保障了可见性。 </p>
<p><strong>而volatile变量，通过内存屏障（JMM课程）可以禁止指令重排。从而实现指令的有序性。</strong> </p>
<p><strong>注意！</strong> </p>
<p><strong>volatile不能保证锁的原子性。</strong> </p>
<p>案例：给前面的计数器案例里加上volatile试试 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadVolatile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        i = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> BadVolatile counter = <span class="keyword">new</span> BadVolatile();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    counter.inc();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="comment">//理论上10才对。可是.... </span></span><br><span class="line">        System.out.println(counter.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//达不到目的。说明原子性无法保障。</span></span><br></pre></td></tr></table></figure>


<h2 id="1-7-ConcurrentHashMap"><a href="#1-7-ConcurrentHashMap" class="headerlink" title="1.7 ConcurrentHashMap"></a>1.7 ConcurrentHashMap</h2><p>使用:</p>
<p>new创建即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">//定义ConcurrentHashMap</span></span><br><span class="line">        Map map=<span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//多线程下的put可以放心使用 </span></span><br><span class="line">                map.put(UUID.randomUUID().toString(),<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 实现原理 </p>
<p>1.7是分段锁，上面阐述过，1.8采用的是cas + synchronized 操作，具体看代码：</p>
<p><img src="http://mele.cool/image-20201006221032679.png" alt="image-20201006221032679"></p>
<p><strong>注意！</strong> </p>
<p>注意正确理解ConcurrentHashMap线程安全这个问题。看一个典型案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadConcurrent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line">        map.put(<span class="string">&quot;val&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">int</span> v = map.get(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">                v++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(<span class="string">&quot;val&quot;</span>, v);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(map);<span class="comment">//&#123;val=1&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="1-8-并发容器"><a href="#1-8-并发容器" class="headerlink" title="1.8 并发容器"></a>1.8 并发容器</h2><p>java中的集合类非常丰富（ArrayList，HashMap之类），在单线程下用的顺风顺水，但这些集合类都是非线程安全的，即在多线程的环境下，都需要其他额外的手段来保证数据的正确性。常见手段有两种： </p>
<ul>
<li>自己通过synchronized关键字将所有使用到非线程安全的容器代码全部同步执行 </li>
<li>Vector、Stack、HashTable、Collections.synchronized等同步容器法，在早期的jdk中用的比较多，实现方 式和上面几乎一样，而且多步操作时如果外面不额外加一层synchronized，依然锁不住。实际效果还不如上面</li>
</ul>
<p><strong>并发容器清单:</strong></p>
<p><strong>1.ConcurrentHashMap</strong> </p>
<p>对应：HashMap目标：代替Hashtable、synchronizedMap，使用最多，前面详细介绍过 </p>
<p>原理：JDK7中采用Segment分段锁，JDK8中采用CAS+synchronized </p>
<p><strong>2.CopyOnWriteArrayList</strong> </p>
<p>对应：ArrayList </p>
<p>目标：代替Vector、synchronizedList </p>
<p>原理：高并发往往是读多写少的特性，读操作不加锁，而对写操作加Lock独享锁，先复制一份新的集合，在新的集合上面修改，然后将新集合赋值给旧的引用，并通过volatile 保证其可见性。 </p>
<p>查看源码：<em>volatile array</em>，<em>lock</em>加锁，数组复制 </p>
<p><strong>3.CopyOnWriteArraySet</strong> </p>
<p>对应：HashSet </p>
<p>目标：代替synchronizedSet </p>
<p>原理：与CopyOnWriteArrayList实现原理类似。 </p>
<p><strong>4.ConcurrentSkipListMap</strong> </p>
<p>对应：TreeMap </p>
<p>目标：代替synchronizedSortedMap(TreeMap) </p>
<p>原理：基于Skip list（跳表）来代替平衡树，按照分层key上下链接指针来实现。 </p>
<p>附加：跳表 </p>
<p><strong>5.ConcurrentSkipListSet</strong> </p>
<p>对应：TreeSet </p>
<p>目标：代替synchronizedSortedSet(TreeSet) </p>
<p>原理：内部基于ConcurrentSkipListMap实现，原理一致 </p>
<p><strong>6.ConcurrentLinkedQueue</strong> </p>
<p>对应：LinkedList </p>
<p>对应：无界线程安全队列 </p>
<p>原理：通过队首队尾指针，以及Node类元素的next实现FIFO队列</p>
<p><strong>7.BlockingQueue</strong> </p>
<p>对应：Queue </p>
<p>特点：拓展了Queue，增加了可阻塞的插入和获取等操作 </p>
<p>原理：通过ReentrantLock实现线程安全，通过Condition实现阻塞和唤醒 </p>
<p>实现类：</p>
<ul>
<li>LinkedBlockingQueue：基于链表实现的可阻塞的FIFO队列 </li>
<li>ArrayBlockingQueue：基于数组实现的可阻塞的FIFO队列 </li>
<li>PriorityBlockingQueue：按优先级排序的队列 </li>
</ul>
<h1 id="2-性能调优"><a href="#2-性能调优" class="headerlink" title="2.性能调优"></a>2.性能调优</h1><h2 id="2-1锁优化"><a href="#2-1锁优化" class="headerlink" title="2.1锁优化"></a>2.1锁优化</h2><h3 id="Synchronized优化"><a href="#Synchronized优化" class="headerlink" title="Synchronized优化"></a><strong>Synchronized</strong>优化</h3><p>synchronized使用起来非常简单，但是需要注意的是synchronized加锁的是什么维度</p>
<p>对象级别： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO </span></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>类级别: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (TestSynchronized.class) &#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO </span></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>案例：看一个加锁粒度的案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadSync</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        inc();</span><br><span class="line">        atomicLong.getAndAdd(System.currentTimeMillis() ‐ start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BadSync sync = <span class="keyword">new</span> BadSync();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(sync).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;最终计数：i=&quot;</span> + sync.i);</span><br><span class="line">        System.out.println(<span class="string">&quot;最终耗时：time=&quot;</span> + sync.atomicLong.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下最后的结果和耗时 </p>
<ul>
<li>将synchronized换到inc方法上，再试试最后的结果和耗时 </li>
<li>结论是什么？ </li>
</ul>
<h3 id="Lock锁优化"><a href="#Lock锁优化" class="headerlink" title="Lock锁优化"></a><strong>Lock</strong>锁优化</h3><p>看一个小需求：电商系统中记录首页被用户浏览的次数，以及最后一次操作的时间（含读或写）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TotalLock</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">//类创建的时间 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//总耗时 </span></span><br><span class="line"></span><br><span class="line">AtomicLong totalTime = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存变量 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String,Long&gt; map = <span class="keyword">new</span> HashMap()&#123;&#123;put(<span class="string">&quot;count&quot;</span>,<span class="number">0L</span>);&#125;&#125;; </span><br><span class="line"></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//查看map被写入了多少次 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map <span class="title">read</span><span class="params">()</span></span>&#123; </span><br><span class="line"></span><br><span class="line">lock.lock(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">Thread.currentThread().sleep(<span class="number">100</span>); </span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line"></span><br><span class="line">e.printStackTrace(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//最后操作完成的时间 </span></span><br><span class="line"></span><br><span class="line">map.put(<span class="string">&quot;time&quot;</span>,end); </span><br><span class="line"></span><br><span class="line">lock.unlock(); </span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;,read=&quot;</span>+(end‐start)); </span><br><span class="line"></span><br><span class="line">totalTime.addAndGet(end ‐ start); </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> map; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map <span class="title">write</span><span class="params">()</span></span>&#123; </span><br><span class="line"></span><br><span class="line">lock.lock(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">Thread.currentThread().sleep(<span class="number">100</span>); </span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line"></span><br><span class="line">e.printStackTrace(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入计数 </span></span><br><span class="line"></span><br><span class="line">map.put(<span class="string">&quot;count&quot;</span>,map.get(<span class="string">&quot;count&quot;</span>)+<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis(); </span><br><span class="line"></span><br><span class="line">map.put(<span class="string">&quot;time&quot;</span>,end); </span><br><span class="line"></span><br><span class="line">lock.unlock(); </span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;,write=&quot;</span>+(end‐start)); </span><br><span class="line"></span><br><span class="line">totalTime.addAndGet(end ‐ start); </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> map; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;TotalLock count = <span class="keyword">new</span> TotalLock(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//读</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()‐&gt;&#123; </span><br><span class="line"></span><br><span class="line">count.read(); </span><br><span class="line"></span><br><span class="line">&#125;).start(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()‐&gt;&#123; </span><br><span class="line"></span><br><span class="line">count.write(); </span><br><span class="line"></span><br><span class="line">&#125;).start(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">3000</span>); </span><br><span class="line"></span><br><span class="line">System.out.println(count.map); </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;读写总共耗时：&quot;</span>+count.totalTime.get()); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>仔细看读的时间变化和执行的总时间，思考一下，从业务和技术角度有没有可优化空间？ </p>
<p>仔细分析业务：查看次数这里其实是可以并行读取的，我们关注的业务是写入次数，也就是count，至于读取发生 的时间time的写入操作，只是一个单步put，每次覆盖，不需要原子性保障，对这个加互斥锁没有必要。 改成读写锁试试……</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadAndWrite</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">//类创建的时间 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//总耗时 </span></span><br><span class="line"></span><br><span class="line">AtomicLong totalTime = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存变量，注意！因为read并发，这里换成ConcurrentHashMap </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String,Long&gt; map = <span class="keyword">new</span> ConcurrentHashMap()&#123;&#123;put(<span class="string">&quot;count&quot;</span>,<span class="number">0L</span>);&#125;&#125;; </span><br><span class="line"></span><br><span class="line">ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//查看map被写入了多少次 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map <span class="title">read</span><span class="params">()</span></span>&#123; </span><br><span class="line"></span><br><span class="line">lock.readLock().lock(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">Thread.currentThread().sleep(<span class="number">100</span>); </span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line"></span><br><span class="line">e.printStackTrace(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//最后操作完成的时间 </span></span><br><span class="line"></span><br><span class="line">map.put(<span class="string">&quot;time&quot;</span>,end); </span><br><span class="line"></span><br><span class="line">lock.readLock().unlock(); </span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;,read=&quot;</span>+(end‐start)); </span><br><span class="line"></span><br><span class="line">totalTime.addAndGet(end ‐ start); </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> map; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map <span class="title">write</span><span class="params">()</span></span>&#123; </span><br><span class="line"></span><br><span class="line">lock.writeLock().lock(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">Thread.currentThread().sleep(<span class="number">100</span>); </span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line"></span><br><span class="line">e.printStackTrace(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入计数 </span></span><br><span class="line"></span><br><span class="line">map.put(<span class="string">&quot;count&quot;</span>,map.get(<span class="string">&quot;count&quot;</span>)+<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis(); </span><br><span class="line"></span><br><span class="line">map.put(<span class="string">&quot;time&quot;</span>,end); </span><br><span class="line"></span><br><span class="line">lock.writeLock().unlock(); </span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;,write=&quot;</span>+(end‐start)); </span><br><span class="line"></span><br><span class="line">totalTime.addAndGet(end ‐ start); </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> map; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;ReadAndWrite rw = <span class="keyword">new</span> ReadAndWrite(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//读</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()‐&gt;&#123; </span><br><span class="line"></span><br><span class="line">rw.read(); </span><br><span class="line"></span><br><span class="line">&#125;).start(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()‐&gt;&#123; </span><br><span class="line"></span><br><span class="line">rw.write(); </span><br><span class="line"></span><br><span class="line">&#125;).start(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">3000</span>); </span><br><span class="line"></span><br><span class="line">System.out.println(rw.map); </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;读写总共耗时：&quot;</span>+rw.totalTime.get()); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>再来看读的时间变化和总执行时间。 </p>
<p>当read远大于write时，这个差距会更明显 （改成<em>9:1</em>试试<em>……</em>） </p>
<h3 id="CAS乐观锁优化"><a href="#CAS乐观锁优化" class="headerlink" title="CAS乐观锁优化"></a><strong>CAS</strong>乐观锁优化</h3><p>回顾上面的计数器，我们用synchronized实现了准确计数，本节我们看执行时间，追究性能问题。 </p>
<p>案例一：直接加synchronized锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalSync</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123; </span><br><span class="line"></span><br><span class="line">Long start = System.currentTimeMillis(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = i; </span><br><span class="line"></span><br><span class="line"><span class="comment">//实际业务中可能会有一堆的耗时操作，这里等待100ms模拟 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//做一系列操作 </span></span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">100</span>); </span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line"></span><br><span class="line">e.printStackTrace(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务结束后，增加计数 </span></span><br><span class="line"></span><br><span class="line">i = j+<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getId()+ </span><br><span class="line"></span><br><span class="line"><span class="string">&quot; ok,time=&quot;</span>+(System.currentTimeMillis() ‐ start)); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line"></span><br><span class="line">NormalSync test = <span class="keyword">new</span> NormalSync(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(test).start(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(test).start(); </span><br><span class="line"></span><br><span class="line">Thread.currentThread().sleep(<span class="number">1000</span>); </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;last value=&quot;</span>+test.i); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>线程二最终耗时会在200ms+，总耗时300ms，原因是悲观锁卡在了read后的耗时操作上，但是保证了最终结果是2</p>
<p>案例二：基于CAS思想，compare再set</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Unsafe; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CasSync</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = i; </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">100</span>); </span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line"></span><br><span class="line">e.printStackTrace(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CAS处理，在这里理解思想，实际中不推荐大家使用！ </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">Field f = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>); </span><br><span class="line"></span><br><span class="line">f.setAccessible(<span class="keyword">true</span>); </span><br><span class="line"></span><br><span class="line">Unsafe unsafe = (Unsafe) f.get(<span class="keyword">null</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> offset = unsafe.objectFieldOffset(CasSync.class.getDeclaredField(<span class="string">&quot;i&quot;</span>)); </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!unsafe.compareAndSwapInt(<span class="keyword">this</span>,offset,j,j+<span class="number">1</span>))&#123; </span><br><span class="line"></span><br><span class="line">j = i; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line"></span><br><span class="line">e.printStackTrace(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际开发中，要用atomic包，或者while+synchronized自旋 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// synchronized (this)&#123; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// //注意这里！ </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// while (j != i)&#123; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// j = i; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// i = j+1; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName()+ </span><br><span class="line"></span><br><span class="line"><span class="string">&quot; ok,time=&quot;</span>+(System.currentTimeMillis() ‐ start)); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line"></span><br><span class="line">CasSync test = <span class="keyword">new</span> CasSync(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(test).start(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(test).start(); </span><br><span class="line"></span><br><span class="line">Thread.currentThread().sleep(<span class="number">1000</span>); </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;last value=&quot;</span>+test.i); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程一、二均在100ms+，总耗时200ms，最终结果还是2 </p>
<p><strong>一些经验</strong> </p>
<ul>
<li>减少锁的时间 </li>
</ul>
<p>不需要同步执行的代码，能不放在同步快里面执行就不要放在同步快内，可以让锁尽快释放 </p>
<ul>
<li>减少锁的粒度 </li>
</ul>
<p>将物理上的一个锁，拆成逻辑上的多个锁，增加并行度，从而降低锁竞争，典型如分段锁 </p>
<ul>
<li>锁的粒度 </li>
</ul>
<p>拆锁的粒度不能无限拆，最多可以将一个锁拆为当前cup数量相等 </p>
<ul>
<li>减少加减锁的次数 </li>
</ul>
<p>假如有一个循环，循环内的操作需要加锁，我们应该把锁放到循环外面，否则每次进出循环，都要加锁 </p>
<ul>
<li>使用读写锁 </li>
</ul>
<p>业务细分，读操作加读锁，可以并发读，写操作使用写锁，只能单线程写，参考计数器案例 </p>
<ul>
<li>善用volatile </li>
</ul>
<p>volatile的控制比synchronized更轻量化，在某些变量上可以加以运用，如单例模式中 </p>
<h2 id="2-2-线程池参数调优"><a href="#2-2-线程池参数调优" class="headerlink" title="2.2 线程池参数调优"></a>2.2 线程池参数调优</h2><h2 id="2-3-协程"><a href="#2-3-协程" class="headerlink" title="2.3 协程"></a>2.3 协程</h2><h2 id="2-4-并发容器选择"><a href="#2-4-并发容器选择" class="headerlink" title="2.4 并发容器选择"></a>2.4 并发容器选择</h2><h2 id="2-5-上下文切换优化"><a href="#2-5-上下文切换优化" class="headerlink" title="2.5 上下文切换优化"></a>2.5 上下文切换优化</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%8A%E8%B0%83%E4%BC%98/" data-id="ckke5nr5i00b3cl8g9rra4ga0" data-title="多线程及调优" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-java/" rel="tag">多线程 - java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/02/hello-world/" class="article-date">
  <time class="dt-published" datetime="2020-12-02T14:50:51.843Z" itemprop="datePublished">2020-12-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hello-world/">hello world</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/02/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/02/hello-world/" data-id="ckke5nr35000wcl8gcwfxbphn" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%A5%E9%97%A8/" rel="tag">入门</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/bug/">bug</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/db/">db</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hello-world/">hello world</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mele/">mele</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mq/">mq</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/springCloud/">springCloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/springboot/">springboot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/">工具类</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/">版本控制</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/acid/" rel="tag">acid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aop/" rel="tag">aop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/baby/" rel="tag">baby</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bug/" rel="tag">bug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/" rel="tag">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/excel/" rel="tag">excel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/executors/" rel="tag">executors</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/explain/" rel="tag">explain</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/filter/" rel="tag">filter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/freemarker/" rel="tag">freemarker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/" rel="tag">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/httpServerletRequest/" rel="tag">httpServerletRequest</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/httpclient/" rel="tag">httpclient</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/idea/" rel="tag">idea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interceptor/" rel="tag">interceptor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ioc/" rel="tag">ioc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ip/" rel="tag">ip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%9F%BA%E7%A1%80/" rel="tag">java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdbcTemplate/" rel="tag">jdbcTemplate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdk8-java/" rel="tag">jdk8 - java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/" rel="tag">mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/" rel="tag">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/md/" rel="tag">md</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mele/" rel="tag">mele</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mq/" rel="tag">mq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ms/" rel="tag">ms</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oracle/" rel="tag">oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pagehelper-%E5%88%86%E9%A1%B5/" rel="tag">pagehelper - 分页</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/photo/" rel="tag">photo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rabbitmq-mq/" rel="tag">rabbitmq - mq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis-db/" rel="tag">redis - db</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springApplication/" rel="tag">springApplication</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springCloud/" rel="tag">springCloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/" rel="tag">springboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql%E4%BC%98%E5%8C%96/" rel="tag">sql优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stream/" rel="tag">stream</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/struts2/" rel="tag">struts2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/threadPollExecutor/" rel="tag">threadPollExecutor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thymeleaf/" rel="tag">thymeleaf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/" rel="tag">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/" rel="tag">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/war/" rel="tag">war</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webservice/" rel="tag">webservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/word/" rel="tag">word</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xml/" rel="tag">xml</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%BB%E9%94%AE/" rel="tag">主键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81/" rel="tag">代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%A5%E5%8F%A3%E7%B1%BB/" rel="tag">入口类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%A5%E9%97%A8/" rel="tag">入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%AC%E9%92%A5/" rel="tag">公钥</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E9%A1%B5/" rel="tag">分页</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" rel="tag">单元测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E7%90%86/" rel="tag">原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%91%BD%E4%BB%A4/" rel="tag">命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-java/" rel="tag">多线程 - java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%BC%E5%87%BA/" rel="tag">导出</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/" rel="tag">工具类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%B8%E7%94%A8/" rel="tag">常用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E5%B8%B8/" rel="tag">异常</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/" rel="tag">异步调用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/" rel="tag">拦截器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97/" rel="tag">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E6%9D%BF/" rel="tag">模板</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E8%A7%A3/" rel="tag">注解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A/" rel="tag">注释</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/" rel="tag">热部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9B%91%E6%8E%A7/" rel="tag">监控</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/" rel="tag">箭头函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag">线程池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/" rel="tag">自动装配</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/" rel="tag">过滤器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%82%AE%E4%BB%B6/" rel="tag">邮件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E5%90%88/" rel="tag">集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/" rel="tag">雪花算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/acid/" style="font-size: 11.67px;">acid</a> <a href="/tags/aop/" style="font-size: 10px;">aop</a> <a href="/tags/baby/" style="font-size: 10px;">baby</a> <a href="/tags/bug/" style="font-size: 11.67px;">bug</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/dubbo/" style="font-size: 10px;">dubbo</a> <a href="/tags/excel/" style="font-size: 10px;">excel</a> <a href="/tags/executors/" style="font-size: 10px;">executors</a> <a href="/tags/explain/" style="font-size: 10px;">explain</a> <a href="/tags/filter/" style="font-size: 10px;">filter</a> <a href="/tags/freemarker/" style="font-size: 10px;">freemarker</a> <a href="/tags/git/" style="font-size: 13.33px;">git</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/httpServerletRequest/" style="font-size: 10px;">httpServerletRequest</a> <a href="/tags/httpclient/" style="font-size: 10px;">httpclient</a> <a href="/tags/idea/" style="font-size: 10px;">idea</a> <a href="/tags/interceptor/" style="font-size: 10px;">interceptor</a> <a href="/tags/ioc/" style="font-size: 10px;">ioc</a> <a href="/tags/ip/" style="font-size: 10px;">ip</a> <a href="/tags/java/" style="font-size: 18.33px;">java</a> <a href="/tags/java%E5%9F%BA%E7%A1%80/" style="font-size: 11.67px;">java基础</a> <a href="/tags/jdbcTemplate/" style="font-size: 10px;">jdbcTemplate</a> <a href="/tags/jdk8-java/" style="font-size: 10px;">jdk8 - java</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/linux/" style="font-size: 13.33px;">linux</a> <a href="/tags/mac/" style="font-size: 10px;">mac</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/md/" style="font-size: 10px;">md</a> <a href="/tags/mele/" style="font-size: 10px;">mele</a> <a href="/tags/mq/" style="font-size: 11.67px;">mq</a> <a href="/tags/ms/" style="font-size: 11.67px;">ms</a> <a href="/tags/mybatis/" style="font-size: 15px;">mybatis</a> <a href="/tags/oracle/" style="font-size: 11.67px;">oracle</a> <a href="/tags/pagehelper-%E5%88%86%E9%A1%B5/" style="font-size: 10px;">pagehelper - 分页</a> <a href="/tags/photo/" style="font-size: 10px;">photo</a> <a href="/tags/rabbitmq-mq/" style="font-size: 10px;">rabbitmq - mq</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/redis-db/" style="font-size: 10px;">redis - db</a> <a href="/tags/spring/" style="font-size: 11.67px;">spring</a> <a href="/tags/springApplication/" style="font-size: 10px;">springApplication</a> <a href="/tags/springCloud/" style="font-size: 11.67px;">springCloud</a> <a href="/tags/springboot/" style="font-size: 20px;">springboot</a> <a href="/tags/sql%E4%BC%98%E5%8C%96/" style="font-size: 10px;">sql优化</a> <a href="/tags/stream/" style="font-size: 10px;">stream</a> <a href="/tags/struts2/" style="font-size: 10px;">struts2</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/threadPollExecutor/" style="font-size: 10px;">threadPollExecutor</a> <a href="/tags/thymeleaf/" style="font-size: 10px;">thymeleaf</a> <a href="/tags/tomcat/" style="font-size: 11.67px;">tomcat</a> <a href="/tags/tool/" style="font-size: 13.33px;">tool</a> <a href="/tags/war/" style="font-size: 10px;">war</a> <a href="/tags/webservice/" style="font-size: 10px;">webservice</a> <a href="/tags/word/" style="font-size: 10px;">word</a> <a href="/tags/xml/" style="font-size: 11.67px;">xml</a> <a href="/tags/%E4%B8%BB%E9%94%AE/" style="font-size: 10px;">主键</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 11.67px;">事务</a> <a href="/tags/%E4%BB%A3%E7%A0%81/" style="font-size: 10px;">代码</a> <a href="/tags/%E5%85%A5%E5%8F%A3%E7%B1%BB/" style="font-size: 10px;">入口类</a> <a href="/tags/%E5%85%A5%E9%97%A8/" style="font-size: 11.67px;">入门</a> <a href="/tags/%E5%85%AC%E9%92%A5/" style="font-size: 10px;">公钥</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 11.67px;">分布式</a> <a href="/tags/%E5%88%86%E9%A1%B5/" style="font-size: 10px;">分页</a> <a href="/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">单元测试</a> <a href="/tags/%E5%8E%9F%E7%90%86/" style="font-size: 10px;">原理</a> <a href="/tags/%E5%91%BD%E4%BB%A4/" style="font-size: 10px;">命令</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-java/" style="font-size: 10px;">多线程 - java</a> <a href="/tags/%E5%AF%BC%E5%87%BA/" style="font-size: 10px;">导出</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/" style="font-size: 16.67px;">工具类</a> <a href="/tags/%E5%B8%B8%E7%94%A8/" style="font-size: 10px;">常用</a> <a href="/tags/%E5%BC%82%E5%B8%B8/" style="font-size: 10px;">异常</a> <a href="/tags/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/" style="font-size: 10px;">异步调用</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/" style="font-size: 10px;">拦截器</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 11.67px;">日志</a> <a href="/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 10px;">模板</a> <a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 10px;">注解</a> <a href="/tags/%E6%B3%A8%E9%87%8A/" style="font-size: 10px;">注释</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 10px;">消息队列</a> <a href="/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">热部署</a> <a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 10px;">监控</a> <a href="/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/" style="font-size: 10px;">箭头函数</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 11.67px;">线程池</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 10px;">缓存</a> <a href="/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/" style="font-size: 10px;">自动装配</a> <a href="/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/" style="font-size: 10px;">过滤器</a> <a href="/tags/%E9%82%AE%E4%BB%B6/" style="font-size: 10px;">邮件</a> <a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 10px;">集合</a> <a href="/tags/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/" style="font-size: 10px;">雪花算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/23/redis%E6%95%99%E7%A8%8B%E6%95%88%E7%8E%87%E7%89%88/">redis入门效率版</a>
          </li>
        
          <li>
            <a href="/2021/01/22/%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86/">开发中注意的小问题</a>
          </li>
        
          <li>
            <a href="/2021/01/02/SQL%E8%AF%AD%E5%8F%A5%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/">SQL语句性能提升</a>
          </li>
        
          <li>
            <a href="/2020/12/15/%E9%9B%86%E5%90%88%E5%88%86%E9%A1%B5%E5%B7%A5%E5%85%B7%E7%B1%BB/">集合分页工具类</a>
          </li>
        
          <li>
            <a href="/2020/12/10/%E5%8F%AA%E4%BF%AE%E6%94%B9%E5%87%A0%E8%A1%8C%EF%BC%8Cgit%E5%8D%B4%E6%98%BE%E7%A4%BA%E6%95%B4%E4%B8%AA%E6%96%87%E4%BB%B6%E9%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9/">只修改几行，git却显示整个文件都被修改</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>