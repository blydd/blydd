<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-数据库系统原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2020-12-04T02:10:17.000Z" itemprop="datePublished">2020-12-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/db/">db</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">数据库系统原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<p><img src="http://59.110.212.214/upload/20200708_16571956.png"></p>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h3 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1. 原子性（Atomicity）"></a>1. 原子性（Atomicity）</h3><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>
<p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
<h3 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2. 一致性（Consistency）"></a>2. 一致性（Consistency）</h3><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p>
<h3 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3. 隔离性（Isolation）"></a>3. 隔离性（Isolation）</h3><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>
<h3 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4. 持久性（Durability）"></a>4. 持久性（Durability）</h3><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>
<p>系统发生奔溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p>
<hr>
<p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对系统崩溃的情况。</li>
</ul>
<h2 id="AUTOCOMMIT"><a href="#AUTOCOMMIT" class="headerlink" title="AUTOCOMMIT"></a>AUTOCOMMIT</h2><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p>
<h1 id="二、并发一致性问题"><a href="#二、并发一致性问题" class="headerlink" title="二、并发一致性问题"></a>二、并发一致性问题</h1><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<h2 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h2><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>
<h2 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h2><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>
<h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<h2 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h2><p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<hr>
<p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
<h1 id="三、封锁"><a href="#三、封锁" class="headerlink" title="三、封锁"></a>三、封锁</h1><h2 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h2><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p>
<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。<strong>锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</strong></p>
<p><strong>但是加锁需要消耗资源</strong>，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>
<p><strong>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</strong></p>
<h2 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h2><h3 id="1-读写锁"><a href="#1-读写锁" class="headerlink" title="1. 读写锁"></a>1. 读写锁</h3><ul>
<li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li>
<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>
</ul>
<p>有以下两个规定：</p>
<ul>
<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>
<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>
</ul>
<p>锁的兼容关系如下：</p>
<p>![image-20200708162307968](/Users/boguotong/Library/Application Support/typora-user-images/image-20200708162307968.png)</p>
<h3 id="2-意向锁"><a href="#2-意向锁" class="headerlink" title="2. 意向锁"></a>2. 意向锁</h3><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>
<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>
<p><strong>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。</strong>有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<p>各种锁的兼容关系如下：</p>
<p><img src="http://59.110.212.214/upload/20200708_16472219.png"></p>
<p>解释如下：</p>
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li>
<li>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li>
</ul>
<h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><h3 id="1-三级封锁协议"><a href="#1-三级封锁协议" class="headerlink" title="1. 三级封锁协议"></a>1. 三级封锁协议</h3><p><strong>一级封锁协议</strong></p>
<p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p>
<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>
<p><strong>二级封锁协议</strong></p>
<p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p>
<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>
<p><strong>三级封锁协议</strong></p>
<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>
<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>
<h3 id="2-两段锁协议"><a href="#2-两段锁协议" class="headerlink" title="2. 两段锁协议"></a>2. 两段锁协议</h3><p>加锁和解锁分为两个阶段进行。</p>
<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure>
<p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure>
<h2 id="MySQL-隐式与显示锁定"><a href="#MySQL-隐式与显示锁定" class="headerlink" title="MySQL 隐式与显示锁定"></a>MySQL 隐式与显示锁定</h2><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>
<p>InnoDB 也可以使用特定的语句进行显示锁定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... LOCK In SHARE MODE;</span><br><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>
<h1 id="四、隔离级别"><a href="#四、隔离级别" class="headerlink" title="四、隔离级别"></a>四、隔离级别</h1><h2 id="未提交读（READ-UNCOMMITTED）"><a href="#未提交读（READ-UNCOMMITTED）" class="headerlink" title="未提交读（READ UNCOMMITTED）"></a>未提交读（READ UNCOMMITTED）</h2><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p>
<h2 id="提交读（READ-COMMITTED）"><a href="#提交读（READ-COMMITTED）" class="headerlink" title="提交读（READ COMMITTED）"></a>提交读（READ COMMITTED）</h2><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>
<h2 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h2><p>保证在同一个事务中多次读取同一数据的结果是一样的。</p>
<h2 id="可串行化（SERIALIZABLE）"><a href="#可串行化（SERIALIZABLE）" class="headerlink" title="可串行化（SERIALIZABLE）"></a>可串行化（SERIALIZABLE）</h2><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p>
<p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p>
<hr>
<p><img src="http://59.110.212.214/upload/20200708_16461824.png"></p>
<h1 id="五、多版本并发控制"><a href="#五、多版本并发控制" class="headerlink" title="五、多版本并发控制"></a>五、多版本并发控制</h1><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。</p>
<p>在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。</p>
<p>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。</p>
<h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><ul>
<li>系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号 TRX_ID ：事务开始时的系统版本号。</li>
</ul>
<h2 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h2><p>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。</p>
<p>例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO t(id, x) VALUES(1, &quot;a&quot;);</span><br><span class="line">UPDATE t SET x&#x3D;&quot;b&quot; WHERE id&#x3D;1;</span><br><span class="line">UPDATE t SET x&#x3D;&quot;c&quot; WHERE id&#x3D;1;</span><br></pre></td></tr></table></figure>
<p>因为没有使用 <code>START TRANSACTION</code> 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。</p>
<p>INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。</p>
<h2 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h2><p>MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, …}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。</p>
<p>在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：</p>
<ul>
<li>TRX_ID &lt; TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。</li>
<li>TRX_ID &gt; TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</li>
<li>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，需要根据隔离级别再进行判断：<ul>
<li>提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。</li>
<li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li>
</ul>
</li>
</ul>
<p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。</p>
<h2 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h2><h3 id="1-快照读"><a href="#1-快照读" class="headerlink" title="1. 快照读"></a>1. 快照读</h3><p>MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table ...;</span><br></pre></td></tr></table></figure>
<h3 id="2-当前读"><a href="#2-当前读" class="headerlink" title="2. 当前读"></a>2. 当前读</h3><p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT;</span><br><span class="line">UPDATE;</span><br><span class="line">DELETE;</span><br></pre></td></tr></table></figure>
<p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table WHERE ? lock in share mode;</span><br><span class="line">SELECT * FROM table WHERE ? for update;</span><br></pre></td></tr></table></figure>
<h1 id="六、Next-Key-Locks"><a href="#六、Next-Key-Locks" class="headerlink" title="六、Next-Key Locks"></a>六、Next-Key Locks</h1><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p>
<p>MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>
<h2 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h2><p>锁定一个记录上的索引，而不是记录本身。</p>
<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p>
<h2 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h2><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;</span><br></pre></td></tr></table></figure>
<h2 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h2><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(-∞, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, +∞)</span><br></pre></td></tr></table></figure>
<h1 id="七、关系数据库设计理论"><a href="#七、关系数据库设计理论" class="headerlink" title="七、关系数据库设计理论"></a>七、关系数据库设计理论</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>
<p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>
<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p>
<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p>
<table>
<thead>
<tr>
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
<th>Mname</th>
<th>Cname</th>
<th>Grade</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
<td>院长-1</td>
<td>课程-1</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-2</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-1</td>
<td>100</td>
</tr>
<tr>
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-2</td>
<td>95</td>
</tr>
</tbody></table>
<p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p>
<ul>
<li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li>
<li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li>
<li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li>
<li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li>
</ul>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式理论是为了解决以上提到四种异常。</p>
<p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p>
<h3 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1. 第一范式 (1NF)"></a>1. 第一范式 (1NF)</h3><p>属性不可分。</p>
<h3 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2. 第二范式 (2NF)"></a>2. 第二范式 (2NF)</h3><p>每个非主属性完全函数依赖于键码。</p>
<p>可以通过分解来满足。</p>
<p><strong>分解前</strong></p>
<table>
<thead>
<tr>
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
<th>Mname</th>
<th>Cname</th>
<th>Grade</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
<td>院长-1</td>
<td>课程-1</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-2</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-1</td>
<td>100</td>
</tr>
<tr>
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-2</td>
<td>95</td>
</tr>
</tbody></table>
<p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
<li>Sno, Cname-&gt; Grade</li>
</ul>
<p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p>
<p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p>
<p><strong>分解后</strong></p>
<p>关系-1</p>
<table>
<thead>
<tr>
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
<th>Mname</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
<td>院长-1</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
</tr>
<tr>
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
<td>院长-2</td>
</tr>
</tbody></table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
</ul>
<p>关系-2</p>
<table>
<thead>
<tr>
<th>Sno</th>
<th>Cname</th>
<th>Grade</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>课程-1</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>课程-2</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>课程-1</td>
<td>100</td>
</tr>
<tr>
<td>3</td>
<td>课程-2</td>
<td>95</td>
</tr>
</tbody></table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno, Cname -&gt; Grade</li>
</ul>
<h3 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3. 第三范式 (3NF)"></a>3. 第三范式 (3NF)</h3><p>非主属性不传递函数依赖于键码。</p>
<p>上面的 关系-1 中存在以下传递函数依赖：</p>
<ul>
<li>Sno -&gt; Sdept -&gt; Mname</li>
</ul>
<p>可以进行以下分解：</p>
<p>关系-11</p>
<table>
<thead>
<tr>
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
</tr>
<tr>
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
</tr>
</tbody></table>
<p>关系-12</p>
<table>
<thead>
<tr>
<th>Sdept</th>
<th>Mname</th>
</tr>
</thead>
<tbody><tr>
<td>学院-1</td>
<td>院长-1</td>
</tr>
<tr>
<td>学院-2</td>
<td>院长-2</td>
</tr>
</tbody></table>
<h1 id="八、ER-图"><a href="#八、ER-图" class="headerlink" title="八、ER 图"></a>八、ER 图</h1><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p>
<p>用来进行关系型数据库系统的概念设计。</p>
<h2 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h2><p>包含一对一，一对多，多对多三种。</p>
<ul>
<li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li>
<li>如果是一对一，画两个带箭头的线段；</li>
<li>如果是多对多，画两个不带箭头的线段。</li>
</ul>
<p>下图的 Course 和 Student 是一对多的关系。</p>
<p><img src="http://59.110.212.214/upload/20200708_16451235.png"></p>
<h2 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h2><p>一个实体在联系出现几次，就要用几条线连接。</p>
<p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p>
<p><img src="http://59.110.212.214/upload/20200708_16445542.png"></p>
<h2 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h2><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p>
<p><img src="http://59.110.212.214/upload/20200708_16443677.png"></p>
<h2 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h2><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。<br><img src="http://59.110.212.214/upload/20200708_16440671.png"></p>
<ul>
<li>转自:<a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md">https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" data-id="ckke5nr5b009zcl8gehg37v44" data-title="数据库系统原理" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/acid/" rel="tag">acid</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E7%90%86/" rel="tag">原理</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-深入学习Spring Boot中的SpringApplication" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/04/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Spring%20Boot%E4%B8%AD%E7%9A%84SpringApplication/" class="article-date">
  <time class="dt-published" datetime="2020-12-04T02:10:17.000Z" itemprop="datePublished">2020-12-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/springboot/">springboot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/04/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Spring%20Boot%E4%B8%AD%E7%9A%84SpringApplication/">深入学习springboot中的SpringApplication</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在Spring Boot的入口类中，我们通常是通过调用<code>SpringApplication</code>的run方法来启动Spring Boot项目。这节我们来深入学习下SpringApplication的一些细节。</p>
<h2 id="自定义SpringApplication"><a href="#自定义SpringApplication" class="headerlink" title="自定义SpringApplication"></a>自定义SpringApplication</h2><p>默认的我们都是直接通过<code>SpringApplication</code>的run方法来直接启动Spring Boot，其实我们可以通过一些API来调整某些行为。</p>
<h3 id="通过SpringApplication-API调整"><a href="#通过SpringApplication-API调整" class="headerlink" title="通过SpringApplication API调整"></a>通过SpringApplication API调整</h3><p>我们新建一个SpringBoot项目，Spring Boot版本为2.1.0.RELEASE，<code>artifactId</code>为SpringApplication，并引入<code>spring-boot-starter-web</code>依赖。项目结构如下所示:</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190223103358.png" alt="QQ截图20190223103358.png"></p>
<p>我们将入口类的代码改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication application = <span class="keyword">new</span> SpringApplication(DemoApplication.class);</span><br><span class="line">application.setBannerMode(Banner.Mode.OFF);<span class="comment">//关闭了Banner的打印</span></span><br><span class="line">application.setWebApplicationType(WebApplicationType.NONE);<span class="comment">//设置应用环境为非WEB应用</span></span><br><span class="line">application.setAdditionalProfiles(<span class="string">&quot;dev&quot;</span>);<span class="comment">//profiles指定为dev</span></span><br><span class="line">application.run(args);</span><br></pre></td></tr></table></figure>


<p>通过调用<code>SpringApplication</code>的方法，我们关闭了Banner的打印，设置应用环境为非WEB应用，profiles指定为dev。除此之外，<code>SpringApplication</code>还包含了许多别的方法，具体可以查看源码或者官方文档：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190223101959.png" alt="QQ截图20190223101959.png"></p>
<h3 id="通过SpringApplicationBuilder-API调整"><a href="#通过SpringApplicationBuilder-API调整" class="headerlink" title="通过SpringApplicationBuilder API调整"></a>通过SpringApplicationBuilder API调整</h3><p><code>SpringApplicationBuilder</code>提供了Fluent API，可以实现链式调用，下面的代码和上面的效果一致，但在编写上较为方便：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(DemoApplication.class)</span><br><span class="line">        .bannerMode(Banner.Mode.OFF)</span><br><span class="line">        .web(WebApplicationType.NONE)</span><br><span class="line">        .profiles(<span class="string">&quot;dev&quot;</span>)</span><br><span class="line">        .run(args);</span><br></pre></td></tr></table></figure>
<h2 id="SpringApplication准备阶段"><a href="#SpringApplication准备阶段" class="headerlink" title="SpringApplication准备阶段"></a>SpringApplication准备阶段</h2><p><code>SpringApplication</code>的生命周期阶段大致可以分为准备阶段和运行阶段。</p>
<p>我们通过源码来查看<code>SpringApplication</code>的有参构造器：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190223102806.png" alt="QQ截图20190223102806.png"></p>
<p>通过有参构造器里的代码我们可以将<code>SpringApplication</code>的准备阶段分为以下几个步骤：</p>
<h3 id="配置源"><a href="#配置源" class="headerlink" title="配置源"></a>配置源</h3><p>构造器中<code>this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</code>这行代码用于加载我们配置的Spring Boot Bean源。通常我们使用<code>SpringApplication</code>或者<code>SpringApplicationBuilder</code>的构造器来直接指定源。</p>
<p>所谓的<strong>Spring Boot Bean源指的是某个被<code>@SpringBootApplication</code>注解标注的类，比如入口类</strong>：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190223104742.png" alt="QQ截图20190223104742.png"></p>
<p>我们也可以将上面的代码改为下面这种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class DemoApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication application &#x3D; new SpringApplication(ApplicationResource.class);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SpringBootApplication</span><br><span class="line">    public static class ApplicationResource &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这样也是可行的。查看<code>SpringApplication</code>的单个参数构造器：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190223105200.png" alt="QQ截图20190223105200.png"></p>
<p>说明我们除了配置单个源外，还可以配置多个源。</p>
<h3 id="推断应用类型"><a href="#推断应用类型" class="headerlink" title="推断应用类型"></a>推断应用类型</h3><p>构造器中这行<code>this.webApplicationType = WebApplicationType.deduceFromClasspath();</code>代码用于推断当前Spring Boot应用类型。</p>
<p>Spring Boot 2.0后，应用可以分为下面三种类型：</p>
<ol>
<li><code>WebApplicationType.NONE</code>：非WEB类型；</li>
<li><code>WebApplicationType.REACTIVE</code>：Web Reactive类型；</li>
<li><code>WebApplicationType.SERVLET</code>：Web Servlet类型。</li>
</ol>
<p><code>WebApplicationType.deduceFromClasspath()</code>或根据当前应用ClassPath中是否存在相关的实现类来判断应用类型到底是哪个，<code>deduceFromClasspath</code>方法的源码如下所示:</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190223105842.png" alt="QQ截图20190223105842.png"></p>
<p>我们也可以直接通过<code>SpringApplication</code>的<code>setWebApplicationType</code>方法或者<code>SpringApplicationBuilder</code>的<code>web</code>方法来指定当前应用的类型。</p>
<h3 id="加载应用上下文初始器"><a href="#加载应用上下文初始器" class="headerlink" title="加载应用上下文初始器"></a>加载应用上下文初始器</h3><p>接着下一行代码<code>setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</code>用于加载应用上下文初始器<code>ApplicationContextInitializer</code>。</p>
<p><code>getSpringFactoriesInstances</code>方法的源码如下所示：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190223110924.png" alt="QQ截图20190223110924.png"></p>
<p>上面代码利用Spring工厂加载机制，实例化<code>ApplicationContextInitializer</code>实现类，并进行排序。</p>
<p>所以我们可以通过实现<code>ApplicationContextInitializer</code>接口用于在Spring Boot应用初始化之前执行一些自定义操作。</p>
<p>举个例子，在<code>com.example.demo</code>下新建<code>initializer</code>包，然后创建一个<code>HelloApplicationContextInitializer</code>类，实现<code>ApplicationContextInitializer</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationContextInitializer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConfigurableApplicationContext.id - &quot;</span> + applicationContext.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面代码中实现了initialize方法，并且使用<code>@Order</code>注解指定优先级。其中<code>Ordered.HIGHEST_PRECEDENCE</code>等于<code>Integer.MIN_VALUE</code>，<code>Ordered.LOWEST_PRECEDENCE</code>等于<code>Integer.MAX_VALUE</code>。所以数值越小，优先级越高。</p>
<p>除了使用<code>@Order</code>注解来指定优先级外，我们也可以通过实现<code>org.springframework.core.Ordered</code>接口的<code>getOrder</code>方法来指定优先级。</p>
<p>接着我们来创建一个优先级比<code>HelloApplicationContextInitializer</code>低的Initializer —— <code>AfterHelloApplicationContextInitializer</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterHelloApplicationContextInitializer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextInitializer</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AfterHelloApplicationContextInitializer: &quot;</span> + applicationContext.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面通过<code>getOrder</code>方法来指定了优先级为最低优先级。</p>
<p>创建好后，我们还需在工厂配置文件里配置这两个实现类。在resources目录下新建META-INF目录，并创建spring.factories文件：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Initializers</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationContextInitializer</span>=<span class="string">\</span></span><br><span class="line">com.example.demo.initializer.HelloApplicationContextInitializer,\</span><br><span class="line"><span class="attr">com.example.demo.initializer.AfterHelloApplicationContextInitializer</span></span><br></pre></td></tr></table></figure>


<p>这时候，启动Spring Boot项目，会发现控制台在打印Banner后就执行了这两个初始化器，并且<code>HelloApplicationContextInitializer</code>的<code>initialize</code>方法执行时机先于<code>AfterHelloApplicationContextInitializer</code>的<code>initialize</code>方法：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190223155233.png" alt="QQ截图20190223155233.png"></p>
<h3 id="加载应用事件监听器"><a href="#加载应用事件监听器" class="headerlink" title="加载应用事件监听器"></a>加载应用事件监听器</h3><p>在加载完应用上下文初始器后，下一行的<code>setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</code>代码加载了应用事件监听器。与加载事件上下文初始器类似，Spring Boot也是通过Spring的工厂方法来实例化<code>ApplicationListener</code>的实现类，并进行排序。</p>
<p>既然是事件监听，那么其可以监听什么事件呢？其监听的是<code>ApplicationEvent</code>接口的实现类，我们查看一下都有哪些事件实现了这个接口：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190223162205.png" alt="QQ截图20190223162205.png"></p>
<p>这里我们以<code>ContextClosedEvent</code>为例子来编写自定义的应用事件监听器，监听Spring上下文关闭事件。</p>
<p>在<code>com.example.demo</code>下新建<code>listener</code>包，然后创建一个<code>ContextClosedEventListener</code>类，实现<code>ApplicationListener</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextClosedEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextClosedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ContextClosedEvent: &quot;</span> + event.getApplicationContext().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面代码实现了对<code>ContextClosedEvent</code>事件的监听，并且分配了最高优先级。</p>
<p>接着创建一个优先级比<code>ContextClosedEventListener</code>低的上面代码实现了对<code>ContextClosedEvent</code>事件监听器<code>AfterContextClosedEventListener</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterContextClosedEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextClosedEvent</span>&gt;, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AfterContextClosedEventr: &quot;</span> + event.getApplicationContext().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Ordered.HIGHEST_PRECEDENCE + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>最后，别忘了在Spring工厂配置文件里进行配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Application Listeners</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationListener</span>=<span class="string">\</span></span><br><span class="line">com.example.demo.listener.ContextClosedEventListener,\</span><br><span class="line"><span class="attr">com.example.demo.listener.AfterContextClosedEventListener</span></span><br></pre></td></tr></table></figure>


<p>在Spring Boot入口类中将环境指定为非WEB环境（这样在启动后应用会马上关闭）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(DemoApplication.class)</span><br><span class="line">                .web(WebApplicationType.NONE)</span><br><span class="line">                .run(args);</span><br></pre></td></tr></table></figure>


<p>运行Spring Boot入口类，控制台输出如下：<img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190223162948.png" alt="QQ截图20190223162948.png"></p>
<h3 id="推断入口类"><a href="#推断入口类" class="headerlink" title="推断入口类"></a>推断入口类</h3><p>接着构造器里的代码下一行<code>this.mainApplicationClass = deduceMainApplicationClass();</code>用于推断运行Spring Boot应用的入口类。查看<code>deduceMainApplicationClass</code>方法源码：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190225093317.png" alt="QQ截图20190225093317.png"></p>
<p>代码主要逻辑是根据Main线程执行堆栈判断实际的入口类。</p>
<p>准备阶段介绍完毕后，接下来开始介绍运行阶段。</p>
<h2 id="SpringApplication运行阶段"><a href="#SpringApplication运行阶段" class="headerlink" title="SpringApplication运行阶段"></a>SpringApplication运行阶段</h2><p>SpringApplication的运行阶段对应<code>SpringApplication</code>的<code>run</code>方法，我们查看其源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">    listeners.starting();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">                args);</span><br><span class="line">        ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">                applicationArguments);</span><br><span class="line">        configureIgnoreBeanInfo(environment);</span><br><span class="line">        Banner printedBanner = printBanner(environment);</span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">                SpringBootExceptionReporter.class,</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;ConfigurableApplicationContext.class&#125;, context);</span><br><span class="line">        prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">                printedBanner);</span><br><span class="line">        refreshContext(context);</span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">                    .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        listeners.started(context);</span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        listeners.running(context);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行阶段大致可以分为下面这几个过程：</p>
<h3 id="开启时间监听"><a href="#开启时间监听" class="headerlink" title="开启时间监听"></a>开启时间监听</h3><p><code>run</code>方法开头的这两行代码用于开启时间监听：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br></pre></td></tr></table></figure>


<p>上面代码用于开启Spring Boot应用启动时间监听，配合下面的<code>stopWatch.stop();</code>便可以计算出完整的启动时间。</p>
<h3 id="开启运行监听器"><a href="#开启运行监听器" class="headerlink" title="开启运行监听器"></a>开启运行监听器</h3><p><code>run</code>方法的这几行代码用于加载Spring应用运行监听器（SpringApplicationRunListener）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">listeners.started();</span><br></pre></td></tr></table></figure>


<p><code>getRunListeners</code>方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SpringApplicationRunListeners <span class="title">getRunListeners</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SpringApplicationRunListeners(logger, getSpringFactoriesInstances(</span><br><span class="line">        SpringApplicationRunListener.class, types, <span class="keyword">this</span>, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面代码通过<code>SpringFactoriesLoader</code>检索META-INF/spring.factories找到声明的所有<code>SpringApplicationRunListener</code>的实现类并将其实例化，然后装配到<code>List</code>运行监听器集合中。</p>
<p><code>listeners.started();</code>用于遍历运行监听器集合中的所有<code>SpringApplicationRunListener</code>的实现类，并逐一调用它们的<code>starting</code>方法，广播Spring Boot应用要开始启动了。</p>
<p>在Spring Boot中<code>SpringApplicationRunListener</code>接口用于监听整个Spring Boot应用生命周期，其代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">started</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">running</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这些方法对应着Spring Boot应用生命周期的各个阶段：</p>
<table>
<thead>
<tr>
<th align="left">方法名称</th>
<th align="left">对应生命周期</th>
<th align="left">Spring Boot起始版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left">starting()</td>
<td align="left">Spring 应用刚启动</td>
<td align="left">1.0</td>
</tr>
<tr>
<td align="left">environmentPrepared(ConfigurableEnvironment)</td>
<td align="left">ConfigurableEnvironment 准备完毕，允许将其调整</td>
<td align="left">1.0</td>
</tr>
<tr>
<td align="left">contextPrepared(ConfigurableApplicationContext)</td>
<td align="left">ConfigurableApplicationContext 准备完毕，允许将其调整</td>
<td align="left">1.0</td>
</tr>
<tr>
<td align="left">contextLoaded(ConfigurableApplicationContext)</td>
<td align="left">ConfigurableApplicationContext 已装载，但仍未启动</td>
<td align="left">1.0</td>
</tr>
<tr>
<td align="left">started(ConfigurableApplicationContext)</td>
<td align="left">ConfigurableApplicationContext 已启动，此时 Spring Bean 已初始化完成</td>
<td align="left">2.0</td>
</tr>
<tr>
<td align="left">running(ConfigurableApplicationContext)</td>
<td align="left">Spring 应用正在运行</td>
<td align="left">2.0</td>
</tr>
<tr>
<td align="left">failed(ConfigurableApplicationContext,Throwable)</td>
<td align="left">Spring 应用运行失败</td>
<td align="left">2.0</td>
</tr>
</tbody></table>
<p>我们在<code>com.example.demo.linstener</code>下自定义一个<code>SpringApplicationRunListener</code>接口实现类<code>HelloSpringApplicationRunListener</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationRunListener</span> <span class="keyword">implements</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloApplicationRunListener</span><span class="params">(SpringApplication application, String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloApplicationRunListener starting......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">started</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">running</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>通过这个实现类，我们可以在Spring Boot应用刚启动的时候在控制台输出<code>HelloApplicationRunListener starting......</code>。</p>
<p>因为其基于Spring的工厂方法来实现，所以我们需要在spring.factories文件里配置这个实现类:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run Listeners</span></span><br><span class="line"><span class="meta">org.springframework.boot.SpringApplicationRunListener</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">com.example.demo.run.HelloApplicationRunListener</span></span><br></pre></td></tr></table></figure>


<p>启动Spring Boot应用便可以在控制台看到如下输出了：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190225101411.png" alt="QQ截图20190225101411.png"></p>
<h3 id="创建-Environment"><a href="#创建-Environment" class="headerlink" title="创建 Environment"></a>创建 Environment</h3><p><code>run</code>方法中的这行代码用于创建并配置当前SpringBoot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br></pre></td></tr></table></figure>


<p>我们已经在准备阶段里推断出了应用类型，这里只要根据相应的应用类型来创建相应的应用环境即可，类型和环境对应关系如下：</p>
<ul>
<li>Web Reactive： StandardReactiveWebEnvironment</li>
<li>Web Servlet： StandardServletEnvironment</li>
<li>非 Web： StandardEnvironment</li>
</ul>
<p>在<code>prepareEnvironment</code>方法中会执行<code>listeners.environmentPrepared(environment);</code>，用于遍历调用所有<code>SpringApplicationRunListener</code>实现类的<code>environmentPrepared()</code>方法，广播Environment准备完毕。</p>
<h3 id="是否打印Banner"><a href="#是否打印Banner" class="headerlink" title="是否打印Banner"></a>是否打印Banner</h3><p><code>run</code>方法中的这行代码会根据我们的配置来决定是否打印Banner：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Banner printedBanner = printBanner(environment);</span><br></pre></td></tr></table></figure>


<h3 id="创建Context"><a href="#创建Context" class="headerlink" title="创建Context"></a>创建Context</h3><p><code>run</code>方法中的这行代码用于创建<code>ApplicationContext</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context = createApplicationContext();</span><br></pre></td></tr></table></figure>


<p>不同的环境对应不同的<code>ApplicationContext</code>：</p>
<ul>
<li>Web Reactive： AnnotationConfigReactiveWebServerApplicationContext</li>
<li>Web Servlet： AnnotationConfigServletWebServerApplicationContext</li>
<li>非 Web： AnnotationConfigApplicationContext</li>
</ul>
<h3 id="装配Context"><a href="#装配Context" class="headerlink" title="装配Context"></a>装配Context</h3><p><code>run</code>方法中的这行代码用于装配Context：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br></pre></td></tr></table></figure>


<p>方法<code>prepareContext</code>的源码如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">    context.setEnvironment(environment);</span><br><span class="line">    postProcessApplicationContext(context);</span><br><span class="line">    applyInitializers(context);</span><br><span class="line">    listeners.contextPrepared(context);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">        logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">        logStartupProfileInfo(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add boot specific singleton beans</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">    beanFactory.registerSingleton(<span class="string">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class="line">    <span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">        ((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">                .setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Load the sources</span></span><br><span class="line">    Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">    Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line">    load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">    listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>prepareContext</code>方法开头为<code>ApplicationContext</code>加载了environment，之后通过<code>applyInitializers</code>方法逐个执行<code>ApplicationContextInitializer</code>的<code>initialize</code>方法来进一步封装<code>ApplicationContext</code>，并调用所有的<code>SpringApplicationRunListener</code>实现类的<code>contextPrepared</code>方法，广播ApplicationContext已经准备完毕了。</p>
<p>之后初始化IOC容器，并调用<code>SpringApplicationRunListener</code>实现类的<code>contextLoaded</code>方法，广播<code>ApplicationContext</code>加载完成，这里就包括通过<code>@EnableAutoConfiguration</code>导入的各种自动配置类。</p>
<h3 id="Refresh-Context"><a href="#Refresh-Context" class="headerlink" title="Refresh Context"></a>Refresh Context</h3><p><code>run</code>方法中的这行代码用于初始化所有自动配置类，并调用<code>ApplicationContext</code>的<code>refresh</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">refreshContext(context);</span><br></pre></td></tr></table></figure>


<h3 id="广播应用已启动"><a href="#广播应用已启动" class="headerlink" title="广播应用已启动"></a>广播应用已启动</h3><p><code>run</code>方法中的这行代码用于广播Spring Boot应用已启动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listeners.started(context);</span><br></pre></td></tr></table></figure>


<p><code>started</code>方法会调用所有的<code>SpringApplicationRunListener</code>的<code>finished</code>方法，广播SpringBoot应用已经成功启动。</p>
<h3 id="执行Runner"><a href="#执行Runner" class="headerlink" title="执行Runner"></a>执行Runner</h3><p><code>run</code>方法中的这行代码<code>callRunners(context, applicationArguments);</code>遍历所有<code>ApplicationRunner</code>和<code>CommandLineRunner</code>的实现类，并执行其<code>run</code>方法。我们可以实现自己的<code>ApplicationRunner</code>或者<code>CommandLineRunner</code>，来对Spring Boot的启动过程进行扩展。</p>
<p>我们在<code>com.example.demo</code>下新建<code>runner</code>包，然后创建一个<code>ApplicationRunner</code>的实现类<code>HelloApplicationRunner</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloApplicationRunner: hello spring boot&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里我们需要将<code>HelloApplicationRunner</code>使用<code>@Component</code>注解标注，让其注册到IOC容器中。</p>
<p>然后再创建一个<code>CommandLineRunner</code>的实现类<code>HelloCommandLineRunner</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloCommandLineRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloCommandLineRunner: hello spring boot&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>启动Spring Boot应用，便可以在应用刚启动好后看到如下输出：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190225112601.png" alt="QQ截图20190225112601.png"></p>
<h3 id="广播应用运行中"><a href="#广播应用运行中" class="headerlink" title="广播应用运行中"></a>广播应用运行中</h3><p><code>run</code>方法中的这行代码<code>listeners.running(context);</code>用于调用<code>SpringApplicationRunListener</code>的<code>running</code>方法，广播Spring Boot应用正在运行中。</p>
<p>当<code>run</code>方法运行出现异常时，便会调用<code>handleRunFailure</code>方法来处理异常，该方法里会通过<code>listeners.failed(context, exception);</code>来调用<code>SpringApplicationRunListener</code>的<code>failed</code>方法，广播应用启动失败，并将异常扩散出去。</p>
<p>上面所有的广播事件都是使用Spring的应用事件广播器接口<code>ApplicationEventMulticaster</code>的实现类<code>SimpleApplicationEventMulticaster</code>来进行广播的。</p>
<blockquote>
<p>源码链接：<a target="_blank" rel="noopener" href="https://github.com/wuyouzhuguli/SpringAll/tree/master/45.Spring-Boot-SpringApplication">https://github.com/wuyouzhuguli/SpringAll/tree/master/45.Spring-Boot-SpringApplication</a></p>
<p>FROM:<a target="_blank" rel="noopener" href="https://mrbird.cc/deepin-springboot-application.html">https://mrbird.cc/deepin-springboot-application.html</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/04/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Spring%20Boot%E4%B8%AD%E7%9A%84SpringApplication/" data-id="ckke5nr5c00a1cl8g9acoeol6" data-title="深入学习springboot中的SpringApplication" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/springApplication/" rel="tag">springApplication</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/springboot/" rel="tag">springboot</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%A5%E5%8F%A3%E7%B1%BB/" rel="tag">入口类</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-SpringBoot项目打包成war包" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/02/SpringBoot%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%88%90war%E5%8C%85/" class="article-date">
  <time class="dt-published" datetime="2020-12-02T14:56:17.000Z" itemprop="datePublished">2020-12-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/springboot/">springboot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/02/SpringBoot%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%88%90war%E5%8C%85/">springboot项目打包成war包</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-修改pom-xml文件"><a href="#1-修改pom-xml文件" class="headerlink" title="1.修改pom.xml文件"></a>1.修改pom.xml文件</h2><h3 id="将打包方式改为war："><a href="#将打包方式改为war：" class="headerlink" title="将打包方式改为war："></a>将打包方式改为war：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="然后添加如下的Tomcat依赖配置，覆盖Spring-Boot自带的Tomcat依赖："><a href="#然后添加如下的Tomcat依赖配置，覆盖Spring-Boot自带的Tomcat依赖：" class="headerlink" title="然后添加如下的Tomcat依赖配置，覆盖Spring Boot自带的Tomcat依赖："></a>然后添加如下的Tomcat依赖配置，覆盖Spring Boot自带的Tomcat依赖：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="在-lt-build-gt-lt-build-gt-标签内配置项目名（该配置类似于server-context-path-mrbird）："><a href="#在-lt-build-gt-lt-build-gt-标签内配置项目名（该配置类似于server-context-path-mrbird）：" class="headerlink" title="在&lt;build&gt;&lt;/build&gt;标签内配置项目名（该配置类似于server.context-path=mrbird）："></a>在<code>&lt;build&gt;&lt;/build&gt;</code>标签内配置项目名（该配置类似于server.context-path=mrbird）：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>mrbird<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="添加启动类ServletInitializer："><a href="#添加启动类ServletInitializer：" class="headerlink" title="添加启动类ServletInitializer："></a>添加启动类ServletInitializer：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.support.SpringBootServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletInitializer</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> application.sources(Application.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中Application为Spring Boot的启动类。</p>
<p>##2.准备完毕后，运行mvn clean package命令即可在target目录下生产war包：</p>
<hr>
<p>FROM:<a target="_blank" rel="noopener" href="https://mrbird.cc/Spring-Boot%20war.html" title="MiBird">MiBird</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/02/SpringBoot%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%88%90war%E5%8C%85/" data-id="ckke5nr31000lcl8gh4k63dqg" data-title="springboot项目打包成war包" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/springboot/" rel="tag">springboot</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/war/" rel="tag">war</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-docker" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/02/docker/" class="article-date">
  <time class="dt-published" datetime="2020-12-02T14:56:17.000Z" itemprop="datePublished">2020-12-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/docker/">docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/02/docker/">docker</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-镜像相关命令"><a href="#1-镜像相关命令" class="headerlink" title="1.镜像相关命令"></a>1.镜像相关命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta">#</span><span class="bash">搜索镜像</span></span><br><span class="line">docker search centos7</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取镜像</span></span><br><span class="line">docker pull centos:7</span><br><span class="line"><span class="meta">#</span><span class="bash">删除镜像</span></span><br><span class="line">docker rmi 镜像ID</span><br><span class="line"><span class="meta">#</span><span class="bash">删除本地全部镜像 慎用</span></span><br><span class="line">docker rmi `docker images -q`</span><br></pre></td></tr></table></figure>
<h1 id="2-容器相关命令"><a href="#2-容器相关命令" class="headerlink" title="2.容器相关命令"></a>2.容器相关命令</h1><h2 id="2-1-创建并启动交互式容器"><a href="#2-1-创建并启动交互式容器" class="headerlink" title="2.1 创建并启动交互式容器"></a>2.1 创建并启动交互式容器</h2><blockquote>
<p> docker交互式容器:(启动容器之后会直接进入容器的命令行终端,如果退出则容器停止运行）</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看正在运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看全部容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta">#</span><span class="bash">创建并启动容器</span></span><br><span class="line">docker run</span><br><span class="line"><span class="meta">#</span><span class="bash">创建并启动交互式容器 退出:<span class="built_in">exit</span>,退出则容器停止运行</span></span><br><span class="line">docker run -it --name=mycentos7 centos:7 /bin/bash</span><br></pre></td></tr></table></figure>
<p><img src="http://mele.cool//image-20201021214847134.png" alt="image-20201021214847134"></p>
<h2 id="2-2-创建并启动守护式容器"><a href="#2-2-创建并启动守护式容器" class="headerlink" title="2.2 创建并启动守护式容器"></a>2.2 创建并启动守护式容器</h2><blockquote>
<p>创建启动docker容器,可以在后台运行;</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建并启动守护式容器</span></span><br><span class="line">docker run -di --name=mycentos2 centos:7</span><br><span class="line"><span class="meta">#</span><span class="bash">登陆进入已启动的容器 退出:<span class="built_in">exit</span>,退出后容器仍在运行</span></span><br><span class="line">docker exec -it mycentos2 /bin/bash</span><br></pre></td></tr></table></figure>
<h2 id="2-3-容器常用命令"><a href="#2-3-容器常用命令" class="headerlink" title="2.3 容器常用命令"></a>2.3 容器常用命令</h2><blockquote>
<p>容器的停止 启动 、拷贝文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">停止</span></span><br><span class="line">docker stop 容器名称</span><br><span class="line"><span class="meta">#</span><span class="bash">启动</span></span><br><span class="line">docker start 容器名称</span><br><span class="line"><span class="meta">#</span><span class="bash">复制宿主机文件到docker 在docker中运行命令</span></span><br><span class="line">docker cp abc.txt mycentos2:/</span><br><span class="line"><span class="meta">#</span><span class="bash">复制docker文件到宿主机 在宿主机中运行命令</span></span><br><span class="line">docker cp mycentos2:/abc.txt /root</span><br></pre></td></tr></table></figure>
<blockquote>
<p>目录挂载:可以在创建容器的时候,将宿主机的目录与容器内的目录进行映射,这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。<br>创建容器时添加-v参数,后边为宿主机目录:容器目录,例如: </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -di -v /usr/local/test:/usr/local/test --name=mycentos3 centos:7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">在linux宿主机下查看mycentos3的ip</span></span><br><span class="line">docker inspect mycentos3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除容器(非运行状态)</span></span><br><span class="line">docker rm mycentos7</span><br><span class="line"><span class="meta">#</span><span class="bash">删除全部容器(包括运行的与非运行的)</span></span><br><span class="line">docker rm `docker ps -a -q\`</span><br></pre></td></tr></table></figure>
<h2 id="2-4-mysql容器部署"><a href="#2-4-mysql容器部署" class="headerlink" title="2.4 mysql容器部署"></a>2.4 mysql容器部署</h2><blockquote>
<ol>
<li>拉取mysql镜像;</li>
<li>创建并启动守护式容器；</li>
<li>在容器中操作mysql;</li>
<li>使用图形界面工具(windows )操作在docker中安装的mysql ;在创建mysql容器的时候使用-p指定端口映射实现连接.<br>在创建容器的时候mysql的root用户可以指定远程访问的密码。</li>
</ol>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> #</span><span class="bash">拉取</span></span><br><span class="line"> docker search mysql</span><br><span class="line"> docker pull centos/mysql-57-centos7</span><br><span class="line"><span class="meta"> #</span><span class="bash">创建并启动守护式容器,指定端口映射</span> </span><br><span class="line"> docker run -di --name=mysql5.7 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root centos/mysql-57-centos7</span><br><span class="line"><span class="meta"> #</span><span class="bash">进入容器</span></span><br><span class="line"> docker exec -it mysql5.7 /bin/bash</span><br><span class="line"> mysql -u root -p #此处密码是空,直接enter登陆</span><br><span class="line"><span class="meta"> #</span><span class="bash">远程连接操作:</span></span><br><span class="line"> 宿主机ip:3306  因为已经指定端口映射了</span><br><span class="line"><span class="meta"> #</span><span class="bash">授权</span></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO root@&quot;%&quot; IDENTIFIED BY &quot;密码&quot;;</span><br><span class="line">flush privileges;</span><br><span class="line"><span class="meta">#</span><span class="bash">进入mysql，然后编辑/etc/mysql/mysql.conf.d/mysqld.cnf,然后重启docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash">参考:https://zhuanlan.zhihu.com/p/46207256</span></span><br><span class="line">bind-address 0.0.0.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">解决mysql容器中没有vim命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash">进入运行中的mysql容器，执行如下语句：docker <span class="built_in">exec</span> -it dd75f390a5df /bin/bash,其中dd75f390a5df是容器ID</span></span><br><span class="line">apt-get install vim</span><br><span class="line"><span class="meta">#</span><span class="bash">若出现报错的输出语句，就执行：apt-get update,然后重新执行apt-get install vim</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结:在创建容器的时候指定环境变量MYSQL-ROOT-PASSWORD表示使用root进行远程连接时候的密码。如果需要进行远程连接的话可以使用-p进行端口映射。</p>
</blockquote>
<h2 id="2-5-tomcat容器部署"><a href="#2-5-tomcat容器部署" class="headerlink" title="2.5 tomcat容器部署"></a>2.5 tomcat容器部署</h2><ul>
<li><p>将项目文件上传到容器中的tomcat目录(webapps)</p>
<p>创建容器的时候可以指定-进行目录挂载, tomcat在容器中的目录(/usr/local/tomcat/webapps )</p>
</li>
<li><p>可以通过外部浏览器访问容器中的项目</p>
<p>创建容器的时候可以指定-p进行端口映射</p>
</li>
</ul>
<p>1,拉取tomcat镜像; docker pu11 tomcat</p>
<p>2.创建并启动tomcat容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=mytomcat -p 9000:8080 -v /usr/1ocal/tomcat/webapps:/usr/local/tomcat/webapps tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如果出现WARNING: IPv4 forwarding is disabled. Networking wil1 not work.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">执行如下操作</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1、编辑sysct1.conf</span></span><br><span class="line">vi /etc/sysctl.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">2、在上述打开的文件中后面添加</span></span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line"><span class="meta">#</span><span class="bash">3、重启network</span></span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>
<p>3,访问容器中tomcat<br>    <a target="_blank" rel="noopener" href="http://192.168.76.128:9000/">http://192.168.76.128:9000</a> 显示404说明部署成功</p>
<h2 id="2-6-Nginx容器部署"><a href="#2-6-Nginx容器部署" class="headerlink" title="2.6 Nginx容器部署"></a>2.6 Nginx容器部署</h2><blockquote>
<p>nginx默认端口是80</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">拉取nginx</span></span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="meta">#</span><span class="bash">创建并启动nginx</span></span><br><span class="line">docker run -di --name=mynginx -p 80:80 nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试,</p>
<h2 id="2-7-redis容器部署"><a href="#2-7-redis容器部署" class="headerlink" title="2.7 redis容器部署"></a>2.7 redis容器部署</h2><blockquote>
<p>默认端口:6379</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">拉取</span></span><br><span class="line">docker pull redis</span><br><span class="line"><span class="meta">#</span><span class="bash">创建并启动容器</span></span><br><span class="line">docker run -di --name=myredis -p 6379:6379 redis</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器</span></span><br><span class="line">docker exec -it myredis /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入命令目录,启动redis</span></span><br><span class="line">cd /usr/local/bin</span><br><span class="line">./redis-cli</span><br><span class="line"><span class="meta">#</span><span class="bash">在redis中输入ping,返回pong说明启动成功</span></span><br></pre></td></tr></table></figure>
<p>测试:使用redis图形化工具 Redis Desktop Manager连接redis容器:</p>
<p><img src="http://mele.cool//image-20201022211759290.png" alt="image-20201022211759290"></p>
<h1 id="3-Docker-Compose"><a href="#3-Docker-Compose" class="headerlink" title="3.Docker Compose"></a>3.Docker Compose</h1><blockquote>
<p>Compose项目是Docker官方的开源项目,负责实现对Docker容器集群的快速编排。它是一个定义和运行多容器的docker应用工具。使用compose,你能通过YMAL文件配置你自己的服务,然后通过一个命令,你能使用配置文件创建和运行所有的服务。</p>
<p><strong>docker-compose是一个应用工具;可以通过配置docker-compose.yml文件同时启动多个容器。</strong></p>
</blockquote>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成:"></a>组成:</h2><p>Docker-Compose将所管理的容器分为三层,分别是工程(project) ,服务(service)以及容器(container) .<br>Docker-Compose运行目录下的所有文件(docker-compose.yml, extends文件或环境变量文件等)组成一个工程,若无特殊指定工程名即为当前目录名。一个工程当中可包含多个服务,每个服务钟定义了容器运行的镜像,参数,依赖。一个服务当中可包括多个容器实例。</p>
<p>Docker-Compose的工程配置文件默认为docker-compose.yml,可通过环境变量COMPOSE-FILE或-参数自定义配置文件,其定义了多个有依赖关系的服务及每个服务运行的容器。</p>
<p>使用一个Dockerfile模板文件,可以让用户很方便的定义一个单独的应用容器。在工作中,经常会碰到需要多个容器相互配合来完成某项任务的情况。例如:要部署一个Web项目,除了Web服务容器,往往还需要再加上后端的数据库服务容器,甚至还包括负载均衡容器等。</p>
<h2 id="安装与卸载"><a href="#安装与卸载" class="headerlink" title="安装与卸载:"></a>安装与卸载:</h2><p>Compose目前已经完全支持Linux, Mac OS和Windows,在我们安装Compose之前,需要先安装Docker,下面我们以编译好的二进制包方式安装在Linux系统中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装</span></span><br><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/1ocal/bin/docker-compose</span><br><span class="line"><span class="meta">#</span><span class="bash">设置文件可执行权限</span></span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta">#</span><span class="bash">查看版本信息</span></span><br><span class="line">docker-compose -version</span><br><span class="line"><span class="meta">#</span><span class="bash">卸载</span></span><br><span class="line">rm -rf /usr/local/bin/docker-compose </span><br></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用:"></a>应用:</h2><blockquote>
<p>模板文件是使用Compose的核心,涉及的指令关键字也比较多,大部分指令与docker run相关参数的含义都是类似的。默认的模板文件名称为docker-compose.yml,格式为YAML格式。</p>
</blockquote>
<p>Compose命令的基本的使用格式为:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker-compose [-f 參数..] [options] [COMMAND] [ARGS...]</span><br><span class="line">-f, -file FILE指定使用的compose模板文件,默认为docker-compose.yml,可以多次指定。</span><br><span class="line">-p,-project-name NAME指定项目名称,默认将使用所在目录名称作为项目名。</span><br><span class="line">-x-network-driver 使用Docker的可拔插网络后端特性(需要Docker 1.9及以后版本)</span><br><span class="line">-x-network-driver DRIVER指定网络后端的驱动,默认为bridge (需要Docker 1.9及以后版本)</span><br><span class="line">-verbose输出更多调试信息</span><br><span class="line">-v,-version打印版本并退出</span><br></pre></td></tr></table></figure>
<p>使用Compose前,可以通过执行docker-compose –help|-h来查看Compose基本命令用法。<br>也可以通过执行docker-compose [COMMAND] –help或者docker-compose –help [COMMAND]来查看某个具体的使用格式。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令:"></a>常用命令:</h2><p>up</p>
<p>ps</p>
<blockquote>
<p>格式:docker-compose ps [options] [SERVICE …]<br>作用:列出项目中目前的所有容器。<br>选项包括：<br>    -q 只打印容器的ID信息</p>
</blockquote>
<p>stop</p>
<blockquote>
<p>格式为:docker-compose stop [options] [SERVICE…]</p>
<p>作用:停止已经处于运行状态的容器,但不删除它</p>
<p>选项包括:</p>
<p>​    -t, –timeout TIMEOUT 停止容器时候的超时(默认为10秒)</p>
</blockquote>
<p>down</p>
<p><img src="http://mele.cool//image-20201022213849355.png" alt="image-20201022213849355"><img src="http://mele.cool//image-20201022213909059.png" alt="image-20201022213909059"></p>
<p>restart</p>
<p>rm </p>
<p><img src="http://mele.cool//image-20201022213802622.png" alt="image-20201022213802622"></p>
<p>start</p>
<p><img src="http://mele.cool//image-20201022213815702.png" alt="image-20201022213815702"></p>
<p>run</p>
<p>config</p>
<p>kill</p>
<p>create</p>
<p>exec</p>
<p><img src="http://mele.cool//image-20201022214001837.png" alt="image-20201022214001837"></p>
<h2 id="Compose模板文件"><a href="#Compose模板文件" class="headerlink" title="Compose模板文件:"></a>Compose模板文件:</h2><p><img src="http://mele.cool//image-20201022214245204.png" alt="image-20201022214245204"></p>
<p>Docker Compose常用模板文件主要命令:</p>
<p><img src="http://mele.cool//image-20201022214403864.png" alt="image-20201022214403864">![image-20201022214437985](/Users/boguotong/Library/Application Support/typora-user-images/image-20201022214437985.png)<img src="http://mele.cool//image-20201022214502044.png" alt="image-20201022214502044"></p>
<h2 id="compose应用"><a href="#compose应用" class="headerlink" title="compose应用:"></a>compose应用:</h2><blockquote>
<p><strong>需求</strong>:编写compose模版文件,实现同时启动tomcat, mysql和redis容器。</p>
<p><strong>分析</strong>: do cker-compose可以实现一次启动多个容器;通过配置docker-compose模板文件( docker-compose.yml ),在这个配置文件中去配置各个容器及其相关的依赖。<br>1,编写模板文件;<br>2.创建并启动docker-compose项目(模板文件所在的目录, docker-compose.yml )<br>3.测试</p>
</blockquote>
<h3 id="1-编写模板文件"><a href="#1-编写模板文件" class="headerlink" title="1.编写模板文件"></a>1.编写模板文件</h3><p>#创建文件夹<br>mkdir -p /usr/local/mycompose<br>#进入文件夹<br>cd /usr/local/mycompose<br>#创建docker-compose.yml文件;内容如下<br>vi docker-compose.yml</p>
<p><img src="http://mele.cool//image-20201022215958996.png" alt="image-20201022215958996"></p>
<p> <img src="http://mele.cool//image-20201022215642031.png" alt="image-20201022215642031"></p>
<h3 id="2-启动docker-compose"><a href="#2-启动docker-compose" class="headerlink" title="2.启动docker-compose"></a>2.启动docker-compose</h3><p> 编写完配置文件,由于之前启动了容器,为了避免重复启动,可以重启docker之后再启动docker-compose</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启docker</span></span><br><span class="line">systemctl restart docker</span><br><span class="line">pwd</span><br><span class="line">/usr/local/mycompose</span><br><span class="line"><span class="meta">#</span><span class="bash">后台启动docker-compose</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"><span class="meta">#</span><span class="bash">启动完成后查看正在运行的容器,发现web1 mysql1 redis1都成功运行了</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如果要停止 down会删除容器和网络 stop不会</span></span><br><span class="line">docker-compose down </span><br><span class="line"><span class="meta">#</span><span class="bash">查看都有哪些网络 可以发现</span></span><br><span class="line">docker network ls</span><br></pre></td></tr></table></figure>
<p>打开浏览器,测试访问已启动的那些容器.</p>
<h1 id="4-迁移和备份"><a href="#4-迁移和备份" class="headerlink" title="4.迁移和备份"></a>4.迁移和备份</h1><blockquote>
<p> <strong>目标:**能够将容器保存为镜像,备份,恢复镜像再启动以恢复的镜像作为基础的容器<br>**分析：</strong>在当前的容器中安装了各种组件;期望在其他服务器上也能快速拥有该容器的一切环境;可以将当前的容器制作为一个镜像,再将该镜像复制到其他服务器,其他服务器再基于镜像运行容器。</p>
</blockquote>
<p><img src="http://mele.cool//image-20201022221019216.png" alt="image-20201022221019216"></p>
<p><strong>其中涉及到的命令有:</strong></p>
<ul>
<li>docker commit将容器保存为镜像</li>
<li>docker save将镜像备份为tar文件</li>
<li>docker load根据tar文件恢复为镜像</li>
</ul>
<p><strong>步骤:</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">把容器名为mynginx的容器打包成一个镜像,命名镜像名为mynginx</span> </span><br><span class="line">docker commit mynginx mynginx</span><br><span class="line"><span class="meta">#</span><span class="bash">把myninx镜像保存为mynginx.tar文件,保存到本地路径.保存完可以ll查看tar文件</span></span><br><span class="line">docker save -o mynginx.tar mynginx</span><br><span class="line"><span class="meta">#</span><span class="bash">tar包复制到另一个服务器后进行恢复,后可以docker images查看此镜像,然后根据镜像运行容器</span></span><br><span class="line">docker load -i mynginx.tar</span><br><span class="line"><span class="meta">#</span><span class="bash">启动</span></span><br><span class="line">docker run -di --name=mynginx -p 80:80 mynginx</span><br></pre></td></tr></table></figure>
<h1 id="5-使用Dockerfile创建镜像"><a href="#5-使用Dockerfile创建镜像" class="headerlink" title="5.使用Dockerfile创建镜像"></a>5.使用Dockerfile创建镜像</h1><blockquote>
<p>已经知道了,要获得镜像,可以从Docker仓库中进行下载。那如果我们想自己开发一个镜像,那该如何做呢?答案是:Dockerfile<br>Dockerfile其实就是一个文本文件,由一系列命令和参数构成, Docker可以读取Dockerfile文件并根据Dockerfile文件的描述来构建镜像。</p>
<p><strong>Dockerfile文件内容一般分为4部分:</strong></p>
<ul>
<li>基础镜像信息</li>
<li>维护者信息</li>
<li>镜像操作指令</li>
<li>容器启动时执行的指令</li>
</ul>
</blockquote>
<p>Dockerfile常用命令:</p>
<p><img src="http://mele.cool//image-20201022222401357.png" alt="image-20201022222401357"></p>
<p>**DEMO:**在centos7作为基础镜像上;添加idk1.8并构建一个包含idk1.8的centos7新镜像。</p>
<p>实现步骤：</p>
<ol>
<li><p>拉取centos7镜像;</p>
</li>
<li><p>上传jdk1.8;</p>
</li>
<li><p>编写Dockerfile文件;</p>
</li>
<li><p>构建镜像;</p>
</li>
<li><p>5测试(基于新镜像创建并运行容器,运行java-version)</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos7</span><br><span class="line"><span class="meta">#</span><span class="bash">创建jdk放置目录,并把jdk8文件上传进去,在此目录下执行以下命令</span></span><br><span class="line">mkdir -p /usr/local/dockerjdk8</span><br><span class="line"><span class="meta">#</span><span class="bash">创建Dockerfile文件</span></span><br><span class="line">vi Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">Dockerfile内容begin</span></span><br><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER myname</span><br><span class="line">WORKDIR /usr</span><br><span class="line">RUN mkdir /usr/local/java</span><br><span class="line">ADD jdk-8u202-1inux-x64.tar.gz /usr/local/java/</span><br><span class="line">ENV JAVA-HOME /usr/local/java/jdk1.8.0_202</span><br><span class="line">ENV JRE_HOME $JAVA_HOME/jre</span><br><span class="line">ENV CLASSPATH $JAVA-HOME/1ib/dt.jar:$JAVA-HOME/1ib/tools.jar:$JRE_HOME/1ib:$CLASSPATH</span><br><span class="line">ENV PATH $JAVA_HOME/bin:$PATH</span><br><span class="line"><span class="meta">#</span><span class="bash">Dockerfile内容end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">构建镜像.注意最后一个点,表示在当前目录下构建镜像,镜像名为jdk1.8</span></span><br><span class="line">docker build -t=&#x27;jdk1.8&#x27; .</span><br><span class="line"><span class="meta">#</span><span class="bash">查看镜像是否建立完成</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta">#</span><span class="bash">创建并启动容器 启动后会默认进入文件中设置的工作目录/usr</span></span><br><span class="line">docker run -it --name=testjdk jdk1.8 /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash">验证java版本是否显示</span></span><br><span class="line">java -verison</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="6-私有仓库搭建与配置"><a href="#6-私有仓库搭建与配置" class="headerlink" title="6.私有仓库搭建与配置"></a>6.私有仓库搭建与配置</h1><blockquote>
<p>Docker官方的Docker hub (<a target="_blank" rel="noopener" href="http://hub.docker.com)是一个用于管理公共镜像的仓库,我们可以从上面拉取镜像到本地,也可以把我们自己的镜像推送上去.但是,有时候我们的服务器无法访问互联网,或者你不希望将自己的镜像放到公网当中,那么我们就需要搭建自己的私有仓库来存储和管理自己的镜像./">http://hub.docker.com)是一个用于管理公共镜像的仓库,我们可以从上面拉取镜像到本地,也可以把我们自己的镜像推送上去。但是,有时候我们的服务器无法访问互联网,或者你不希望将自己的镜像放到公网当中,那么我们就需要搭建自己的私有仓库来存储和管理自己的镜像。</a></p>
</blockquote>
<p>私有仓库搭建步骤:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、拉取私有仓库镜像</span></span><br><span class="line">docker pull registry</span><br><span class="line"><span class="meta">#</span><span class="bash">2、启动私有仓库容器</span></span><br><span class="line">docker run -di --name=registry -p 5000:5000 registry</span><br><span class="line"><span class="meta">#</span><span class="bash">3、打开浏览器输入地址http://宿主机ip: 5000/v2/_catalog,看到&#123;<span class="string">&quot;repositories&quot;</span>:[]&#125;表示私有仓库搭建成功</span></span><br><span class="line"><span class="meta">#</span><span class="bash">4、修改daemon.json</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="meta">#</span><span class="bash">在上述文件中添加一个key,保存退出。此步用于让docker信任私有仓库地址;注意将宿主机ip修改为自己宿主机真实ip</span></span><br><span class="line">&#123;&quot;insecure-registries&quot; : [&quot;宿主机ip: 5000&quot;]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">5、重启docker服务</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line">docker start registry</span><br><span class="line"><span class="meta">#</span><span class="bash">打开浏览器输入地址http://宿主机ip: 5000/v2/_catalog,看到&#123;<span class="string">&quot;repositories&quot;</span>:[]&#125;表示私有仓库搭建成功</span></span><br></pre></td></tr></table></figure>
<h2 id="将镜像上传至私有仓库"><a href="#将镜像上传至私有仓库" class="headerlink" title="将镜像上传至私有仓库"></a>将镜像上传至私有仓库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、标记镜像为私有仓库的镜像</span></span><br><span class="line">docker tag jdk1.8 宿主机IP:5000/jdk1.8</span><br><span class="line"><span class="meta">#</span><span class="bash">2、再次启动私有仓库容器</span></span><br><span class="line">docker restart registry</span><br><span class="line"><span class="meta">#</span><span class="bash">3、上传标记的镜像</span></span><br><span class="line">docker push 宿主机IP:5000/jdk1.8</span><br><span class="line"><span class="meta">#</span><span class="bash">4、输入网址查看仓库效果</span></span><br></pre></td></tr></table></figure>
<h2 id="从私有仓库拉取镜像"><a href="#从私有仓库拉取镜像" class="headerlink" title="从私有仓库拉取镜像"></a>从私有仓库拉取镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">若是在私有仓库所在的服务器上去拉取镜像;那么直接执行如下命令:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">因为私有仓库所在的服务器上已经存在相关镜像;所以先删除;请指定镜像名,不是id</span></span><br><span class="line">docker rmi 服务器ip:5000/jdk1.8</span><br><span class="line"><span class="meta">#</span><span class="bash">拉取镜像</span></span><br><span class="line">docker pul1 服务器ip:5000/jdk1.8</span><br><span class="line"><span class="meta">#</span><span class="bash">可以通过如下命令查看docker的信息;了解到私有仓库地址</span></span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">大多数情况下,都是某台服务器部署了私有镜像仓库之后;到其它服务器上从私有仓库中拉取镜像,若要拉取私有仓库镜像需要去修改docker的配置文件,设置启动时候的仓库地址。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">打开配置文件</span></span><br><span class="line">vi /usr/lib/systemd/system/docker.service</span><br><span class="line"><span class="meta">#</span><span class="bash">在打开的上述文件中按照下面的图,添加如下的内容;注意修改下面内容中的ip地址</span></span><br><span class="line">--add-registry=192.168.12.135:5000 --insecure-registry=192.168.12.135:5000</span><br><span class="line"><span class="meta">#</span><span class="bash">修改完后需要重新加载docker配置文件并重启docker</span></span><br><span class="line">systemctl daemon-reload </span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="meta">#</span><span class="bash">在重启之后;那么则可以去拉取私有仓库中的镜像:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">执行拉取镜像命令并查看</span></span><br><span class="line">docker pull jdk1.8 </span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/02/docker/" data-id="ckke5nr32000ncl8g6u38cyvb" data-title="docker" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-git" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/02/git/" class="article-date">
  <time class="dt-published" datetime="2020-12-02T14:56:17.000Z" itemprop="datePublished">2020-12-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/">版本控制</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/02/git/">git</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-git常用命令"><a href="#1-git常用命令" class="headerlink" title="1.git常用命令"></a>1.git常用命令</h2><h3 id="1-1-设置用户信息-标识是谁提交的代码"><a href="#1-1-设置用户信息-标识是谁提交的代码" class="headerlink" title="1.1.设置用户信息:标识是谁提交的代码"></a>1.1.设置用户信息:标识是谁提交的代码</h3><ul>
<li>设置用户名 git config –global user.name “yourname”</li>
<li>设置邮箱 git config –global user.email “<a href="mailto:&#x79;&#111;&#117;&#101;&#x6d;&#x61;&#x69;&#108;&#64;&#113;&#x71;&#x2e;&#99;&#x6f;&#109;">&#x79;&#111;&#117;&#101;&#x6d;&#x61;&#x69;&#108;&#64;&#113;&#x71;&#x2e;&#99;&#x6f;&#109;</a>“</li>
<li>查看配置信息 git config –list  </li>
<li>查看用户名  git config user.name</li>
</ul>
<p>配置信息保存在   <code>~/.gitconfig</code> 文件中</p>
<h3 id="1-2-获取git仓库"><a href="#1-2-获取git仓库" class="headerlink" title="1.2 获取git仓库"></a>1.2 获取git仓库</h3><p>要使用git对代码进行版本控制,首先要获得git仓库,获得方式有两种:</p>
<ul>
<li>本地初始化一个git仓库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在本地仓库文件夹中</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
<ul>
<li>从远程仓库克隆</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 远程仓库地址</span><br></pre></td></tr></table></figure>
<h3 id="1-3-工作目录、暂存区以及版本库-概念"><a href="#1-3-工作目录、暂存区以及版本库-概念" class="headerlink" title="1.3 工作目录、暂存区以及版本库 概念"></a>1.3 工作目录、暂存区以及版本库 概念</h3><ul>
<li>**版本库:**前面看到的.git隐藏文件夹就是版本库,版本库中存储了很多配置信息、日志信息和文件版本信息等</li>
<li><strong>工作目录(工作区)</strong> :包含.git文件夹的目录就是工作目录,主要用于存放开发的代码</li>
<li><strong>暂存区:</strong> .git文件夹中有很多文件,其中有一个index文件就是暂存区,也可以叫做stage.暂存区是一个临时保存修改文件的地方</li>
</ul>
<p><img src="http://mele.cool//image-20200926090234827.png" alt="image-20200926090234827"></p>
<h3 id="1-4-Git工作目录下文件的两种状态"><a href="#1-4-Git工作目录下文件的两种状态" class="headerlink" title="1.4 Git工作目录下文件的两种状态"></a>1.4 Git工作目录下文件的两种状态</h3><ul>
<li>untracked未跟踪(未被纳入版本控制)</li>
<li>tracked已跟踪(被纳入版本控制)<ul>
<li>Unmodified未修改状态</li>
<li>Modified已修改状态</li>
<li>Staged已暂存状态</li>
</ul>
</li>
</ul>
<h3 id="1-5-提交命令和查看状态"><a href="#1-5-提交命令和查看状态" class="headerlink" title="1.5 提交命令和查看状态"></a>1.5 提交命令和查看状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看各个文件状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使输出信息更简洁</span></span><br><span class="line">git status -s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把文件加入暂存区</span> </span><br><span class="line">git add hell.java</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把文件取消暂存</span></span><br><span class="line">git reset HEAD hell.java</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把暂存区文件提交到本地仓库 (如果文件没加入暂存区则无法提交到本地仓库)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果不加-m,则会打开编辑器让填写日志</span></span><br><span class="line">git commit -m &quot;提交日志&quot;</span><br><span class="line"><span class="meta"> #</span><span class="bash"> 删除文件(删除本地工作区文件,需要git commit -m <span class="string">&quot;delete file&quot;</span> 提交到远程)</span></span><br><span class="line"><span class="meta"> #</span><span class="bash"> 如果右键删除文件,并没有加到暂存区,还需要通过git add 文件名加到暂存区后再commit同步到git远程</span></span><br><span class="line"><span class="meta"> #</span><span class="bash"> 推荐git rm方式删除</span></span><br><span class="line"> git rm hell.java</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="1-6-将文件添加到忽略列表"><a href="#1-6-将文件添加到忽略列表" class="headerlink" title="1.6 将文件添加到忽略列表"></a>1.6 将文件添加到忽略列表</h3><blockquote>
<p>一般我们总会有些文件无需纳入Git的管理,也不希望它们总出现在未跟踪文件列表,通常都是些自动生成的文件,比如日志文件,或者编译过程中创建的临时文件等。在这种情况下,我们可以在工作目录中创建一个名为.gitignore的文件(文件名称固定) ,列出要忽略的文件模式。下面是一个示例:</p>
<p>windows下无法直接创建.gitignore文件,需要通过gitbash命令:touch .gitignore创建</p>
</blockquote>
<p><img src="http://mele.cool//image-20200926103057723.png" alt="image-20200926103057723"></p>
<h3 id="1-7-查看日志记录"><a href="#1-7-查看日志记录" class="headerlink" title="1.7 查看日志记录"></a>1.7 查看日志记录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过回车分页查看 退出输入q</span></span><br><span class="line">git log</span><br></pre></td></tr></table></figure>
<h3 id="1-8-远程仓库"><a href="#1-8-远程仓库" class="headerlink" title="1.8 远程仓库"></a>1.8 远程仓库</h3><ul>
<li><p><strong>查看远程仓库</strong><br>如果想查看已经配置的远程仓库服务器,可以运行<code>git remote</code>命令,显示和本地仓库已经关联的远程仓库。它会列出指定的每一个远程服务器的简写。<br>如果已经克隆了远程仓库,那么至少应该能看到origin,这是Git克隆的仓库服务器的默认名字</p>
<p>git remote -v 显示更多信息</p>
</li>
<li><p><strong>添加远程仓库</strong></p>
<p>一个本地仓库可以绑定多个远程仓库</p>
<p>git remote add <shortname> <url>   shortname远程仓库简称</p>
<p>Eg: git remote add origin <a target="_blank" rel="noopener" href="https://gitee/">https://gitee</a>. com/ChuanzhiBoKe/repo1.git</p>
</li>
<li><p><strong>移除远程仓库</strong></p>
<p>如果因为一些原因想要移除一个远程仓库,可以使用<code>git remote rm 远程仓库简称</code></p>
<p>注意:此命令只是从本地移除远程仓库的记录,并不会真正影响到远程仓库</p>
</li>
<li><p><strong>抓取和拉取</strong></p>
<ul>
<li>git fetch是从远程仓库获取最新版本到本地仓库,不会自动merge</li>
</ul>
<blockquote>
<p>执行完git fetch后会把远程仓库文件以二进制形式存储到.git中,并不会主动合并到工作区,还需要手动合并:</p>
<p>git merge origin/master  (origin/master会在git fetch后显示)</p>
</blockquote>
<ul>
<li><p>git pull是从远程仓库获取最新版本并merge到本地仓库</p>
<blockquote>
<p>注意:如果当前本地仓库不是从远程仓库克隆,而是本地创建的仓库,并且仓库中存在文件,此时再从远程仓库拉取文件(<strong>git pull origin master</strong>)的时候会报错(fatal:refusing to merge unrelated histories ) ,</p>
<p>解决此问题可以在git pull命令后加入参数**-allow-unrelated-histories**</p>
<p>然后会让输入日志.保存即可.</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>推送到远程仓库</strong></p>
<p>​    git push origin master</p>
<blockquote>
<p>只有把文件加入暂存区才可加到本地仓库,如果想一步完成:</p>
<p>git commit -a -m “提交日志”</p>
</blockquote>
</li>
</ul>
<h3 id="1-9-git分支"><a href="#1-9-git分支" class="headerlink" title="1.9 git分支"></a>1.9 git分支</h3><ul>
<li>查看分支:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">列出所有本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"><span class="meta">#</span><span class="bash">列出所有远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br><span class="line"><span class="meta">#</span><span class="bash">列出所有本地分支和远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建分支</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建分支 (在当前分支基础上创建)</span></span><br><span class="line">git branch 分支名称</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换分支</span></span><br><span class="line">git checkout 分支名称</span><br></pre></td></tr></table></figure>
<ul>
<li>推送本地分支至远程分支</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin 本地分支名称</span><br></pre></td></tr></table></figure>
<ul>
<li><p>合并分支</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在master分支下操作此命令,表示把b1分支合并到master</span></span><br><span class="line">git merge b1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 有时候合并操作不会如此顺利。如果你在两个不同的分支中,对同一个文件的同一个部分进行了不同的修改, Git就没办法合并它们,同时会提示文件冲突。此时需要我们打开冲突的文件并修复冲突内容,最后执行git add命令来标识中突已解决</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 步骤如下</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1 git merge b1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2 提示冲突,手动解决冲突</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3 git add</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4 git commit -m <span class="string">&quot;解决冲突日志&quot;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>新增文件推送到远程分支</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin 远程分支名称		</span><br></pre></td></tr></table></figure>
<ul>
<li><p>删除本地分支</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除本地分支 不会影响远程分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果要删除的分支中进行了一些开发动作,此时执行上面的删除命令并不会删除分支,如果坚持要删除此分支,可以将命令中的一d参数改为-D</span></span><br><span class="line">git branch -d 本地分支名称</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
<li><p>删除远程分支</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin -d branchName</span><br></pre></td></tr></table></figure>
<h3 id="1-10-git标签"><a href="#1-10-git标签" class="headerlink" title="1.10 git标签"></a>1.10 git标签</h3></li>
</ul>
<blockquote>
<p>像其他版本控制系统(VCS)一样, Git可以给历史中的某一个提交打上标签,以示重要。比较有代表性的是人们会使用这个功能来标记发布结点(v1.0,v1.2等) 。标签指的是某个分支某个特定时间点的状态。通过标签,可以很方便的切换到标记时的状态。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有标签</span></span><br><span class="line">git tag</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建标签 v0,1是标签名</span></span><br><span class="line">git tag v0.1  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看tag信息 比较详细</span></span><br><span class="line">git show 标签名</span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送标签到远程仓库</span></span><br><span class="line">git push origin 标签名</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">检出标签</span></span><br><span class="line"><span class="meta">#</span><span class="bash">新建一个分支，指向某个tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [新分支名] [标签名]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如:git checkout -b b3 v1.0 表示创建一个b3分支,其代码状态就是v1.0标签时的代码状态</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除本地标签</span></span><br><span class="line">git tag -d 本地标签名</span><br><span class="line"><span class="meta">#</span><span class="bash">删除远程标签</span></span><br><span class="line">git push origin:refs/tags/远程标签名</span><br></pre></td></tr></table></figure>
<h2 id="2-TortoiseGit"><a href="#2-TortoiseGit" class="headerlink" title="2. TortoiseGit"></a>2. TortoiseGit</h2><p>TortoiseGit是一款开源的Git图形界面工具,使用TortoiseGit可以简化Git相关的操作(本质上还是执行的Git相关命令)<br>TortoiseGit下载地址: <a target="_blank" rel="noopener" href="https://tortoisegit.org/download/">https://tortoisegit.org/download/</a></p>
<h2 id="3-IDEA使用git"><a href="#3-IDEA使用git" class="headerlink" title="3.IDEA使用git"></a>3.IDEA使用git</h2><h2 id="4-SSH协议配置"><a href="#4-SSH协议配置" class="headerlink" title="4.SSH协议配置"></a>4.SSH协议配置</h2><blockquote>
<h3 id="可以使用Git提供的命令行工具Git-Bash生成公钥和私钥-具体操作过程如下"><a href="#可以使用Git提供的命令行工具Git-Bash生成公钥和私钥-具体操作过程如下" class="headerlink" title="可以使用Git提供的命令行工具Git Bash生成公钥和私钥,具体操作过程如下:"></a>可以使用Git提供的命令行工具Git Bash生成公钥和私钥,具体操作过程如下:</h3></blockquote>
<h3 id="1、使用命令ssh-keygen-trsa生成公钥和私钥-执行完成后在windows本地用户-ssh目录-C-Users-用户名-ssh-下面生成公钥和私钥"><a href="#1、使用命令ssh-keygen-trsa生成公钥和私钥-执行完成后在windows本地用户-ssh目录-C-Users-用户名-ssh-下面生成公钥和私钥" class="headerlink" title="1、使用命令ssh-keygen-trsa生成公钥和私钥,执行完成后在windows本地用户.ssh目录:  C:\Users\用户名\.ssh 下面生成公钥和私钥"></a>1、使用命令ssh-keygen-trsa生成公钥和私钥,执行完成后在windows本地用户.ssh目录:  C:\Users\用户名\.ssh 下面生成公钥和私钥</h3><h3 id="2-把公钥内容复制到服务器"><a href="#2-把公钥内容复制到服务器" class="headerlink" title="2.把公钥内容复制到服务器"></a>2.把公钥内容复制到服务器</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/02/git/" data-id="ckke5nr34000tcl8gfi9y056j" data-title="git" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-mybaby" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/02/mybaby/" class="article-date">
  <time class="dt-published" datetime="2020-12-02T14:56:17.000Z" itemprop="datePublished">2020-12-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mele/">mele</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/02/mybaby/">mybaby</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>安静的美女子</p>
</blockquote>
<p><img src="http://mele.cool//UZJeSA.jpg" alt="UZJeSA.jpg"></p>
<hr>
<blockquote>
<p>认识下我的朋友们</p>
</blockquote>
<p><img src="http://mele.cool//UZJAFe.jpg" alt="UZJAFe.jpg"></p>
<hr>
<blockquote>
<p>我是采蘑菇的小村姑</p>
</blockquote>
<p><img src="http://mele.cool//UZJEJH.jpg" alt="UZJEJH.jpg"></p>
<hr>
<blockquote>
<blockquote>
<p>困不行了 我先眯会儿</p>
</blockquote>
<p><img src="http://mele.cool//UZJFoD.jpg" alt="UZJFoD.jpg"></p>
</blockquote>
<hr>
<blockquote>
<p>换个姿势 继续怡然自得</p>
</blockquote>
<p><img src="http://mele.cool//UZJnyt.jpg" alt="UZJVWd.jpg"></p>
<hr>
<p><img src="http://mele.cool//image-20201202215542476.png" alt="image-20201202215542476"></p>
<hr>
<p><img src="http://mele.cool//UZJuOP.jpg" alt="UZJuOP.jpg"></p>
<p><img src="http://mele.cool//image-20201202215621333.png" alt="image-20201202215621333"></p>
<hr>
<p><img src="http://mele.cool//image-20201202215507460.png" alt="image-20201202215507460"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/02/mybaby/" data-id="ckke5nr360011cl8ghhw79wsj" data-title="mybaby" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/baby/" rel="tag">baby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/photo/" rel="tag">photo</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-redis入门" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/02/redis%E5%85%A5%E9%97%A8/" class="article-date">
  <time class="dt-published" datetime="2020-12-02T14:56:17.000Z" itemprop="datePublished">2020-12-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/db/">db</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/02/redis%E5%85%A5%E9%97%A8/">redis入门</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-redis简介"><a href="#1-redis简介" class="headerlink" title="1.redis简介"></a>1.redis简介</h1><h2 id="1-1-nosql"><a href="#1-1-nosql" class="headerlink" title="1.1 nosql"></a>1.1 nosql</h2><p><strong>NoSQL</strong>:即Not-Only SQL (泛指非关系型的数据库) ,作为关系型数据库的补充。<br><strong>作用</strong>:应对基于海量用户和海量数据前提下的数据处理问题。</p>
<p><strong>特征:</strong></p>
<ul>
<li>可扩容,可伸缩</li>
<li>大数据量下高性能</li>
<li>灵活的数据模型</li>
<li>高可用</li>
</ul>
<p><img src="http://mele.cool//image-20200927205857241.png" alt="image-20200927205857241"></p>
<h2 id="1-2-redis"><a href="#1-2-redis" class="headerlink" title="1.2 redis"></a>1.2 redis</h2><p><strong>概念</strong>: Redis (REmote DIctionary Server)是用C语言开发的一个开源的高性能键值对(key-value)数据库。</p>
<p><strong>特征：</strong></p>
<p>1,数据间没有必然的关联关系</p>
<p>2,内部采用单线程机制进行工作</p>
<p>3,高性能。官方提供测试数据, 50个并发执行100000个请求读的速度是110000/,写的速度是81000次/s。</p>
<p>4,多数据类型支持</p>
<ul>
<li>​    字符串类型 string</li>
<li>​    列表类型 list</li>
<li>​    散列类型 hash</li>
<li>​    集合类型 set </li>
<li>​    有序集合类型 sorted set</li>
</ul>
<p>5,持久化支持。可以进行数据灾难恢复</p>
<p><strong>默认端口</strong>:6379</p>
<h1 id="2-redis基本操作"><a href="#2-redis基本操作" class="headerlink" title="2.redis基本操作"></a>2.redis基本操作</h1><p>功能性命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置信息</span></span><br><span class="line">set key value</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取信息 如果不存在返回nil</span></span><br><span class="line">get key</span><br></pre></td></tr></table></figure>
<p>清除屏幕信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure>
<p>帮助信息查阅</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">help 命令</span><br><span class="line">eg: help set</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看群组命令</span></span><br><span class="line">help @组名</span><br></pre></td></tr></table></figure>
<p>退出指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br><span class="line">exit</span><br><span class="line">&lt;ESC&gt;</span><br></pre></td></tr></table></figure>
<h1 id="3-redis数据类型"><a href="#3-redis数据类型" class="headerlink" title="3.redis数据类型"></a>3.redis数据类型</h1><h2 id="3-1-string"><a href="#3-1-string" class="headerlink" title="3.1 string"></a>3.1 string</h2><h3 id="3-1-1-简介"><a href="#3-1-1-简介" class="headerlink" title="3.1.1 简介"></a>3.1.1 简介</h3><ul>
<li>存储的数据:单个数据,最简单的数据存储类型,也是最常用的数据存储类型</li>
<li>存储数据的格式:一个存储空间保存一个数据</li>
<li>存储内容:通常使用字符串,如果字符串以整数的形式展示,可以作为数字操作使用</li>
</ul>
<h3 id="3-1-2-常用命令"><a href="#3-1-2-常用命令" class="headerlink" title="3.1.2 常用命令"></a>3.1.2 常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">添加/修改数据</span></span><br><span class="line">set key value</span><br><span class="line"><span class="meta">#</span><span class="bash">获取数据</span></span><br><span class="line">get key</span><br><span class="line"><span class="meta">#</span><span class="bash">删除数据</span></span><br><span class="line">del key</span><br><span class="line"><span class="meta">#</span><span class="bash">添加/修改多个数据</span></span><br><span class="line">mset keyl valuel key2 value2...</span><br><span class="line"><span class="meta">#</span><span class="bash">获取多个数据</span></span><br><span class="line">mget keyl key2...</span><br><span class="line"><span class="meta">#</span><span class="bash">获取数据字符个数(字符串长度)</span></span><br><span class="line">strlen key</span><br><span class="line"><span class="meta">#</span><span class="bash">追加信息到原始信息后部(如果原始信息存在就追加,否则新建)</span></span><br><span class="line">append key value</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">设置数值数据增加指定范围的值</span></span><br><span class="line"><span class="meta">#</span><span class="bash">增加一个数值</span></span><br><span class="line">incr key</span><br><span class="line"><span class="meta">#</span><span class="bash">增加一个给定的值 eg:incrby count 20 表示增加20  increment可正可负</span></span><br><span class="line">incrby key increment </span><br><span class="line"><span class="meta">#</span><span class="bash">增加一个给定的值 专门操作小数</span></span><br><span class="line">inczbyfloat key increment</span><br><span class="line"><span class="meta">#</span><span class="bash">设置数值数据减少指定范围的值</span></span><br><span class="line"><span class="meta">#</span><span class="bash">减少一个数值</span></span><br><span class="line">decr key</span><br><span class="line"><span class="meta">#</span><span class="bash">减少一个给定的值 increment可正可负</span></span><br><span class="line">decrby key increment</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-1-3-作为数值操作"><a href="#3-1-3-作为数值操作" class="headerlink" title="3.1.3 作为数值操作"></a>3.1.3 作为数值操作</h3><blockquote>
<p><strong>string作为数值操作</strong></p>
<ul>
<li>string在redis内部存储默认就是一个字符串,当遇到增减类操作incr, decr时会转成教值型进行计算。</li>
<li>redis所有的操作都是原子性的，采用单线程处理所有业务,命令是一个一个执行的,因此无需考虑并发带来的数据影响。</li>
<li>注意:按数值进行操作的数据,如果原始数据不能转成教值,或超越了redis数值上限范围,将报错。<br>9223372036854775807 (java+long型数据最大值, Long.MAX VALUE)</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Tips :</strong></p>
<p>redis用于控制数据库表主键id,为数据库表主键提供生成策略,保障数据库表的主键唯一性</p>
<p>此方案适用于所有数据库,且支持数据库集群</p>
</blockquote>
<h3 id="3-1-4-设置生命周期"><a href="#3-1-4-设置生命周期" class="headerlink" title="3.1.4 设置生命周期"></a>3.1.4 设置生命周期</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设置数据具有指定的生命周期</span><br><span class="line"><span class="meta">#</span><span class="bash"> 秒 eg:setex news_id 10 1 设置news_id有效期10秒内值为1</span></span><br><span class="line">setex key seconds value </span><br><span class="line"><span class="meta">#</span><span class="bash"> 毫秒</span></span><br><span class="line">psetex key milliseconds value</span><br></pre></td></tr></table></figure>
<p><img src="http://mele.cool//image-20200927214504613.png" alt="image-20200927214504613"></p>
<h2 id="3-2-hash"><a href="#3-2-hash" class="headerlink" title="3.2 hash"></a>3.2 hash</h2><blockquote>
<ul>
<li>新的存储需求:对一系列存储的数据进行编组,方便管理,典型应用存储对象信息</li>
<li>需要的存储结构：一个存储空间保存多个键值对数据</li>
<li>hash类型:底层使用哈希表结构实现数据存储</li>
</ul>
</blockquote>
<p><img src="http://mele.cool//image-20200928205758769.png" alt="image-20200928205758769"></p>
<blockquote>
<p><strong>hash存储结构优化</strong></p>
<ul>
<li>如果field数量较少,存储结构优化为类数组结构</li>
<li>如果field数量较多,存储结构使用HashMap结构</li>
</ul>
</blockquote>
<h3 id="3-2-1-基本操作"><a href="#3-2-1-基本操作" class="headerlink" title="3.2.1 基本操作"></a>3.2.1 基本操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">添加/修改数据</span></span><br><span class="line">hset key field value</span><br><span class="line"><span class="meta">#</span><span class="bash">获取数据</span></span><br><span class="line">hget key fiely</span><br><span class="line">hgetall key</span><br><span class="line"><span class="meta">#</span><span class="bash">删除数据</span></span><br><span class="line">hdel key fieldl [field2]</span><br><span class="line"><span class="meta">#</span><span class="bash">添加/修改多个数据</span></span><br><span class="line">hmset key fieldl valuel field2 value2</span><br><span class="line"><span class="meta">#</span><span class="bash">获取多个数据</span></span><br><span class="line">hmget key fieldl field2...</span><br><span class="line"><span class="meta">#</span><span class="bash">获取哈希表中字段的数量</span></span><br><span class="line">hlen key</span><br><span class="line"><span class="meta">#</span><span class="bash">获取哈希表中是否存在指定的字段</span></span><br><span class="line">hexists key field</span><br></pre></td></tr></table></figure>
<h3 id="3-2-2-扩展操作"><a href="#3-2-2-扩展操作" class="headerlink" title="3.2.2 扩展操作"></a>3.2.2 扩展操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">获取哈希表中所有的字段名或字段值 列表</span></span><br><span class="line">hkeys key</span><br><span class="line">hvals key</span><br><span class="line"><span class="meta">#</span><span class="bash">设置指定字段的数值数据增加指定范围的值</span></span><br><span class="line">hincrby key field increment </span><br><span class="line">hincrbyfloat key field increment</span><br></pre></td></tr></table></figure>
<h3 id="3-2-3-hash类型数据操作的注意事项"><a href="#3-2-3-hash类型数据操作的注意事项" class="headerlink" title="3.2.3 hash类型数据操作的注意事项"></a>3.2.3 hash类型数据操作的注意事项</h3><ul>
<li>hash类型下的value只能存储字符串,不允许存储其他数据类型,不存在嵌套现象。如果数据未获取到,对应的值为(nil)</li>
<li>每个hash可以存储2^32-1个键值对</li>
<li>hash类型十分贴近对象的数据存储形式,并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的,切记不可滥用,更不可以将hash作为对象列表使用</li>
<li>hgetall操作可以获取全部属性,如果内部field过多,遍历整体数据效率就很会低,有可能成为数据访问瓶颈</li>
</ul>
<h3 id="3-2-4-hash应用场景"><a href="#3-2-4-hash应用场景" class="headerlink" title="3.2.4 hash应用场景"></a>3.2.4 hash应用场景</h3><h4 id="3-2-4-1-购物车"><a href="#3-2-4-1-购物车" class="headerlink" title="3.2.4.1 购物车"></a>3.2.4.1 购物车</h4><p><img src="http://mele.cool//image-20200928211238742.png" alt="image-20200928211238742"></p>
<p><strong>解决方案</strong></p>
<ul>
<li>以客户id作为key,每位客户创建一个hash存储结构存储对应的购物车信息</li>
<li>将商品编号作为field,购买数量作为value进行存储</li>
<li>添加商品：追加全新的field与value</li>
<li>浏览:遍历hash</li>
<li>更改数量:自增/自减,设置value值</li>
<li>删除商品:删除field</li>
<li>清空:删除key</li>
</ul>
<p><img src="http://mele.cool//image-20200928212526832.png" alt="image-20200928212526832"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> key value 值存在则不操作,不存在则插入</span></span><br><span class="line">hsetnx key field value</span><br></pre></td></tr></table></figure>
<h4 id="3-2-4-2-抢购"><a href="#3-2-4-2-抢购" class="headerlink" title="3.2.4.2 抢购"></a>3.2.4.2 抢购</h4><p><img src="http://mele.cool//image-20200928212744948.png" alt="image-20200928212744948"></p>
<p><img src="http://mele.cool//image-20200928213002052.png" alt="image-20200928213002052"></p>
<h2 id="3-3-list"><a href="#3-3-list" class="headerlink" title="3.3 list"></a>3.3 list</h2><ul>
<li>需要的存储结构:一个存储空间保存多个数据 ,且通过数据可以体现<strong>进入顺序</strong></li>
<li>list类型:保存多个数据,<strong>底层使用双向链表</strong>存储结构实现</li>
</ul>
<h3 id="3-3-1-基本操作"><a href="#3-3-1-基本操作" class="headerlink" title="3.3.1 基本操作"></a>3.3.1 基本操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">添加/修改数据</span></span><br><span class="line">lpush key valuel [value2] ....</span><br><span class="line">rpush key valuel [value2] ....</span><br><span class="line"><span class="meta">#</span><span class="bash">获取数据 start stop指索引,从0开始</span></span><br><span class="line">lrange key start stop </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看全部 -1表示最后一个索引</span></span><br><span class="line">lrange key 0 -1</span><br><span class="line">lindex key index </span><br><span class="line">llen key</span><br><span class="line"><span class="meta">#</span><span class="bash">获取并移除数据</span></span><br><span class="line">lpop key </span><br><span class="line">rpop key</span><br></pre></td></tr></table></figure>
<h3 id="3-3-2-扩展操作"><a href="#3-3-2-扩展操作" class="headerlink" title="3.3.2  扩展操作"></a>3.3.2  扩展操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">规定时间内获取并移除数据 时间单位秒 时间内能取到就取,否则就取到nil</span></span><br><span class="line">blpop keyl [key2...] timeout</span><br><span class="line">brpop keyl [key2...] timeout</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">移除指定数据 从左边删除指定key的count个value元素</span></span><br><span class="line">lrem key count value</span><br></pre></td></tr></table></figure>
<h3 id="3-3-3-list类型数据操作注意事项"><a href="#3-3-3-list类型数据操作注意事项" class="headerlink" title="3.3.3 list类型数据操作注意事项"></a>3.3.3 list类型数据操作注意事项</h3><ul>
<li>list中保存的数据都是string类型的,数据总容量是有限的,最多2^32-1个元素(4294967295)</li>
<li>list具有索引的概念,但是操作数据时通常以队列的形式进行入队出队操作,或以栈的形式进行入栈出栈操作</li>
<li>获取全部数据操作结束索引设置为-1</li>
<li>list可以对数据进行分页操作,通常第一页的信息来自于list,第2页及更多的信息通过数据库的形式加载</li>
</ul>
<h2 id="3-4-set"><a href="#3-4-set" class="headerlink" title="3.4 set"></a>3.4 set</h2><blockquote>
<p><strong>新的存储需求</strong>:存储大量的数据,在查询方面提供更高的效率<br><strong>需要的存储结构</strong>:能够保存大量的数据,高效的内部存储机制,便于查询</p>
<p><strong>set类型</strong>:与hash存储结构完全相同,仅存储键,不存储值(nil) ,并且值是不允许重复的</p>
</blockquote>
<h3 id="3-4-1-基本操作"><a href="#3-4-1-基本操作" class="headerlink" title="3.4.1 基本操作"></a>3.4.1 基本操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">添加数据</span></span><br><span class="line">sadd key member1 [member2]</span><br><span class="line"><span class="meta">#</span><span class="bash">获取全部数据</span></span><br><span class="line">smembers key</span><br><span class="line"><span class="meta">#</span><span class="bash">删除数据</span></span><br><span class="line">srem key member1 [member2]</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#获取集合数据总量</span></span></span><br><span class="line">scard key</span><br><span class="line"><span class="meta">#</span><span class="bash">判断集合中是否包含指定数据</span></span><br><span class="line">sismember key member</span><br></pre></td></tr></table></figure>
<h3 id="3-4-2-扩展操作"><a href="#3-4-2-扩展操作" class="headerlink" title="3.4.2 扩展操作"></a>3.4.2 扩展操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">随机获取集合中指定数量的数据</span></span><br><span class="line">srandmember key [count]</span><br><span class="line"><span class="meta">#</span><span class="bash">随机获取集合中的几个数据并将该数据移出集合</span></span><br><span class="line">spop key [count]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">求两个集合的交、并、差集,差集有方向性</span></span><br><span class="line">sinter keyl [key2]</span><br><span class="line">sunion keyl [key2</span><br><span class="line">sdiff keyl [key2]</span><br><span class="line"><span class="meta">#</span><span class="bash">求两个集合的交、并、差集并存储到指定集合中</span></span><br><span class="line">sinterstore destination keyl [key2] </span><br><span class="line">sunionstore destination keyl [key2] </span><br><span class="line">sdiffstore destination keyl [key2]</span><br><span class="line"><span class="meta">#</span><span class="bash">将指定数据从原始集合中移动到目标集合中</span></span><br><span class="line">smove source destination member</span><br></pre></td></tr></table></figure>
<h3 id="3-4-3-注意事项"><a href="#3-4-3-注意事项" class="headerlink" title="3.4.3 注意事项"></a>3.4.3 注意事项</h3><blockquote>
<p>set类型不允许数据重复,如果添加的数据在set中已经存在,将只保留一份</p>
<p>set虽然与hash的存储结构相同,但是无法启用hash中存储值的空间</p>
</blockquote>
<p><strong>业务场景:</strong></p>
<p>公司对旗下新的网站做推广,统计网站的PV (访问量) ,UV (独立访客) ,IP (独立IP)</p>
<ul>
<li>PV:网站被访问次数,可通过刷新页面提高访问量</li>
<li>UV:网站被不同用户访问的次数,可通过cookie统计访问量,相同用户切换P地址, UV不变IP:网站被不同IP地址访问的总次数,</li>
<li>可通过P地址统计访问量,相同IP不同用户访问, IP不变</li>
</ul>
<p><strong>解决方案:</strong></p>
<ul>
<li>利用set集合的数据去重特征,记录各种访问数据</li>
<li>建立string类型数据,利用incr统计日访问量(PV)</li>
<li>建立set模型,记录不同cookie数量(UV)</li>
<li>建立se模型,记录不同IP数量(IP)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/02/redis%E5%85%A5%E9%97%A8/" data-id="ckke5nr39001acl8ghitq9k6n" data-title="redis入门" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis-db/" rel="tag">redis - db</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-springboot整合配置pagehelper" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/02/springboot%E6%95%B4%E5%90%88%E9%85%8D%E7%BD%AEpagehelper/" class="article-date">
  <time class="dt-published" datetime="2020-12-02T14:56:17.000Z" itemprop="datePublished">2020-12-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/springboot/">springboot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/02/springboot%E6%95%B4%E5%90%88%E9%85%8D%E7%BD%AEpagehelper/">springboot整合配置pagehelper</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一-java代码配置法"><a href="#一-java代码配置法" class="headerlink" title="一.java代码配置法"></a>一.java代码配置法</h2><blockquote>
<p>　　这种方法个人感觉比较繁琐不是很推荐，而且也不怎么符合springboot的理念，但是胜在也能够用，所以就列起来，万一以后接手的代码是用这种方式的也方便自己维护。</p>
</blockquote>
<p>　　首先引入jar包。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　然后，直接在启动类里面添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 　　<span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PageHelper <span class="title">pageHelper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PageHelper pageHelper = <span class="keyword">new</span> PageHelper();</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.setProperty(<span class="string">&quot;offsetAsPageNum&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;rowBoundsWithCount&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;reasonable&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;dialect&quot;</span>,<span class="string">&quot;mysql&quot;</span>);    <span class="comment">//配置mysql数据库的方言</span></span><br><span class="line">    pageHelper.setProperties(properties);</span><br><span class="line">    <span class="keyword">return</span> pageHelper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　那么这样第一种办法就配置好了。</p>
<h2 id="二、配置文件配置法"><a href="#二、配置文件配置法" class="headerlink" title="二、配置文件配置法"></a>二、配置文件配置法</h2><p>　　第二种方法就比较简单了，而且从引入jar包的名字就能看出官方推荐的是哪种配置方式了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　引入jar包后只要在application.properties或者application.yml里面加入相关的属性配置就好了，由于个人不太喜欢yml的形式，所以就只列一下application.properties的配置。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pagehelper properties</span></span><br><span class="line"><span class="meta">pagehelper.offsetAsPageNum</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">pagehelper.rowBoundsWithCount</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">pagehelper.pageSizeZero</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">pagehelper.reasonable</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">pagehelper.params</span>=<span class="string">pageNum=pageHelperStart;pageSize=pageHelperRows;</span></span><br><span class="line"><span class="meta">pagehelper.supportMethodsArguments</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>
<p>　　而且似乎pagehelper不需要配置dialect这个属性也能正常工作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/02/springboot%E6%95%B4%E5%90%88%E9%85%8D%E7%BD%AEpagehelper/" data-id="ckke5nr3f001jcl8g55jhghqi" data-title="springboot整合配置pagehelper" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pagehelper-%E5%88%86%E9%A1%B5/" rel="tag">pagehelper - 分页</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/springboot/" rel="tag">springboot</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-springboot项目热部署" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/02/springboot%E9%A1%B9%E7%9B%AE%E7%83%AD%E9%83%A8%E7%BD%B2/" class="article-date">
  <time class="dt-published" datetime="2020-12-02T14:56:17.000Z" itemprop="datePublished">2020-12-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/springboot/">springboot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/02/springboot%E9%A1%B9%E7%9B%AE%E7%83%AD%E9%83%A8%E7%BD%B2/">springboot热部署</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>平日里开发项目中，修改了Java代码或者配置文件的时候，必须手动重启项目才能生效。所谓的热部署就是在你修改了后端代码后不需要手动重启，工具会帮你快速的自动重启是修改生效。其深层原理是使用了两个<code>ClassLoader</code>，一个<code>Classloader</code>加载那些不会改变的类（第三方Jar包），另一个<code>ClassLoader</code>加载会更改的类，称为<code>restart ClassLoader</code>，这样在有代码更改的时候，原来的<code>restart ClassLoader</code> 被丢弃，重新创建一个<code>restart ClassLoader</code>，由于需要加载的类相比较少，所以实现了较快的重启时间。</p>
<p>本文将介绍如何通过使用<code>Spring-Boot-devtools</code>来实现Spring Boot项目的热部署。IDE使用的是Eclipse<br>Oxygen，并且使用Maven构建。</p>
</blockquote>
<h2 id="1-引入Devtools"><a href="#1-引入Devtools" class="headerlink" title="1.引入Devtools"></a>1.引入Devtools</h2><p>搭建一个简单的Spring Boot项目，然后引入Spring-Boot-devtools：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>devtools会监听classpath下的文件变动，并且会立即重启应用（发生在保存时机），因为其采用的虚拟机机制，该项重启是很快的。</p>
<p>在Eclipse中生效还需要修改<code>spring-boot-maven-plugin</code>插件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>并且开启Build Automatically：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20180523094924.png" alt="QQ截图20180523094924.png"></p>
<h2 id="2-测试热部署"><a href="#2-测试热部署" class="headerlink" title="2.测试热部署"></a>2.测试热部署</h2><p>在入口类中添加一个方法，用于热部署测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello spring boot&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>启动项目访问<a target="_blank" rel="noopener" href="http://localhost:8080/%EF%BC%8C%E9%A1%B5%E9%9D%A2%E8%BE%93%E5%87%BAhello">http://localhost:8080/，页面输出hello</a> spring boot。</p>
<p>将方法的返回值修改为hello world并在保存的瞬间，应用便重启好了，刷新页面，内容也将得到更改。</p>
<h2 id="3-所有配置"><a href="#3-所有配置" class="headerlink" title="3.所有配置"></a>3.所有配置</h2><p>下面是所有Devtools在Spring Boot中的可选配置:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Whether to enable a livereload.com-compatible server.</span></span><br><span class="line"><span class="meta">spring.devtools.livereload.enabled</span>=<span class="string">true </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Server port.</span></span><br><span class="line"><span class="meta">spring.devtools.livereload.port</span>=<span class="string">35729 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Additional patterns that should be excluded from triggering a full restart.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.additional-exclude</span>= <span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Additional paths to watch for changes.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.additional-paths</span>= <span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Whether to enable automatic restart.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.enabled</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Patterns that should be excluded from triggering a full restart.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.exclude</span>=<span class="string">META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties,META-INF/build-info.properties</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Whether to log the condition evaluation delta upon restart.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.log-condition-evaluation-delta</span>=<span class="string">true </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Amount of time to wait between polling for classpath changes.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.poll-interval</span>=<span class="string">1s </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Amount of quiet time required without any classpath changes before a restart is triggered.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.quiet-period</span>=<span class="string">400ms </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Name of a specific file that, when changed, triggers the restart check. If not specified, any classpath file change triggers the restart.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.trigger-file</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>


<p>源码链接：<a target="_blank" rel="noopener" href="https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/24.Spring-Boot-Devtools">https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/24.Spring-Boot-Devtools</a></p>
<p>From:  <a target="_blank" rel="noopener" href="https://mrbird.cc/Spring-Boot-Devtools.html">MyBird</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/02/springboot%E9%A1%B9%E7%9B%AE%E7%83%AD%E9%83%A8%E7%BD%B2/" data-id="ckke5nr3i001qcl8gajffce1s" data-title="springboot热部署" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/springboot/" rel="tag">springboot</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/" rel="tag">热部署</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-rabbitmq" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/02/rabbitmq/" class="article-date">
  <time class="dt-published" datetime="2020-12-02T14:56:17.000Z" itemprop="datePublished">2020-12-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mq/">mq</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/02/rabbitmq/">rabbitmq</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-消息队列概述"><a href="#1-消息队列概述" class="headerlink" title="1.消息队列概述"></a>1.消息队列概述</h1><p>MQ:Message Queue,消息队列是应用程序与应用程序之间的通信方法.</p>
<h2 id="1-1为什么使用MQ"><a href="#1-1为什么使用MQ" class="headerlink" title="1.1为什么使用MQ"></a>1.1为什么使用MQ</h2><p>在项目中,可将一些无需即时返回且耗时的操作提取出来,进行异步处理,而这种异步处理的方式大大的节省了服务器的请求响应时间,从而提高了系统的吞吐量。</p>
<h2 id="1-2-开发中消息队列通常有如下应用场景"><a href="#1-2-开发中消息队列通常有如下应用场景" class="headerlink" title="1.2 开发中消息队列通常有如下应用场景:"></a>1.2 开发中消息队列通常有如下应用场景:</h2><p>1、任务异步处理<br>将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。<br>2、应用程序解耦合<br>MQ相当于一个中介,生产方通过MQ与消费方交互,它将应用程序进行解耦合。</p>
<p><strong>MQ是消息通信的模型;实现MQ的大致有两种主流方式: AMQP, JMS.</strong></p>
<blockquote>
<p>AMQP是一种协议,更准确的说是一种binary wirelevel protocol (链接协议) 。这是其和JMS的本质差别, AMQP不从API层进行限定,而是直接定义网络交换的数据格式。  </p>
<p>JMS即Java消息服务JavaMessage Service)应用程序接口,是一个<strong>java平台</strong>关于面向消息中间件(MOM)的API,用于在两个应用程序之间,或分布式系统中发送消息,进行异步通信。</p>
</blockquote>
<h2 id="1-3-AMQP与JMS区别"><a href="#1-3-AMQP与JMS区别" class="headerlink" title="1.3 AMQP与JMS区别"></a>1.3 AMQP与JMS区别</h2><ul>
<li>JMS是定义了统一的接口,来对消息操作进行统一; AMQP是通过规定协议来统一数据交互的格式JMS限定了必须使用ava语言; </li>
<li>AMQP只是协议,不规定实现方式,因此是跨语言的。</li>
<li>JMS规定了两种消息模式;而AMQP的消息模式更加丰富</li>
</ul>
<h1 id="2-mac安装rabbitmq"><a href="#2-mac安装rabbitmq" class="headerlink" title="2.mac安装rabbitmq"></a>2.mac安装rabbitmq</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">1[安装rabbitmq] --&gt; 2[安装rabbitmq可视化监控插件]--&gt;3[配置环境变量]--&gt;4[后台启动rabbitmq]</span><br></pre></td></tr></table></figure>
<h2 id="2-1brew-install-rabbitmq"><a href="#2-1brew-install-rabbitmq" class="headerlink" title="2.1brew install rabbitmq"></a>2.1brew install rabbitmq</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">==&gt; Installing rabbitmq</span><br><span class="line">==&gt; Downloading https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.3/rabbitmq-server-generic-unix-3.8.3.tar.xz</span><br><span class="line">==&gt; Downloading from https://github-production-release-asset-2e65be.s3.amazonaws.com/924551/9b363b00-6236-11ea-964e-aebcb201484a?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAIW</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################### 100.0%</span></span></span><br><span class="line">==&gt; /usr/bin/unzip -qq -j /usr/local/Cellar/rabbitmq/3.8.3/plugins/rabbitmq_management-3.8.3.ez rabbitmq_management-3.8.3/priv/www/cli/rabbitmqadmin</span><br><span class="line">==&gt; Caveats</span><br><span class="line">Management Plugin enabled by default at http://localhost:15672</span><br><span class="line"></span><br><span class="line">Bash completion has been installed to:</span><br><span class="line">  /usr/local/etc/bash_completion.d</span><br><span class="line"></span><br><span class="line">To have launchd start rabbitmq now and restart at login:</span><br><span class="line">  brew services start rabbitmq</span><br><span class="line">Or, if you don&#x27;t want/need a background service you can just run:</span><br><span class="line">  rabbitmq-server</span><br><span class="line">==&gt; Summary</span><br><span class="line">🍺  /usr/local/Cellar/rabbitmq/3.8.3: 281 files, 20.4MB, built in 1 minute 10 seconds</span><br></pre></td></tr></table></figure>
<h2 id="2-2安装rabbitmq可视化监控插件"><a href="#2-2安装rabbitmq可视化监控插件" class="headerlink" title="2.2安装rabbitmq可视化监控插件"></a>2.2安装rabbitmq可视化监控插件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boguotong:~ boguotong$ cd /usr/local/Cellar/rabbitmq/3.8.3/</span><br><span class="line">boguotong:3.8.3 boguotong$ sudo sbin/rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>
<h2 id="2-3配置环境变量"><a href="#2-3配置环境变量" class="headerlink" title="2.3配置环境变量"></a>2.3配置环境变量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line"> //加入以下两行</span><br><span class="line">export RABBIT_HOME=/usr/local/Cellar/rabbitmq/3.8.3/sbin/</span><br><span class="line">export PATH=$CXF3:$JAVA_HOME:$PATH:$SAPJCO:$JETTY_HOME:$PYTHON_HOME:$RABBIT_HOME</span><br><span class="line"> // 立即生效</span><br><span class="line"> source /etc/profile</span><br></pre></td></tr></table></figure>
<h2 id="2-4后台启动rabbitmq"><a href="#2-4后台启动rabbitmq" class="headerlink" title="2.4后台启动rabbitmq"></a>2.4后台启动rabbitmq</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 后台启动</span><br><span class="line">sudo rabbitmq-server -detached  </span><br><span class="line">// 查看状态</span><br><span class="line">rabbitmqctl status </span><br><span class="line">// 访问可视化监控插件的界面</span><br><span class="line">// 浏览器内输入 http://localhost:15672,默认的用户名密码都是guest,登录后可以在Admin那一列菜单内添加自己的用户</span><br><span class="line">rabbitmqctl stop 关闭</span><br></pre></td></tr></table></figure>
<h1 id="3-创建工程"><a href="#3-创建工程" class="headerlink" title="3.创建工程"></a>3.创建工程</h1><blockquote>
<p>入门工程:生产者发送消息到RabbitMQ的队列(simple-queue ) ;消费者可以从队列中获取消息。可以使用Rab<br>RabbitMQ的简单模式( simple )</p>
</blockquote>
<h2 id="3-1-引入依赖"><a href="#3-1-引入依赖" class="headerlink" title="3.1 引入依赖"></a>3.1 引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-2编写生产者代码发送消息到mq"><a href="#3-2编写生产者代码发送消息到mq" class="headerlink" title="3.2编写生产者代码发送消息到mq"></a>3.2编写生产者代码发送消息到mq</h2><blockquote>
<p>在设置连接工厂的时候;如果没有指定连接的参数则会有默认值;可以去设置虚拟主机,实际业务中一般根据不同的业务设置不同的虚拟主机. </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bgt.rabbitmq.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Package: com.bgt.rabbitmq.controller</span></span><br><span class="line"><span class="comment"> * Description： 消息生产者</span></span><br><span class="line"><span class="comment"> * Author: bgt</span></span><br><span class="line"><span class="comment"> * Date: Created in 2020/9/19 5:27 下午</span></span><br><span class="line"><span class="comment"> * Company:</span></span><br><span class="line"><span class="comment"> * Copyright:</span></span><br><span class="line"><span class="comment"> * Version: 0.0.1</span></span><br><span class="line"><span class="comment"> * Modified By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//        1,创建连接工厂(设置RabbitMQ的连接参数) ;</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"><span class="comment">//        2.创建连接;</span></span><br><span class="line">        <span class="comment">//主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"><span class="comment">//        3.创建频道;</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"><span class="comment">//        4.声明队列;</span></span><br><span class="line"><span class="comment">//        参数1:队列名称</span></span><br><span class="line"><span class="comment">//        参数2:是否定义持久化队列(消息会持久化保存在服务器上)</span></span><br><span class="line"><span class="comment">//        参数3:是否独占本连接</span></span><br><span class="line"><span class="comment">//        参数4:是否在不使用的时候队列自动删除</span></span><br><span class="line"><span class="comment">//        参数5:其它参数</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;simple-queue&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//        5.发送消息;</span></span><br><span class="line">        String msg = <span class="string">&quot;你好,我的mq!&quot;</span>;</span><br><span class="line"><span class="comment">//        参数1:交换机名称；如果没有则指定空字符串(表示使用默认的交换机)</span></span><br><span class="line"><span class="comment">//        参数2:路由key,简单模式中可以使用队列名称</span></span><br><span class="line"><span class="comment">//        参数3:消息其它属性</span></span><br><span class="line"><span class="comment">//        参数4:消息内容</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,<span class="string">&quot;simple-queue&quot;</span>,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line"><span class="comment">//        6.关闭资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-3-编写消费者代码接收消息"><a href="#3-3-编写消费者代码接收消息" class="headerlink" title="3.3 编写消费者代码接收消息"></a>3.3 编写消费者代码接收消息</h2><blockquote>
<p>消费者需要持续监听队列消息,所以不要关闭资源</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bgt.rabbitmq.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Package: com.bgt.rabbitmq.simple</span></span><br><span class="line"><span class="comment"> * Description： 简单模式 消费者接收消息</span></span><br><span class="line"><span class="comment"> * Author: bgt</span></span><br><span class="line"><span class="comment"> * Date: Created in 2020/9/19 7:53 下午</span></span><br><span class="line"><span class="comment"> * Company:</span></span><br><span class="line"><span class="comment"> * Copyright:</span></span><br><span class="line"><span class="comment"> * Version: 0.0.1</span></span><br><span class="line"><span class="comment"> * Modified By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 1,创建连接工厂(设置RabbitMQ的连接参数) ;</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"><span class="comment">//        2.创建连接;</span></span><br><span class="line">        <span class="comment">//主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"><span class="comment">//        3.创建频道;</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"><span class="comment">//        4.声明队列;</span></span><br><span class="line"><span class="comment">//        参数1:队列名称</span></span><br><span class="line"><span class="comment">//        参数2:是否定义持久化队列(消息会持久化保存在服务器上)</span></span><br><span class="line"><span class="comment">//        参数3:是否独占本连接</span></span><br><span class="line"><span class="comment">//        参数4:是否在不使用的时候队列自动删除</span></span><br><span class="line"><span class="comment">//        参数5:其它参数</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;simple-queue&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//        5.创建消费者接收并处理消息</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//路由key 交换机 消息id 接受到的消息</span></span><br><span class="line">                System.out.println(envelope.getRoutingKey());</span><br><span class="line">                System.out.println(envelope.getExchange());</span><br><span class="line">                System.out.println(envelope.getDeliveryTag());</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(body,<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//6 监听队列</span></span><br><span class="line"><span class="comment">//        参数1:队列名</span></span><br><span class="line"><span class="comment">//        参数2:是否要自动确认;设置为true表示消息接收到自动向MQ回复接收到了, MQ则会将消息从队列中删除;</span></span><br><span class="line"><span class="comment">//        如果设置为false则需要手动确认</span></span><br><span class="line"><span class="comment">//        参数3:消费者</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;simple-queue&quot;</span>,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-4-测试"><a href="#3-4-测试" class="headerlink" title="3.4 测试"></a>3.4 测试</h2><p><img src="http://mele.cool//image-20200919200926479.png" alt="image-20200919200926479"></p>
<h1 id="4-RabbitMQ工作模式"><a href="#4-RabbitMQ工作模式" class="headerlink" title="4.RabbitMQ工作模式"></a>4.RabbitMQ工作模式</h1><h2 id="4-1work-queue工作队列模式"><a href="#4-1work-queue工作队列模式" class="headerlink" title="4.1work queue工作队列模式"></a>4.1work queue工作队列模式</h2><blockquote>
<p>work queues与入门程序的简单模式相比,多了一个或一些消费端,多个消费端共同消费同一个队列中的消息(竞争关系)。</p>
</blockquote>
<p>应用场景: 可以在消费者端处理任务比较耗时的时候;添加对同一个队列的消费者来提高任务处理能力。</p>
<h3 id="4-1-1-生产者循环发送三十条消息"><a href="#4-1-1-生产者循环发送三十条消息" class="headerlink" title="4.1.1 生产者循环发送三十条消息"></a>4.1.1 生产者循环发送三十条消息</h3><h3 id="4-1-2-编写两个消费者"><a href="#4-1-2-编写两个消费者" class="headerlink" title="4.1.2 编写两个消费者"></a>4.1.2 编写两个消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bgt.rabbitmq.workqueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Package: com.bgt.rabbitmq.simple</span></span><br><span class="line"><span class="comment"> * Description： 简单模式 消费者接收消息</span></span><br><span class="line"><span class="comment"> * Author: bgt</span></span><br><span class="line"><span class="comment"> * Date: Created in 2020/9/19 7:53 下午</span></span><br><span class="line"><span class="comment"> * Company:</span></span><br><span class="line"><span class="comment"> * Copyright:</span></span><br><span class="line"><span class="comment"> * Version: 0.0.1</span></span><br><span class="line"><span class="comment"> * Modified By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqConsumer1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 1,创建连接工厂(设置RabbitMQ的连接参数) ;</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"><span class="comment">//        2.创建连接;</span></span><br><span class="line">        <span class="comment">//主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"><span class="comment">//        3.创建频道;</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"><span class="comment">//        4.声明队列;</span></span><br><span class="line"><span class="comment">//        参数1:队列名称</span></span><br><span class="line"><span class="comment">//        参数2:是否定义持久化队列(消息会持久化保存在服务器上)</span></span><br><span class="line"><span class="comment">//        参数3:是否独占本连接</span></span><br><span class="line"><span class="comment">//        参数4:是否在不使用的时候队列自动删除</span></span><br><span class="line"><span class="comment">//        参数5:其它参数</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;simple-queue&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每次可以预取几个消息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//        5.创建消费者接收并处理消息</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//路由key 交换机 消息id 接受到的消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;路由key:&quot;</span>+envelope.getRoutingKey());</span><br><span class="line">                System.out.println(<span class="string">&quot;交换机:&quot;</span>+envelope.getExchange());</span><br><span class="line">                System.out.println(<span class="string">&quot;消息id:&quot;</span>+envelope.getDeliveryTag());</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者1---接受到的消息:&quot;</span>+<span class="keyword">new</span> String(body,<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//确认消息</span></span><br><span class="line"><span class="comment">//                参数1:消息id</span></span><br><span class="line"><span class="comment">//                基数2: false表示只有当前这条被处理</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//6 监听队列</span></span><br><span class="line"><span class="comment">//        参数1:队列名</span></span><br><span class="line"><span class="comment">//        参数2:是否要自动确认;设置为true表示消息接收到自动向MQ回复接收到了, MQ则会将消息从队列中删除;</span></span><br><span class="line"><span class="comment">//        如果设置为false则需要手动确认</span></span><br><span class="line"><span class="comment">//        参数3:消费者</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;simple-queue&quot;</span>,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="4-1-3-测试-启动两个消费者-然后启动生产者"><a href="#4-1-3-测试-启动两个消费者-然后启动生产者" class="headerlink" title="4.1.3 测试:启动两个消费者,然后启动生产者"></a>4.1.3 测试:启动两个消费者,然后启动生产者</h3><blockquote>
<p>结论:一个消息只能被一个消费者接收.</p>
</blockquote>
<h1 id="5-订阅模式"><a href="#5-订阅模式" class="headerlink" title="5.订阅模式"></a>5.订阅模式</h1><p><img src="http://mele.cool//image-20200919204735420.png" alt="image-20200919204735420"></p>
<ul>
<li>P:生产者,也就是要发送消息的程序,但是不再发送到队列中,而是发给x (交换机)</li>
<li>C:消费者,消息的接受者,会一直等待消息到来。</li>
<li>Queue:消息队列,接收消息、缓存消息。</li>
</ul>
<p><strong>Exchange:交换机</strong>,图中的x,一方面,接收生产者发送的消息。另一方面,知道如何处理消息,例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作,取决于Exchange的类型。Exchang有常见以下3种类型:</p>
<ol>
<li> Fanout:广播,将消息交给所有绑定到交换机的队列</li>
<li> Direct:定向,把消息交给符合指定routing key的队列</li>
<li> Topic:通配符,把消息交给符合routing pattern (路由模式)的队列</li>
</ol>
<p><u>Exchange (交换机)只负责转发消息,不具备存储消息的能力,因此如果没有任何队列与Exchange绑定,或者没有符合路由规则的队列,那么消息会丢失!</u></p>
<h2 id="5-1-pulish-subscribe发布-订阅模式-广播"><a href="#5-1-pulish-subscribe发布-订阅模式-广播" class="headerlink" title="5.1.pulish/subscribe发布/订阅模式(广播)"></a>5.1.pulish/subscribe发布/订阅模式(广播)</h2><p><strong>发布与订阅模式特点</strong>:一个消息可以被多个消费者接收;其实是使用了订阅模式,交换机类型为: fanout广播,一个消费者对应一个队列,该队列只能被一个消费者监听。<br><strong>简单使用</strong>：</p>
<ul>
<li>生产者声明交换机类型为广播类型，并绑定多个队列，然后往这个交换机中发送消息；</li>
<li>消费者声明同一个交换机，并绑定这个交换机已绑定的其中一个队列，即可监听这个队列获取消息。</li>
</ul>
<h3 id="5-1-1-生产者"><a href="#5-1-1-生产者" class="headerlink" title="5.1.1 生产者"></a>5.1.1 生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bgt.rabbitmq.ps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Package: com.bgt.rabbitmq.controller</span></span><br><span class="line"><span class="comment"> * Description： 发布订阅模式  消息生产者</span></span><br><span class="line"><span class="comment"> * Author: bgt</span></span><br><span class="line"><span class="comment"> * Date: Created in 2020/9/19 5:27 下午</span></span><br><span class="line"><span class="comment"> * Company:</span></span><br><span class="line"><span class="comment"> * Copyright:</span></span><br><span class="line"><span class="comment"> * Version: 0.0.1</span></span><br><span class="line"><span class="comment"> * Modified By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//交换机</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String FANOUT_EXCHANGE=<span class="string">&quot;fanout_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String FANOUT_QUEUE1=<span class="string">&quot;fanout_queue1&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String FANOUT_QUEUE2=<span class="string">&quot;fanout_queue2&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//       1.创建连接;</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"><span class="comment">//        2.创建频道;</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//3,声明交换机;参数1:交换机名称,参数2:交换机类型( fanout, direct, topic)</span></span><br><span class="line">        channel. exchangeDeclare (FANOUT_EXCHANGE, BuiltinExchangeType.FANOUT);</span><br><span class="line">        <span class="comment">//4．声明队列；</span></span><br><span class="line">        <span class="comment">/*参数1:队列名称</span></span><br><span class="line"><span class="comment">          参数2:是否定义持久化队列(消息会持久化保存在服务器上)</span></span><br><span class="line"><span class="comment">          参数3:是否独占本连接</span></span><br><span class="line"><span class="comment">         参数4:是否在不使用的时候队列自动删除</span></span><br><span class="line"><span class="comment">         参数5:其它参数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        channel. queueDeclare (FANOUT_QUEUE1, <span class="keyword">true</span>,  <span class="keyword">false</span>,  <span class="keyword">false</span>,  <span class="keyword">null</span>);</span><br><span class="line">        channel. queueDeclare (FANOUT_QUEUE2, <span class="keyword">true</span>,  <span class="keyword">false</span>,  <span class="keyword">false</span>,  <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//      5.队列绑定到交换机 参数1:队列名称,参数2:交换机名称,参数3:路由key</span></span><br><span class="line">        channel. queueBind (FANOUT_QUEUE1, FANOUT_EXCHANGE,  <span class="string">&quot;&quot;</span>);</span><br><span class="line">        channel. queueBind (FANOUT_QUEUE2, FANOUT_EXCHANGE,  <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//6 发送消息</span></span><br><span class="line">        <span class="comment">//参数1:交换机名称;如果没有则指定空字符串(表示使用默认的交换机)参数2:路由key,简单模式中可以使用队列名称</span></span><br><span class="line">        <span class="comment">// 参数3：消息其它属性  参数4:消息内容</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++ )&#123;</span><br><span class="line">            String msg=<span class="string">&quot;hello mq.发布订阅模式--&quot;</span>+i;</span><br><span class="line">            channel.basicPublish(FANOUT_EXCHANGE,<span class="string">&quot;&quot;</span>,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;已发送消息:&quot;</span>+msg);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        6.关闭资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="5-1-2-消费者"><a href="#5-1-2-消费者" class="headerlink" title="5.1.2 消费者"></a>5.1.2 消费者</h3><blockquote>
<p>创建两个消费者</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bgt.rabbitmq.ps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Package: com.bgt.rabbitmq.simple</span></span><br><span class="line"><span class="comment"> * Description： 发布订阅模式 消费者接收消息</span></span><br><span class="line"><span class="comment"> * Author: bgt</span></span><br><span class="line"><span class="comment"> * Date: Created in 2020/9/19 7:53 下午</span></span><br><span class="line"><span class="comment"> * Company:</span></span><br><span class="line"><span class="comment"> * Copyright:</span></span><br><span class="line"><span class="comment"> * Version: 0.0.1</span></span><br><span class="line"><span class="comment"> * Modified By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//交换机</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String FANOUT_EXCHANGE=<span class="string">&quot;fanout_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String FANOUT_QUEUE1=<span class="string">&quot;fanout_queue1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.创建连接;</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"><span class="comment">//        2.创建频道;</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//3 声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(FANOUT_EXCHANGE,BuiltinExchangeType.FANOUT);</span><br><span class="line"><span class="comment">//        4.声明队列;</span></span><br><span class="line"><span class="comment">//        参数1:队列名称</span></span><br><span class="line"><span class="comment">//        参数2:是否定义持久化队列(消息会持久化保存在服务器上)</span></span><br><span class="line"><span class="comment">//        参数3:是否独占本连接</span></span><br><span class="line"><span class="comment">//        参数4:是否在不使用的时候队列自动删除</span></span><br><span class="line"><span class="comment">//        参数5:其它参数</span></span><br><span class="line">        channel.queueDeclare(FANOUT_QUEUE1,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//5 绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(FANOUT_QUEUE1,FANOUT_EXCHANGE,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//        5.创建消费者接收并处理消息</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//路由key 交换机 消息id 接受到的消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;路由key:&quot;</span>+envelope.getRoutingKey());</span><br><span class="line">                System.out.println(<span class="string">&quot;交换机:&quot;</span>+envelope.getExchange());</span><br><span class="line">                System.out.println(<span class="string">&quot;消息id:&quot;</span>+envelope.getDeliveryTag());</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者1---接受到的消息:&quot;</span>+<span class="keyword">new</span> String(body,<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//6 监听队列</span></span><br><span class="line"><span class="comment">//        参数1:队列名</span></span><br><span class="line"><span class="comment">//        参数2:是否要自动确认;设置为true表示消息接收到自动向MQ回复接收到了, MQ则会将消息从队列中删除;</span></span><br><span class="line"><span class="comment">//        如果设置为false则需要手动确认</span></span><br><span class="line"><span class="comment">//        参数3:消费者</span></span><br><span class="line">        channel.basicConsume(FANOUT_QUEUE1,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-2routing-路由模式"><a href="#5-2routing-路由模式" class="headerlink" title="5.2routing 路由模式"></a>5.2routing 路由模式</h2><blockquote>
<p>特点:</p>
<ul>
<li>队列与交换机的绑定,不能是任意绑定了,而是要指定一个Routingkey (路由key)</li>
<li>消息的发送方在向Exchange发送消息时,也必须指定消息的Routingkey.</li>
<li>Exchange不再把消息交给每一个绑定的队列,而是根据消息的Routing key进行判断,只有队列的Routingkey与消息的Routing key完全一致,才会接收到消息</li>
</ul>
</blockquote>
<p><strong>简单使用</strong>：</p>
<ul>
<li>生产者声明交换机类型为direct，把交换机和队列绑定的同时指定routingkey，发送消息时同样指定交换机和routingkey；</li>
<li>消费者声明交换机类型为direct，绑定队列和交换机的同时指定toutingkey，如果routingkey和生产者指定的routingkey一致才能接收到消息。</li>
</ul>
<p><img src="http://mele.cool//image-20200919212311753.png" alt="image-20200919212311753"></p>
<h3 id="5-2-1-生产者"><a href="#5-2-1-生产者" class="headerlink" title="5.2.1 生产者"></a>5.2.1 生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bgt.rabbitmq.routing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Package: com.bgt.rabbitmq.controller</span></span><br><span class="line"><span class="comment"> * Description： 路由模式  消息生产者</span></span><br><span class="line"><span class="comment"> * Author: bgt</span></span><br><span class="line"><span class="comment"> * Date: Created in 2020/9/19 5:27 下午</span></span><br><span class="line"><span class="comment"> * Company:</span></span><br><span class="line"><span class="comment"> * Copyright:</span></span><br><span class="line"><span class="comment"> * Version: 0.0.1</span></span><br><span class="line"><span class="comment"> * Modified By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//交换机</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DIRECT_EXCHANGE=<span class="string">&quot;direct_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DIRECT_QUEUE_INSERT=<span class="string">&quot;direct_queue_insert&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DIRECT_QUEUE_UPDATE=<span class="string">&quot;direct_queue_update&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//       1.创建连接;</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;myrouting&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"><span class="comment">//        2.创建频道;</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//3,声明交换机;参数1:交换机名称,参数2:交换机类型( fanout, direct, topic)</span></span><br><span class="line">        channel. exchangeDeclare (DIRECT_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//4．声明队列；</span></span><br><span class="line">        <span class="comment">/*参数1:队列名称</span></span><br><span class="line"><span class="comment">          参数2:是否定义持久化队列(消息会持久化保存在服务器上)</span></span><br><span class="line"><span class="comment">          参数3:是否独占本连接</span></span><br><span class="line"><span class="comment">         参数4:是否在不使用的时候队列自动删除</span></span><br><span class="line"><span class="comment">         参数5:其它参数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        channel. queueDeclare (DIRECT_QUEUE_INSERT, <span class="keyword">true</span>,  <span class="keyword">false</span>,  <span class="keyword">false</span>,  <span class="keyword">null</span>);</span><br><span class="line">        channel. queueDeclare (DIRECT_QUEUE_UPDATE, <span class="keyword">true</span>,  <span class="keyword">false</span>,  <span class="keyword">false</span>,  <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//      5.队列绑定到交换机 参数1:队列名称,参数2:交换机名称,参数3:路由key</span></span><br><span class="line">        channel. queueBind (DIRECT_QUEUE_INSERT, DIRECT_EXCHANGE,  <span class="string">&quot;insert&quot;</span>);</span><br><span class="line">        channel. queueBind (DIRECT_QUEUE_UPDATE, DIRECT_EXCHANGE,  <span class="string">&quot;update&quot;</span>);</span><br><span class="line">        <span class="comment">//6 发送消息</span></span><br><span class="line">        <span class="comment">//参数1:交换机名称;如果没有则指定空字符串(表示使用默认的交换机)参数2:路由key,简单模式中可以使用队列名称</span></span><br><span class="line">        <span class="comment">// 参数3：消息其它属性  参数4:消息内容</span></span><br><span class="line">        String msg=<span class="string">&quot;hello mq.路由模式--routingkey是insert&quot;</span>;</span><br><span class="line">        channel.basicPublish(DIRECT_EXCHANGE,<span class="string">&quot;insert&quot;</span>,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;已发送消息:&quot;</span>+msg);</span><br><span class="line">        msg=<span class="string">&quot;hello mq.路由模式--routingkey是update&quot;</span>;</span><br><span class="line">        channel.basicPublish(DIRECT_EXCHANGE,<span class="string">&quot;update&quot;</span>,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;已发送消息:&quot;</span>+msg);</span><br><span class="line"><span class="comment">//        6.关闭资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="5-2-2消费者"><a href="#5-2-2消费者" class="headerlink" title="5.2.2消费者"></a>5.2.2消费者</h3><blockquote>
<p>创建两个消费者,分别通过不同的routingkey绑定同一个交换机</p>
</blockquote>
<h4 id="5-2-2-1消费者1"><a href="#5-2-2-1消费者1" class="headerlink" title="5.2.2.1消费者1"></a>5.2.2.1消费者1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bgt.rabbitmq.routing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Package: com.bgt.rabbitmq.simple</span></span><br><span class="line"><span class="comment"> * Description： 发布订阅模式 消费者接收消息</span></span><br><span class="line"><span class="comment"> * Author: bgt</span></span><br><span class="line"><span class="comment"> * Date: Created in 2020/9/19 7:53 下午</span></span><br><span class="line"><span class="comment"> * Company:</span></span><br><span class="line"><span class="comment"> * Copyright:</span></span><br><span class="line"><span class="comment"> * Version: 0.0.1</span></span><br><span class="line"><span class="comment"> * Modified By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//交换机</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DIRECT_EXCHANGE=<span class="string">&quot;direct_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DIRECT_QUEUE_INSERT=<span class="string">&quot;direct_queue_insert&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.创建连接;</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;myrouting&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"><span class="comment">//        2.创建频道;</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//3 声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(DIRECT_EXCHANGE,BuiltinExchangeType.DIRECT);</span><br><span class="line"><span class="comment">//        4.声明队列;</span></span><br><span class="line"><span class="comment">//        参数1:队列名称</span></span><br><span class="line"><span class="comment">//        参数2:是否定义持久化队列(消息会持久化保存在服务器上)</span></span><br><span class="line"><span class="comment">//        参数3:是否独占本连接</span></span><br><span class="line"><span class="comment">//        参数4:是否在不使用的时候队列自动删除</span></span><br><span class="line"><span class="comment">//        参数5:其它参数</span></span><br><span class="line">        channel.queueDeclare(DIRECT_QUEUE_INSERT,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//5 绑定队列到交换机</span></span><br><span class="line">      <span class="comment">//备注:这一步应该可以不要,生产者发送消息时根据routingkey和交换机把消息发送到绑定的队列中,因此消费者只需要监听这个队列就可以获取消息,实测消费者不需要再次绑定交换机/队列/routingkey也可以取到消息,因此这行不需要.</span></span><br><span class="line">       <span class="comment">// channel.queueBind(DIRECT_QUEUE_INSERT,DIRECT_EXCHANGE,&quot;insert&quot;);</span></span><br><span class="line"><span class="comment">//        5.创建消费者接收并处理消息</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//路由key 交换机 消息id 接受到的消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;路由key:&quot;</span>+envelope.getRoutingKey());</span><br><span class="line">                System.out.println(<span class="string">&quot;交换机:&quot;</span>+envelope.getExchange());</span><br><span class="line">                System.out.println(<span class="string">&quot;消息id:&quot;</span>+envelope.getDeliveryTag());</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者1---接受到的消息:&quot;</span>+<span class="keyword">new</span> String(body,<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//6 监听队列</span></span><br><span class="line"><span class="comment">//        参数1:队列名</span></span><br><span class="line"><span class="comment">//        参数2:是否要自动确认;设置为true表示消息接收到自动向MQ回复接收到了, MQ则会将消息从队列中删除;</span></span><br><span class="line"><span class="comment">//        如果设置为false则需要手动确认</span></span><br><span class="line"><span class="comment">//        参数3:消费者</span></span><br><span class="line">        channel.basicConsume(DIRECT_QUEUE_INSERT,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="5-2-2-2消费者2"><a href="#5-2-2-2消费者2" class="headerlink" title="5.2.2.2消费者2"></a>5.2.2.2消费者2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bgt.rabbitmq.routing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Package: com.bgt.rabbitmq.simple</span></span><br><span class="line"><span class="comment"> * Description： 发布订阅模式 消费者接收消息</span></span><br><span class="line"><span class="comment"> * Author: bgt</span></span><br><span class="line"><span class="comment"> * Date: Created in 2020/9/19 7:53 下午</span></span><br><span class="line"><span class="comment"> * Company:</span></span><br><span class="line"><span class="comment"> * Copyright:</span></span><br><span class="line"><span class="comment"> * Version: 0.0.1</span></span><br><span class="line"><span class="comment"> * Modified By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//交换机</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DIRECT_EXCHANGE=<span class="string">&quot;direct_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DIRECT_QUEUE_UPDATE=<span class="string">&quot;direct_queue_update&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.创建连接;</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//主机；默认localhost 连接端口；默认5672   虚拟主机:默认/;  默认用户名:guest</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;myrouting&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"><span class="comment">//        2.创建频道;</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//3 声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(DIRECT_EXCHANGE,BuiltinExchangeType.DIRECT);</span><br><span class="line"><span class="comment">//        4.声明队列;</span></span><br><span class="line"><span class="comment">//        参数1:队列名称</span></span><br><span class="line"><span class="comment">//        参数2:是否定义持久化队列(消息会持久化保存在服务器上)</span></span><br><span class="line"><span class="comment">//        参数3:是否独占本连接</span></span><br><span class="line"><span class="comment">//        参数4:是否在不使用的时候队列自动删除</span></span><br><span class="line"><span class="comment">//        参数5:其它参数</span></span><br><span class="line">        channel.queueDeclare(DIRECT_QUEUE_UPDATE,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//5 绑定队列到交换机</span></span><br><span class="line">       <span class="comment">//备注:这一步应该可以不要,生产者发送消息时根据routingkey和交换机把消息发送到绑定的队列中,因此消费者只需要监听这个队列就可以获取消息,实测消费者不需要再次绑定交换机/队列/routingkey也可以取到消息,因此这行不需要.</span></span><br><span class="line">        <span class="comment">//channel.queueBind(DIRECT_QUEUE_UPDATE,DIRECT_EXCHANGE,&quot;update&quot;);</span></span><br><span class="line"><span class="comment">//        5.创建消费者接收并处理消息</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//路由key 交换机 消息id 接受到的消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;路由key:&quot;</span>+envelope.getRoutingKey());</span><br><span class="line">                System.out.println(<span class="string">&quot;交换机:&quot;</span>+envelope.getExchange());</span><br><span class="line">                System.out.println(<span class="string">&quot;消息id:&quot;</span>+envelope.getDeliveryTag());</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者1---接受到的消息:&quot;</span>+<span class="keyword">new</span> String(body,<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//6 监听队列</span></span><br><span class="line"><span class="comment">//        参数1:队列名</span></span><br><span class="line"><span class="comment">//        参数2:是否要自动确认;设置为true表示消息接收到自动向MQ回复接收到了, MQ则会将消息从队列中删除;</span></span><br><span class="line"><span class="comment">//        如果设置为false则需要手动确认</span></span><br><span class="line"><span class="comment">//        参数3:消费者</span></span><br><span class="line">        channel.basicConsume(DIRECT_QUEUE_UPDATE,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-3-topics通配符模式"><a href="#5-3-topics通配符模式" class="headerlink" title="5.3 topics通配符模式"></a>5.3 topics通配符模式</h2><blockquote>
<p>Topic类型与Direct相比,都是可以根据Routingkey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key的时候使用通配符!<br>Routingkey一般都是有一个或多个单词组成,多个单词之间以”.”分割,例如: item.inser</p>
</blockquote>
<p><strong>通配符规则:</strong></p>
<ul>
<li>#：匹配一个或多个词</li>
<li>*:   匹配不多不少恰好1个词</li>
</ul>
<p><strong>举例:</strong></p>
<ul>
<li>item.#:能够匹配item.insert.abc或者item.insertitem.</li>
<li>*:只能匹配item.insert</li>
</ul>
<p><img src="http://mele.cool//image-20200919215028302.png" alt="image-20200919215028302"></p>
<p><img src="http://mele.cool//image-20200919215432002.png" alt="image-20200919215432002"></p>
<h3 id="5-3-1生产者"><a href="#5-3-1生产者" class="headerlink" title="5.3.1生产者"></a>5.3.1生产者</h3><p>基于路由模式代码改造如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明交换机;交换机类型改为通配符模式</span></span><br><span class="line">channel.exchangeDeclare (TOPIC EXCHAGE, BuiltinExchangeType. TOPIC) :</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送三条消息指定不同的routingkey</span></span><br><span class="line">channel.basicPublish (TOPIC EXCHAGE, routingKey: <span class="string">&quot;item.insert&quot;</span>, props: <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">channel.basicPublish (TOPIC EXCHAGE, routingKey: <span class="string">&quot;item.update&quot;</span>, props: <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">channel.basicPublish (TOPIC EXCHAGE, routingKey: <span class="string">&quot;item.delete&quot;</span>, props: <span class="keyword">null</span>, message.getBytes());</span><br></pre></td></tr></table></figure>
<h3 id="5-3-2-消费者"><a href="#5-3-2-消费者" class="headerlink" title="5.3.2 消费者"></a>5.3.2 消费者</h3><blockquote>
<p>两个消费者</p>
</blockquote>
<p> 基于路由模式代码改造如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明交换机;交换机类型改为通配符模式</span></span><br><span class="line">channel.exchangeDeclare (Producer. TOPIC EXCHAGE, BuiltinExchangeType.TOPIC);</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者1绑定这两个指定routingkey</span></span><br><span class="line">channel.queueBind (Producer.TOPIC_QUEUE1, Producer.TOPIC_EXCHAGE, <span class="string">&quot;item.update&quot;</span>);</span><br><span class="line">channel.queueBind (Producer.TOPIC_QUEUE1, Producer.TOPIC_EXCHAGE, <span class="string">&quot;item.delete&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者2绑定通配符模式的routingkey</span></span><br><span class="line">channel.queueBind (Producer.TOPIC_QUEUE2, Producer.TOPIC_EXCHAGE, <span class="string">&quot;item.*&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="5-4-rabbitmq模式总结"><a href="#5-4-rabbitmq模式总结" class="headerlink" title="5.4 rabbitmq模式总结"></a>5.4 rabbitmq模式总结</h2><p><img src="http://mele.cool//image-20200919221146270.png" alt="image-20200919221146270"></p>
<h1 id="6-springboot整合rabbitmq"><a href="#6-springboot整合rabbitmq" class="headerlink" title="6.springboot整合rabbitmq"></a>6.springboot整合rabbitmq</h1><blockquote>
<p>Spring Boot提供了对于AMQP的整合;可以使月RabbitTemplate发送消息;可以使用@RabbitListener注解接收消息。</p>
<p><strong>示例通配符模式</strong></p>
</blockquote>
<h2 id="6-1-生产者工程"><a href="#6-1-生产者工程" class="headerlink" title="6.1 生产者工程"></a>6.1 生产者工程</h2><h3 id="6-1-1-添加依赖"><a href="#6-1-1-添加依赖" class="headerlink" title="6.1.1 添加依赖"></a>6.1.1 添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--rabbitmq发送消息核心依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.bootk/groupId&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amgp&lt;/artifactrds</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--rabbitmq发送消息测试依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.bootk/groupId&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test&lt;/artifactrds</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>	</span><br></pre></td></tr></table></figure>


<h3 id="6-1-2-添加配置文件"><a href="#6-1-2-添加配置文件" class="headerlink" title="6.1.2 添加配置文件"></a>6.1.2 添加配置文件</h3><blockquote>
<p>application.properties配置rabbitmq连接信息</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> </span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br></pre></td></tr></table></figure>
<h3 id="6-1-3-创建配置类"><a href="#6-1-3-创建配置类" class="headerlink" title="6.1.3 创建配置类"></a>6.1.3 创建配置类</h3><p><img src="http://mele.cool//image-20200919222543932.png" alt="image-20200919222543932"></p>
<h3 id="6-1-4-创建发送消息类"><a href="#6-1-4-创建发送消息类" class="headerlink" title="6.1.4 创建发送消息类"></a>6.1.4 创建发送消息类</h3><p><img src="http://mele.cool//image-20200919223251686.png" alt="image-20200919223251686"></p>
<h2 id="6-2-消费者工程"><a href="#6-2-消费者工程" class="headerlink" title="6.2 消费者工程"></a>6.2 消费者工程</h2><h3 id="6-2-1-添加依赖"><a href="#6-2-1-添加依赖" class="headerlink" title="6.2.1 添加依赖"></a>6.2.1 添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--rabbitmq发送消息核心依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.bootk/groupId&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amgp&lt;/artifactrds</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="6-2-2-添加配置文件"><a href="#6-2-2-添加配置文件" class="headerlink" title="6.2.2 添加配置文件"></a>6.2.2 添加配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> </span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-3-编写消息监听器类"><a href="#6-2-3-编写消息监听器类" class="headerlink" title="6.2.3 编写消息监听器类"></a>6.2.3 编写消息监听器类</h3><h1 id=""><a href="#" class="headerlink" title=""></a><img src="http://mele.cool//image-20200919222909121.png" alt="image-20200919222909121"></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/02/rabbitmq/" data-id="ckke5nr57009gcl8g4uwicaqz" data-title="rabbitmq" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rabbitmq-mq/" rel="tag">rabbitmq - mq</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/bug/">bug</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/db/">db</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hello-world/">hello world</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mele/">mele</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mq/">mq</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/springCloud/">springCloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/springboot/">springboot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/">工具类</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/">版本控制</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/acid/" rel="tag">acid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aop/" rel="tag">aop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/baby/" rel="tag">baby</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bug/" rel="tag">bug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/" rel="tag">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/excel/" rel="tag">excel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/executors/" rel="tag">executors</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/explain/" rel="tag">explain</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/filter/" rel="tag">filter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/freemarker/" rel="tag">freemarker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/" rel="tag">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/httpServerletRequest/" rel="tag">httpServerletRequest</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/httpclient/" rel="tag">httpclient</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/idea/" rel="tag">idea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interceptor/" rel="tag">interceptor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ioc/" rel="tag">ioc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ip/" rel="tag">ip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%9F%BA%E7%A1%80/" rel="tag">java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdbcTemplate/" rel="tag">jdbcTemplate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdk8-java/" rel="tag">jdk8 - java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/" rel="tag">mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/" rel="tag">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/md/" rel="tag">md</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mele/" rel="tag">mele</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mq/" rel="tag">mq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ms/" rel="tag">ms</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oracle/" rel="tag">oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pagehelper-%E5%88%86%E9%A1%B5/" rel="tag">pagehelper - 分页</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/photo/" rel="tag">photo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rabbitmq-mq/" rel="tag">rabbitmq - mq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis-db/" rel="tag">redis - db</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springApplication/" rel="tag">springApplication</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springCloud/" rel="tag">springCloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/" rel="tag">springboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql%E4%BC%98%E5%8C%96/" rel="tag">sql优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stream/" rel="tag">stream</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/struts2/" rel="tag">struts2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/threadPollExecutor/" rel="tag">threadPollExecutor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thymeleaf/" rel="tag">thymeleaf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/" rel="tag">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/" rel="tag">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/war/" rel="tag">war</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webservice/" rel="tag">webservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/word/" rel="tag">word</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xml/" rel="tag">xml</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%BB%E9%94%AE/" rel="tag">主键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81/" rel="tag">代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%A5%E5%8F%A3%E7%B1%BB/" rel="tag">入口类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%A5%E9%97%A8/" rel="tag">入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%AC%E9%92%A5/" rel="tag">公钥</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E9%A1%B5/" rel="tag">分页</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" rel="tag">单元测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E7%90%86/" rel="tag">原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%91%BD%E4%BB%A4/" rel="tag">命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-java/" rel="tag">多线程 - java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%BC%E5%87%BA/" rel="tag">导出</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/" rel="tag">工具类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%B8%E7%94%A8/" rel="tag">常用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E5%B8%B8/" rel="tag">异常</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/" rel="tag">异步调用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/" rel="tag">拦截器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97/" rel="tag">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E6%9D%BF/" rel="tag">模板</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E8%A7%A3/" rel="tag">注解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A/" rel="tag">注释</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/" rel="tag">热部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9B%91%E6%8E%A7/" rel="tag">监控</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/" rel="tag">箭头函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag">线程池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/" rel="tag">自动装配</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/" rel="tag">过滤器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%82%AE%E4%BB%B6/" rel="tag">邮件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E5%90%88/" rel="tag">集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/" rel="tag">雪花算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/acid/" style="font-size: 11.67px;">acid</a> <a href="/tags/aop/" style="font-size: 10px;">aop</a> <a href="/tags/baby/" style="font-size: 10px;">baby</a> <a href="/tags/bug/" style="font-size: 11.67px;">bug</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/dubbo/" style="font-size: 10px;">dubbo</a> <a href="/tags/excel/" style="font-size: 10px;">excel</a> <a href="/tags/executors/" style="font-size: 10px;">executors</a> <a href="/tags/explain/" style="font-size: 10px;">explain</a> <a href="/tags/filter/" style="font-size: 10px;">filter</a> <a href="/tags/freemarker/" style="font-size: 10px;">freemarker</a> <a href="/tags/git/" style="font-size: 13.33px;">git</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/httpServerletRequest/" style="font-size: 10px;">httpServerletRequest</a> <a href="/tags/httpclient/" style="font-size: 10px;">httpclient</a> <a href="/tags/idea/" style="font-size: 10px;">idea</a> <a href="/tags/interceptor/" style="font-size: 10px;">interceptor</a> <a href="/tags/ioc/" style="font-size: 10px;">ioc</a> <a href="/tags/ip/" style="font-size: 10px;">ip</a> <a href="/tags/java/" style="font-size: 18.33px;">java</a> <a href="/tags/java%E5%9F%BA%E7%A1%80/" style="font-size: 11.67px;">java基础</a> <a href="/tags/jdbcTemplate/" style="font-size: 10px;">jdbcTemplate</a> <a href="/tags/jdk8-java/" style="font-size: 10px;">jdk8 - java</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/linux/" style="font-size: 13.33px;">linux</a> <a href="/tags/mac/" style="font-size: 10px;">mac</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/md/" style="font-size: 10px;">md</a> <a href="/tags/mele/" style="font-size: 10px;">mele</a> <a href="/tags/mq/" style="font-size: 11.67px;">mq</a> <a href="/tags/ms/" style="font-size: 11.67px;">ms</a> <a href="/tags/mybatis/" style="font-size: 15px;">mybatis</a> <a href="/tags/oracle/" style="font-size: 11.67px;">oracle</a> <a href="/tags/pagehelper-%E5%88%86%E9%A1%B5/" style="font-size: 10px;">pagehelper - 分页</a> <a href="/tags/photo/" style="font-size: 10px;">photo</a> <a href="/tags/rabbitmq-mq/" style="font-size: 10px;">rabbitmq - mq</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/redis-db/" style="font-size: 10px;">redis - db</a> <a href="/tags/spring/" style="font-size: 11.67px;">spring</a> <a href="/tags/springApplication/" style="font-size: 10px;">springApplication</a> <a href="/tags/springCloud/" style="font-size: 11.67px;">springCloud</a> <a href="/tags/springboot/" style="font-size: 20px;">springboot</a> <a href="/tags/sql%E4%BC%98%E5%8C%96/" style="font-size: 10px;">sql优化</a> <a href="/tags/stream/" style="font-size: 10px;">stream</a> <a href="/tags/struts2/" style="font-size: 10px;">struts2</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/threadPollExecutor/" style="font-size: 10px;">threadPollExecutor</a> <a href="/tags/thymeleaf/" style="font-size: 10px;">thymeleaf</a> <a href="/tags/tomcat/" style="font-size: 11.67px;">tomcat</a> <a href="/tags/tool/" style="font-size: 13.33px;">tool</a> <a href="/tags/war/" style="font-size: 10px;">war</a> <a href="/tags/webservice/" style="font-size: 10px;">webservice</a> <a href="/tags/word/" style="font-size: 10px;">word</a> <a href="/tags/xml/" style="font-size: 11.67px;">xml</a> <a href="/tags/%E4%B8%BB%E9%94%AE/" style="font-size: 10px;">主键</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 11.67px;">事务</a> <a href="/tags/%E4%BB%A3%E7%A0%81/" style="font-size: 10px;">代码</a> <a href="/tags/%E5%85%A5%E5%8F%A3%E7%B1%BB/" style="font-size: 10px;">入口类</a> <a href="/tags/%E5%85%A5%E9%97%A8/" style="font-size: 11.67px;">入门</a> <a href="/tags/%E5%85%AC%E9%92%A5/" style="font-size: 10px;">公钥</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 11.67px;">分布式</a> <a href="/tags/%E5%88%86%E9%A1%B5/" style="font-size: 10px;">分页</a> <a href="/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">单元测试</a> <a href="/tags/%E5%8E%9F%E7%90%86/" style="font-size: 10px;">原理</a> <a href="/tags/%E5%91%BD%E4%BB%A4/" style="font-size: 10px;">命令</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-java/" style="font-size: 10px;">多线程 - java</a> <a href="/tags/%E5%AF%BC%E5%87%BA/" style="font-size: 10px;">导出</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/" style="font-size: 16.67px;">工具类</a> <a href="/tags/%E5%B8%B8%E7%94%A8/" style="font-size: 10px;">常用</a> <a href="/tags/%E5%BC%82%E5%B8%B8/" style="font-size: 10px;">异常</a> <a href="/tags/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/" style="font-size: 10px;">异步调用</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/" style="font-size: 10px;">拦截器</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 11.67px;">日志</a> <a href="/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 10px;">模板</a> <a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 10px;">注解</a> <a href="/tags/%E6%B3%A8%E9%87%8A/" style="font-size: 10px;">注释</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 10px;">消息队列</a> <a href="/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">热部署</a> <a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 10px;">监控</a> <a href="/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/" style="font-size: 10px;">箭头函数</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 11.67px;">线程池</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 10px;">缓存</a> <a href="/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/" style="font-size: 10px;">自动装配</a> <a href="/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/" style="font-size: 10px;">过滤器</a> <a href="/tags/%E9%82%AE%E4%BB%B6/" style="font-size: 10px;">邮件</a> <a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 10px;">集合</a> <a href="/tags/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/" style="font-size: 10px;">雪花算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/23/redis%E6%95%99%E7%A8%8B%E6%95%88%E7%8E%87%E7%89%88/">redis入门效率版</a>
          </li>
        
          <li>
            <a href="/2021/01/22/%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86/">开发中注意的小问题</a>
          </li>
        
          <li>
            <a href="/2021/01/02/SQL%E8%AF%AD%E5%8F%A5%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/">SQL语句性能提升</a>
          </li>
        
          <li>
            <a href="/2020/12/15/%E9%9B%86%E5%90%88%E5%88%86%E9%A1%B5%E5%B7%A5%E5%85%B7%E7%B1%BB/">集合分页工具类</a>
          </li>
        
          <li>
            <a href="/2020/12/10/%E5%8F%AA%E4%BF%AE%E6%94%B9%E5%87%A0%E8%A1%8C%EF%BC%8Cgit%E5%8D%B4%E6%98%BE%E7%A4%BA%E6%95%B4%E4%B8%AA%E6%96%87%E4%BB%B6%E9%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9/">只修改几行，git却显示整个文件都被修改</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>